// Code generated by ryegen. DO NOT EDIT.

// You can add custom binding code to builtins_custom.go!

//go:build !b_no_gioui

package gioui_org

import (
	"errors"
	"fmt"
	"gioui.org/app"
	"gioui.org/f32"
	"gioui.org/font"
	"gioui.org/font/gofont"
	"gioui.org/font/opentype"
	"gioui.org/gesture"
	"gioui.org/gpu"
	"gioui.org/gpu/headless"
	"gioui.org/io/clipboard"
	"gioui.org/io/event"
	"gioui.org/io/input"
	"gioui.org/io/key"
	"gioui.org/io/pointer"
	"gioui.org/io/semantic"
	"gioui.org/io/system"
	"gioui.org/io/transfer"
	"gioui.org/layout"
	"gioui.org/op"
	"gioui.org/op/clip"
	"gioui.org/op/paint"
	"gioui.org/text"
	"gioui.org/unit"
	"gioui.org/widget"
	"gioui.org/widget/material"
	typesetting_font "github.com/go-text/typesetting/font"
	"github.com/go-text/typesetting/opentype/api/metadata"
	"github.com/refaktor/rye/env"
	"github.com/refaktor/rye/evaldo"
	"golang.org/x/image/math/fixed"
	"image"
	"image/color"
	"io"
	"reflect"
	"time"
)

var Builtins map[string]*env.Builtin

func init() {
	Builtins = make(map[string]*env.Builtin, len(builtinsGenerated)+len(builtinsCustom))
	for k, v := range builtinsGenerated {
		Builtins[k] = v
	}
	for k, v := range builtinsCustom {
		Builtins[k] = v
	}
}

// Force-use evaldo and env packages since tracking them would be too complicated
var _ = evaldo.BuiltinNames
var _ = env.Object(nil)

func boolToInt64(x bool) int64 {
	var res int64
	if x {
		res = 1
	}
	return res
}

func ifaceToNative(idx *env.Idxs, v any, ifaceName string) env.Native {
	rV := reflect.ValueOf(v)
	var typRyeName string
	var ok bool
	if rV.Type() != nil {
		var typPfx string
		if rV.Type().Kind() == reflect.Struct {
			newRV := reflect.New(rV.Type())
			newRV.Elem().Set(rV)
			rV = newRV
		}
		typ := rV.Type()
		if typ.Kind() == reflect.Pointer {
			typ = rV.Type().Elem()
			typPfx = "*"
		}
		typRyeName, ok = ryeStructNameLookup[typ.PkgPath()+"."+typPfx+typ.Name()]
	}
	if ok {
		return *env.NewNative(idx, rV.Interface(), typRyeName)
	} else {
		return *env.NewNative(idx, rV.Interface(), ifaceName)
	}
}

var ryeStructNameLookup = map[string]string{
	"gioui.org/app.*Config":                           "Go(*app.Config)",
	"gioui.org/app.*ConfigEvent":                      "Go(*app.ConfigEvent)",
	"gioui.org/app.*DestroyEvent":                     "Go(*app.DestroyEvent)",
	"gioui.org/app.*FrameEvent":                       "Go(*app.FrameEvent)",
	"gioui.org/app.*Insets":                           "Go(*app.Insets)",
	"gioui.org/app.*Window":                           "Go(*app.Window)",
	"gioui.org/f32.*Affine2D":                         "Go(*f32.Affine2D)",
	"gioui.org/f32.*Point":                            "Go(*f32.Point)",
	"gioui.org/font.*Font":                            "Go(*font.Font)",
	"gioui.org/font.*FontFace":                        "Go(*font.FontFace)",
	"gioui.org/font/opentype.*Face":                   "Go(*opentype.Face)",
	"gioui.org/gesture.*Click":                        "Go(*gesture.Click)",
	"gioui.org/gesture.*ClickEvent":                   "Go(*gesture.ClickEvent)",
	"gioui.org/gesture.*Drag":                         "Go(*gesture.Drag)",
	"gioui.org/gesture.*Hover":                        "Go(*gesture.Hover)",
	"gioui.org/gesture.*Scroll":                       "Go(*gesture.Scroll)",
	"gioui.org/gpu.*FBO":                              "Go(*gpu.FBO)",
	"gioui.org/gpu/headless.*Window":                  "Go(*headless.Window)",
	"gioui.org/io/clipboard.*ReadCmd":                 "Go(*clipboard.ReadCmd)",
	"gioui.org/io/clipboard.*WriteCmd":                "Go(*clipboard.WriteCmd)",
	"gioui.org/io/input.*EditorState":                 "Go(*input.EditorState)",
	"gioui.org/io/input.*Router":                      "Go(*input.Router)",
	"gioui.org/io/input.*SemanticDesc":                "Go(*input.SemanticDesc)",
	"gioui.org/io/input.*SemanticNode":                "Go(*input.SemanticNode)",
	"gioui.org/io/input.*Source":                      "Go(*input.Source)",
	"gioui.org/io/input.*SystemEvent":                 "Go(*input.SystemEvent)",
	"gioui.org/io/key.*Caret":                         "Go(*key.Caret)",
	"gioui.org/io/key.*EditEvent":                     "Go(*key.EditEvent)",
	"gioui.org/io/key.*Event":                         "Go(*key.Event)",
	"gioui.org/io/key.*Filter":                        "Go(*key.Filter)",
	"gioui.org/io/key.*FocusCmd":                      "Go(*key.FocusCmd)",
	"gioui.org/io/key.*FocusEvent":                    "Go(*key.FocusEvent)",
	"gioui.org/io/key.*FocusFilter":                   "Go(*key.FocusFilter)",
	"gioui.org/io/key.*InputHintOp":                   "Go(*key.InputHintOp)",
	"gioui.org/io/key.*Range":                         "Go(*key.Range)",
	"gioui.org/io/key.*SelectionCmd":                  "Go(*key.SelectionCmd)",
	"gioui.org/io/key.*Snippet":                       "Go(*key.Snippet)",
	"gioui.org/io/key.*SnippetCmd":                    "Go(*key.SnippetCmd)",
	"gioui.org/io/key.*SoftKeyboardCmd":               "Go(*key.SoftKeyboardCmd)",
	"gioui.org/io/pointer.*Event":                     "Go(*pointer.Event)",
	"gioui.org/io/pointer.*Filter":                    "Go(*pointer.Filter)",
	"gioui.org/io/pointer.*GrabCmd":                   "Go(*pointer.GrabCmd)",
	"gioui.org/io/pointer.*PassOp":                    "Go(*pointer.PassOp)",
	"gioui.org/io/pointer.*PassStack":                 "Go(*pointer.PassStack)",
	"gioui.org/io/pointer.*ScrollRange":               "Go(*pointer.ScrollRange)",
	"gioui.org/io/system.*Locale":                     "Go(*system.Locale)",
	"gioui.org/io/transfer.*CancelEvent":              "Go(*transfer.CancelEvent)",
	"gioui.org/io/transfer.*DataEvent":                "Go(*transfer.DataEvent)",
	"gioui.org/io/transfer.*InitiateEvent":            "Go(*transfer.InitiateEvent)",
	"gioui.org/io/transfer.*OfferCmd":                 "Go(*transfer.OfferCmd)",
	"gioui.org/io/transfer.*RequestEvent":             "Go(*transfer.RequestEvent)",
	"gioui.org/io/transfer.*SourceFilter":             "Go(*transfer.SourceFilter)",
	"gioui.org/io/transfer.*TargetFilter":             "Go(*transfer.TargetFilter)",
	"gioui.org/layout.*Background":                    "Go(*layout.Background)",
	"gioui.org/layout.*Constraints":                   "Go(*layout.Constraints)",
	"gioui.org/layout.*Context":                       "Go(*layout.Context)",
	"gioui.org/layout.*Dimensions":                    "Go(*layout.Dimensions)",
	"gioui.org/layout.*Flex":                          "Go(*layout.Flex)",
	"gioui.org/layout.*FlexChild":                     "Go(*layout.FlexChild)",
	"gioui.org/layout.*Inset":                         "Go(*layout.Inset)",
	"gioui.org/layout.*List":                          "Go(*layout.List)",
	"gioui.org/layout.*Position":                      "Go(*layout.Position)",
	"gioui.org/layout.*Spacer":                        "Go(*layout.Spacer)",
	"gioui.org/layout.*Stack":                         "Go(*layout.Stack)",
	"gioui.org/layout.*StackChild":                    "Go(*layout.StackChild)",
	"gioui.org/op.*CallOp":                            "Go(*op.CallOp)",
	"gioui.org/op.*InvalidateCmd":                     "Go(*op.InvalidateCmd)",
	"gioui.org/op.*MacroOp":                           "Go(*op.MacroOp)",
	"gioui.org/op.*Ops":                               "Go(*op.Ops)",
	"gioui.org/op.*TransformOp":                       "Go(*op.TransformOp)",
	"gioui.org/op.*TransformStack":                    "Go(*op.TransformStack)",
	"gioui.org/op/clip.*Op":                           "Go(*clip.Op)",
	"gioui.org/op/clip.*Outline":                      "Go(*clip.Outline)",
	"gioui.org/op/clip.*Path":                         "Go(*clip.Path)",
	"gioui.org/op/clip.*PathSpec":                     "Go(*clip.PathSpec)",
	"gioui.org/op/clip.*RRect":                        "Go(*clip.RRect)",
	"gioui.org/op/clip.*Stack":                        "Go(*clip.Stack)",
	"gioui.org/op/clip.*Stroke":                       "Go(*clip.Stroke)",
	"gioui.org/op/paint.*ColorOp":                     "Go(*paint.ColorOp)",
	"gioui.org/op/paint.*ImageOp":                     "Go(*paint.ImageOp)",
	"gioui.org/op/paint.*LinearGradientOp":            "Go(*paint.LinearGradientOp)",
	"gioui.org/op/paint.*OpacityStack":                "Go(*paint.OpacityStack)",
	"gioui.org/op/paint.*PaintOp":                     "Go(*paint.PaintOp)",
	"gioui.org/text.*Glyph":                           "Go(*text.Glyph)",
	"gioui.org/text.*Parameters":                      "Go(*text.Parameters)",
	"gioui.org/text.*Range":                           "Go(*text.Range)",
	"gioui.org/text.*Shaper":                          "Go(*text.Shaper)",
	"gioui.org/unit.*Metric":                          "Go(*unit.Metric)",
	"gioui.org/widget.*Bool":                          "Go(*widget.Bool)",
	"gioui.org/widget.*Border":                        "Go(*widget.Border)",
	"gioui.org/widget.*ChangeEvent":                   "Go(*widget.ChangeEvent)",
	"gioui.org/widget.*Click":                         "Go(*widget.Click)",
	"gioui.org/widget.*Clickable":                     "Go(*widget.Clickable)",
	"gioui.org/widget.*Decorations":                   "Go(*widget.Decorations)",
	"gioui.org/widget.*Draggable":                     "Go(*widget.Draggable)",
	"gioui.org/widget.*Editor":                        "Go(*widget.Editor)",
	"gioui.org/widget.*Enum":                          "Go(*widget.Enum)",
	"gioui.org/widget.*Float":                         "Go(*widget.Float)",
	"gioui.org/widget.*Icon":                          "Go(*widget.Icon)",
	"gioui.org/widget.*Image":                         "Go(*widget.Image)",
	"gioui.org/widget.*Label":                         "Go(*widget.Label)",
	"gioui.org/widget.*List":                          "Go(*widget.List)",
	"gioui.org/widget.*Press":                         "Go(*widget.Press)",
	"gioui.org/widget.*Region":                        "Go(*widget.Region)",
	"gioui.org/widget.*Scrollbar":                     "Go(*widget.Scrollbar)",
	"gioui.org/widget.*SelectEvent":                   "Go(*widget.SelectEvent)",
	"gioui.org/widget.*Selectable":                    "Go(*widget.Selectable)",
	"gioui.org/widget.*SubmitEvent":                   "Go(*widget.SubmitEvent)",
	"gioui.org/widget.*TextInfo":                      "Go(*widget.TextInfo)",
	"gioui.org/widget/material.*ButtonLayoutStyle":    "Go(*material.ButtonLayoutStyle)",
	"gioui.org/widget/material.*ButtonStyle":          "Go(*material.ButtonStyle)",
	"gioui.org/widget/material.*CheckBoxStyle":        "Go(*material.CheckBoxStyle)",
	"gioui.org/widget/material.*DecorationsStyle":     "Go(*material.DecorationsStyle)",
	"gioui.org/widget/material.*EditorStyle":          "Go(*material.EditorStyle)",
	"gioui.org/widget/material.*IconButtonStyle":      "Go(*material.IconButtonStyle)",
	"gioui.org/widget/material.*LabelStyle":           "Go(*material.LabelStyle)",
	"gioui.org/widget/material.*ListStyle":            "Go(*material.ListStyle)",
	"gioui.org/widget/material.*LoaderStyle":          "Go(*material.LoaderStyle)",
	"gioui.org/widget/material.*Palette":              "Go(*material.Palette)",
	"gioui.org/widget/material.*ProgressBarStyle":     "Go(*material.ProgressBarStyle)",
	"gioui.org/widget/material.*ProgressCircleStyle":  "Go(*material.ProgressCircleStyle)",
	"gioui.org/widget/material.*RadioButtonStyle":     "Go(*material.RadioButtonStyle)",
	"gioui.org/widget/material.*ScrollIndicatorStyle": "Go(*material.ScrollIndicatorStyle)",
	"gioui.org/widget/material.*ScrollTrackStyle":     "Go(*material.ScrollTrackStyle)",
	"gioui.org/widget/material.*ScrollbarStyle":       "Go(*material.ScrollbarStyle)",
	"gioui.org/widget/material.*SliderStyle":          "Go(*material.SliderStyle)",
	"gioui.org/widget/material.*SwitchStyle":          "Go(*material.SwitchStyle)",
	"gioui.org/widget/material.*Theme":                "Go(*material.Theme)",
}

type iface_event_Event struct {
	self               env.RyeCtx
	fn_ImplementsEvent func(self env.RyeCtx)
}

func (self *iface_event_Event) ImplementsEvent() {
	self.fn_ImplementsEvent(self.self)
}

func ctxTo_event_Event(ps *env.ProgramState, v env.RyeCtx) (event.Event, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_event_Event{
		self: v,
	}
	ctxObj0, ok := wordToObj["implements-event"]
	if !ok {
		return nil, errors.New("context to event.Event: expected context to have function ImplementsEvent")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to event.Event: context fn ImplementsEvent: function has invalid number of arguments (expected 0)")
		}
		impl.fn_ImplementsEvent = func(ctx env.RyeCtx) {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
		}
	default:
		return nil, errors.New("context to event.Event: context fn ImplementsEvent: expected function")
	}
	return impl, nil
}

type iface_event_Filter struct {
	self                env.RyeCtx
	fn_ImplementsFilter func(self env.RyeCtx)
}

func (self *iface_event_Filter) ImplementsFilter() {
	self.fn_ImplementsFilter(self.self)
}

func ctxTo_event_Filter(ps *env.ProgramState, v env.RyeCtx) (event.Filter, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_event_Filter{
		self: v,
	}
	ctxObj0, ok := wordToObj["implements-filter"]
	if !ok {
		return nil, errors.New("context to event.Filter: expected context to have function ImplementsFilter")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to event.Filter: context fn ImplementsFilter: function has invalid number of arguments (expected 0)")
		}
		impl.fn_ImplementsFilter = func(ctx env.RyeCtx) {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
		}
	default:
		return nil, errors.New("context to event.Filter: context fn ImplementsFilter: expected function")
	}
	return impl, nil
}

type iface_event_Tag struct {
	self env.RyeCtx
}

func ctxTo_event_Tag(ps *env.ProgramState, v env.RyeCtx) (event.Tag, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_event_Tag{
		self: v,
	}
	return impl, nil
}

type iface_font_Face struct {
	self    env.RyeCtx
	fn_Face func(self env.RyeCtx) typesetting_font.Face
}

func (self *iface_font_Face) Face() typesetting_font.Face {
	return self.fn_Face(self.self)
}

func ctxTo_font_Face(ps *env.ProgramState, v env.RyeCtx) (font.Face, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_font_Face{
		self: v,
	}
	ctxObj0, ok := wordToObj["face"]
	if !ok {
		return nil, errors.New("context to font.Face: expected context to have function Face")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to font.Face: context fn Face: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Face = func(ctx env.RyeCtx) typesetting_font.Face {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
			var res typesetting_font.Face
			switch v := ps.Res.(type) {
			case env.Native:
				var ok bool
				res, ok = v.Value.(typesetting_font.Face)
				if !ok {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to font.Face: arg 0: callback result: expected native of type typesetting_font.Face",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to font.Face: arg 0: callback result: expected native",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to font.Face: context fn Face: expected function")
	}
	return impl, nil
}

type iface_gpu_GPU struct {
	self       env.RyeCtx
	fn_Release func(self env.RyeCtx)
	fn_Clear   func(self env.RyeCtx, arg0 color.NRGBA)
	fn_Frame   func(self env.RyeCtx, arg0 *op.Ops, arg1 gpu.RenderTarget, arg2 image.Point) error
}

func (self *iface_gpu_GPU) Release() {
	self.fn_Release(self.self)
}
func (self *iface_gpu_GPU) Clear(arg0 color.NRGBA) {
	self.fn_Clear(self.self, arg0)
}
func (self *iface_gpu_GPU) Frame(arg0 *op.Ops, arg1 gpu.RenderTarget, arg2 image.Point) error {
	return self.fn_Frame(self.self, arg0, arg1, arg2)
}

func ctxTo_gpu_GPU(ps *env.ProgramState, v env.RyeCtx) (gpu.GPU, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_gpu_GPU{
		self: v,
	}
	ctxObj0, ok := wordToObj["release"]
	if !ok {
		return nil, errors.New("context to gpu.GPU: expected context to have function Release")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to gpu.GPU: context fn Release: function has invalid number of arguments (expected 0)")
		}
		impl.fn_Release = func(ctx env.RyeCtx) {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
		}
	default:
		return nil, errors.New("context to gpu.GPU: context fn Release: expected function")
	}
	ctxObj1, ok := wordToObj["clear"]
	if !ok {
		return nil, errors.New("context to gpu.GPU: expected context to have function Clear")
	}
	switch fn := ctxObj1.(type) {
	case env.Function:
		if fn.Argsn != 1 {
			return nil, errors.New("context to gpu.GPU: context fn Clear: function has invalid number of arguments (expected 1)")
		}
		impl.fn_Clear = func(ctx env.RyeCtx, farg0 color.NRGBA) {
			var farg0Val env.Object
			farg0Val = *env.NewNative(ps.Idx, farg0, "Go(color.NRGBA)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val)
		}
	default:
		return nil, errors.New("context to gpu.GPU: context fn Clear: expected function")
	}
	ctxObj2, ok := wordToObj["frame"]
	if !ok {
		return nil, errors.New("context to gpu.GPU: expected context to have function Frame")
	}
	switch fn := ctxObj2.(type) {
	case env.Function:
		if fn.Argsn != 3 {
			return nil, errors.New("context to gpu.GPU: context fn Frame: function has invalid number of arguments (expected 3)")
		}
		impl.fn_Frame = func(ctx env.RyeCtx, farg0 *op.Ops, farg1 gpu.RenderTarget, farg2 image.Point) error {
			var farg0Val, farg1Val, farg2Val env.Object
			farg0Val = *env.NewNative(ps.Idx, farg0, "Go(*op.Ops)")
			farg1Val = *env.NewNative(ps.Idx, farg1, "Go(gpu.RenderTarget)")
			farg2Val = *env.NewNative(ps.Idx, farg2, "Go(image.Point)")
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx, farg0Val, farg1Val, farg2Val)
			var res error
			switch v := ps.Res.(type) {
			case env.String:
				res = errors.New(v.Value)
			case env.Error:
				res = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
						"context to gpu.GPU: arg 0: callback result: expected integer to be 0 or nil",
						actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
						actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
					)
					return res
				}
				res = nil
			default:
				fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
					"context to gpu.GPU: arg 0: callback result: expected error, string or nil",
					actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
					actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
				)
				return res
			}
			return res
		}
	default:
		return nil, errors.New("context to gpu.GPU: context fn Frame: expected function")
	}
	return impl, nil
}

type iface_input_Command struct {
	self                 env.RyeCtx
	fn_ImplementsCommand func(self env.RyeCtx)
}

func (self *iface_input_Command) ImplementsCommand() {
	self.fn_ImplementsCommand(self.self)
}

func ctxTo_input_Command(ps *env.ProgramState, v env.RyeCtx) (input.Command, error) {
	words := v.GetWords(*ps.Idx).Series.S
	wordToObj := make(map[string]env.Object, len(words))
	for _, word := range words {
		name := word.(env.String).Value
		idx, ok := ps.Idx.GetIndex(name)
		if !ok {
			panic("expected valid word")
		}
		obj, ok := v.Get(idx)
		if !ok {
			panic("expected valid index")
		}
		wordToObj[name] = obj
	}
	impl := &iface_input_Command{
		self: v,
	}
	ctxObj0, ok := wordToObj["implements-command"]
	if !ok {
		return nil, errors.New("context to input.Command: expected context to have function ImplementsCommand")
	}
	switch fn := ctxObj0.(type) {
	case env.Function:
		if fn.Argsn != 0 {
			return nil, errors.New("context to input.Command: context fn ImplementsCommand: function has invalid number of arguments (expected 0)")
		}
		impl.fn_ImplementsCommand = func(ctx env.RyeCtx) {
			actualFn := fn
			_ = actualFn
			evaldo.CallFunctionArgsN(fn, ps, &ctx)
		}
	default:
		return nil, errors.New("context to input.Command: context fn ImplementsCommand: expected function")
	}
	return impl, nil
}

var builtinsGenerated = map[string]*env.Builtin{
	"Go(*app.Config)//custom-renderer!": {
		Doc:   "Set *app.Config CustomRenderer value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//custom-renderer!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//custom-renderer!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//custom-renderer!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//custom-renderer!: arg 2: expected integer")
			}
			self.CustomRenderer = newVal
			return arg0
		},
	},
	"Go(*app.Config)//custom-renderer?": {
		Doc:   "Get *app.Config CustomRenderer value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//custom-renderer?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//custom-renderer?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//custom-renderer?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.CustomRenderer))
			return resObj
		},
	},
	"Go(*app.Config)//decorated!": {
		Doc:   "Set *app.Config Decorated value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//decorated!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//decorated!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//decorated!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//decorated!: arg 2: expected integer")
			}
			self.Decorated = newVal
			return arg0
		},
	},
	"Go(*app.Config)//decorated?": {
		Doc:   "Get *app.Config Decorated value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//decorated?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//decorated?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//decorated?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Decorated))
			return resObj
		},
	},
	"Go(*app.Config)//focused!": {
		Doc:   "Set *app.Config Focused value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//focused!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//focused!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//focused!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//focused!: arg 2: expected integer")
			}
			self.Focused = newVal
			return arg0
		},
	},
	"Go(*app.Config)//focused?": {
		Doc:   "Get *app.Config Focused value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//focused?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//focused?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//focused?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Focused))
			return resObj
		},
	},
	"Go(*app.Config)//max-size!": {
		Doc:   "Set *app.Config MaxSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//max-size!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//max-size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//max-size!: arg 1: expected native")
			}
			var newVal image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//max-size!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//max-size!: arg 2: expected native")
			}
			self.MaxSize = newVal
			return arg0
		},
	},
	"Go(*app.Config)//max-size?": {
		Doc:   "Get *app.Config MaxSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//max-size?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//max-size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//max-size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.MaxSize, "Go(image.Point)")
			return resObj
		},
	},
	"Go(*app.Config)//min-size!": {
		Doc:   "Set *app.Config MinSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//min-size!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//min-size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//min-size!: arg 1: expected native")
			}
			var newVal image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//min-size!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//min-size!: arg 2: expected native")
			}
			self.MinSize = newVal
			return arg0
		},
	},
	"Go(*app.Config)//min-size?": {
		Doc:   "Get *app.Config MinSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//min-size?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//min-size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//min-size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.MinSize, "Go(image.Point)")
			return resObj
		},
	},
	"Go(*app.Config)//mode!": {
		Doc:   "Set *app.Config Mode value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//mode!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//mode!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//mode!: arg 1: expected native")
			}
			var newVal app.WindowMode
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal app.WindowMode
				if natOk {
					natVal, natValOk = nat.Value.(app.WindowMode)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*app.Config)//mode!: arg 2: expected integer")
					}
					newVal = app.WindowMode(u)
				}
			}
			self.Mode = newVal
			return arg0
		},
	},
	"Go(*app.Config)//mode?": {
		Doc:   "Get *app.Config Mode value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//mode?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//mode?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//mode?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Mode)))
			return resObj
		},
	},
	"Go(*app.Config)//navigation-color!": {
		Doc:   "Set *app.Config NavigationColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//navigation-color!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//navigation-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//navigation-color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//navigation-color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//navigation-color!: arg 2: expected native")
			}
			self.NavigationColor = newVal
			return arg0
		},
	},
	"Go(*app.Config)//navigation-color?": {
		Doc:   "Get *app.Config NavigationColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//navigation-color?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//navigation-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//navigation-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.NavigationColor, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*app.Config)//orientation!": {
		Doc:   "Set *app.Config Orientation value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//orientation!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//orientation!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//orientation!: arg 1: expected native")
			}
			var newVal app.Orientation
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal app.Orientation
				if natOk {
					natVal, natValOk = nat.Value.(app.Orientation)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*app.Config)//orientation!: arg 2: expected integer")
					}
					newVal = app.Orientation(u)
				}
			}
			self.Orientation = newVal
			return arg0
		},
	},
	"Go(*app.Config)//orientation?": {
		Doc:   "Get *app.Config Orientation value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//orientation?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//orientation?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//orientation?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Orientation)))
			return resObj
		},
	},
	"Go(*app.Config)//size!": {
		Doc:   "Set *app.Config Size value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//size!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//size!: arg 1: expected native")
			}
			var newVal image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//size!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//size!: arg 2: expected native")
			}
			self.Size = newVal
			return arg0
		},
	},
	"Go(*app.Config)//size?": {
		Doc:   "Get *app.Config Size value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//size?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Size, "Go(image.Point)")
			return resObj
		},
	},
	"Go(*app.Config)//status-color!": {
		Doc:   "Set *app.Config StatusColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//status-color!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//status-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//status-color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//status-color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//status-color!: arg 2: expected native")
			}
			self.StatusColor = newVal
			return arg0
		},
	},
	"Go(*app.Config)//status-color?": {
		Doc:   "Get *app.Config StatusColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//status-color?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//status-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//status-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.StatusColor, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*app.Config)//title!": {
		Doc:   "Set *app.Config Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//title!: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//title!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//title!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//title!: arg 2: expected string")
			}
			self.Title = newVal
			return arg0
		},
	},
	"Go(*app.Config)//title?": {
		Doc:   "Get *app.Config Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Config
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//title?: arg 1: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Config)//title?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Config)//title?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Title)
			return resObj
		},
	},
	"Go(*app.ConfigEvent)//config!": {
		Doc:   "Set *app.ConfigEvent Config value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.ConfigEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.ConfigEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.ConfigEvent)//config!: arg 1: expected native of type *app.ConfigEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.ConfigEvent)//config!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.ConfigEvent)//config!: arg 1: expected native")
			}
			var newVal *app.Config
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*app.Config)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.ConfigEvent)//config!: arg 2: expected native of type *app.Config")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.ConfigEvent)//config!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.ConfigEvent)//config!: arg 2: expected native")
			}
			self.Config = *newVal
			return arg0
		},
	},
	"Go(*app.ConfigEvent)//config?": {
		Doc:   "Get *app.ConfigEvent Config value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.ConfigEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.ConfigEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.ConfigEvent)//config?: arg 1: expected native of type *app.ConfigEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.ConfigEvent)//config?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.ConfigEvent)//config?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Config, "Go(*app.Config)")
			return resObj
		},
	},
	"Go(*app.ConfigEvent)//implements-event": {
		Doc:   "app.ConfigEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *app.ConfigEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.ConfigEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.ConfigEvent)//implements-event: arg 1: expected native of type *app.ConfigEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.ConfigEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.ConfigEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*app.DestroyEvent)//err!": {
		Doc:   "Set *app.DestroyEvent Err value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.DestroyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.DestroyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.DestroyEvent)//err!: arg 1: expected native of type *app.DestroyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.DestroyEvent)//err!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.DestroyEvent)//err!: arg 1: expected native")
			}
			var newVal error
			switch v := arg1.(type) {
			case env.String:
				newVal = errors.New(v.Value)
			case env.Error:
				newVal = errors.New(v.Print(*ps.Idx))
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.DestroyEvent)//err!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.DestroyEvent)//err!: arg 2: expected error, string or nil")
			}
			self.Err = newVal
			return arg0
		},
	},
	"Go(*app.DestroyEvent)//err?": {
		Doc:   "Get *app.DestroyEvent Err value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.DestroyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.DestroyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.DestroyEvent)//err?: arg 1: expected native of type *app.DestroyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.DestroyEvent)//err?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.DestroyEvent)//err?: arg 1: expected native")
			}
			var resObj env.Object
			if self.Err != nil {
				resObj = env.NewError(self.Err.Error())
			}
			return resObj
		},
	},
	"Go(*app.DestroyEvent)//implements-event": {
		Doc:   "app.DestroyEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *app.DestroyEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.DestroyEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.DestroyEvent)//implements-event: arg 1: expected native of type *app.DestroyEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.DestroyEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.DestroyEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*app.FrameEvent)//frame!": {
		Doc:   "Set *app.FrameEvent Frame value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//frame!: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//frame!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//frame!: arg 1: expected native")
			}
			var newVal func(*op.Ops)
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 1 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//frame!: arg 2: function has invalid number of arguments (expected 1)")
				}
				newVal = func(farg0 *op.Ops) {
					var farg0Val env.Object
					farg0Val = *env.NewNative(ps.Idx, farg0, "Go(*op.Ops)")
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//frame!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//frame!: arg 2: expected function or nil")
			}
			self.Frame = newVal
			return arg0
		},
	},
	"Go(*app.FrameEvent)//frame?": {
		Doc:   "Get *app.FrameEvent Frame value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//frame?: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//frame?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//frame?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *op.Ops
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*op.Ops)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("Go(*app.FrameEvent)//frame?: arg 1: expected native of type *op.Ops")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("Go(*app.FrameEvent)//frame?: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//frame?: arg 1: expected native")
				}
				self.Frame(arg0Val)
				return nil
			}, 1, false, false, "Returned func")
			return resObj
		},
	},
	"Go(*app.FrameEvent)//implements-event": {
		Doc:   "app.FrameEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//implements-event: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*app.FrameEvent)//insets!": {
		Doc:   "Set *app.FrameEvent Insets value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//insets!: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//insets!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//insets!: arg 1: expected native")
			}
			var newVal *app.Insets
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*app.Insets)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//insets!: arg 2: expected native of type *app.Insets")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//insets!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//insets!: arg 2: expected native")
			}
			self.Insets = *newVal
			return arg0
		},
	},
	"Go(*app.FrameEvent)//insets?": {
		Doc:   "Get *app.FrameEvent Insets value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//insets?: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//insets?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//insets?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Insets, "Go(*app.Insets)")
			return resObj
		},
	},
	"Go(*app.FrameEvent)//metric!": {
		Doc:   "Set *app.FrameEvent Metric value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//metric!: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//metric!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//metric!: arg 1: expected native")
			}
			var newVal *unit.Metric
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//metric!: arg 2: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//metric!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//metric!: arg 2: expected native")
			}
			self.Metric = *newVal
			return arg0
		},
	},
	"Go(*app.FrameEvent)//metric?": {
		Doc:   "Get *app.FrameEvent Metric value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//metric?: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//metric?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//metric?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Metric, "Go(*unit.Metric)")
			return resObj
		},
	},
	"Go(*app.FrameEvent)//now!": {
		Doc:   "Set *app.FrameEvent Now value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//now!: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//now!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//now!: arg 1: expected native")
			}
			var newVal time.Time
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(time.Time)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//now!: arg 2: expected native of type time.Time")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//now!: arg 2: expected native")
			}
			self.Now = newVal
			return arg0
		},
	},
	"Go(*app.FrameEvent)//now?": {
		Doc:   "Get *app.FrameEvent Now value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//now?: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//now?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//now?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Now, "Go(time.Time)")
			return resObj
		},
	},
	"Go(*app.FrameEvent)//size!": {
		Doc:   "Set *app.FrameEvent Size value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//size!: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//size!: arg 1: expected native")
			}
			var newVal image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//size!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//size!: arg 2: expected native")
			}
			self.Size = newVal
			return arg0
		},
	},
	"Go(*app.FrameEvent)//size?": {
		Doc:   "Get *app.FrameEvent Size value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//size?: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Size, "Go(image.Point)")
			return resObj
		},
	},
	"Go(*app.FrameEvent)//source!": {
		Doc:   "Set *app.FrameEvent Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//source!: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//source!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//source!: arg 1: expected native")
			}
			var newVal *input.Source
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*input.Source)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//source!: arg 2: expected native of type *input.Source")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//source!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//source!: arg 2: expected native")
			}
			self.Source = *newVal
			return arg0
		},
	},
	"Go(*app.FrameEvent)//source?": {
		Doc:   "Get *app.FrameEvent Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.FrameEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//source?: arg 1: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.FrameEvent)//source?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.FrameEvent)//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Source, "Go(*input.Source)")
			return resObj
		},
	},
	"Go(*app.Insets)//bottom!": {
		Doc:   "Set *app.Insets Bottom value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Insets
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Insets)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//bottom!: arg 1: expected native of type *app.Insets")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//bottom!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Insets)//bottom!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*app.Insets)//bottom!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Bottom = newVal
			return arg0
		},
	},
	"Go(*app.Insets)//bottom?": {
		Doc:   "Get *app.Insets Bottom value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Insets
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Insets)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//bottom?: arg 1: expected native of type *app.Insets")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//bottom?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Insets)//bottom?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Bottom)))
			return resObj
		},
	},
	"Go(*app.Insets)//left!": {
		Doc:   "Set *app.Insets Left value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Insets
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Insets)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//left!: arg 1: expected native of type *app.Insets")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//left!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Insets)//left!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*app.Insets)//left!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Left = newVal
			return arg0
		},
	},
	"Go(*app.Insets)//left?": {
		Doc:   "Get *app.Insets Left value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Insets
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Insets)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//left?: arg 1: expected native of type *app.Insets")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//left?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Insets)//left?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Left)))
			return resObj
		},
	},
	"Go(*app.Insets)//right!": {
		Doc:   "Set *app.Insets Right value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Insets
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Insets)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//right!: arg 1: expected native of type *app.Insets")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//right!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Insets)//right!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*app.Insets)//right!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Right = newVal
			return arg0
		},
	},
	"Go(*app.Insets)//right?": {
		Doc:   "Get *app.Insets Right value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Insets
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Insets)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//right?: arg 1: expected native of type *app.Insets")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//right?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Insets)//right?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Right)))
			return resObj
		},
	},
	"Go(*app.Insets)//top!": {
		Doc:   "Set *app.Insets Top value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Insets
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Insets)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//top!: arg 1: expected native of type *app.Insets")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//top!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Insets)//top!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*app.Insets)//top!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Top = newVal
			return arg0
		},
	},
	"Go(*app.Insets)//top?": {
		Doc:   "Get *app.Insets Top value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *app.Insets
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*app.Insets)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//top?: arg 1: expected native of type *app.Insets")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Insets)//top?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Insets)//top?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Top)))
			return resObj
		},
	},
	"Go(*app.Window)//event": {
		Doc:   "(*app.Window).Event",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *app.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//event: arg 1: expected native of type *app.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Window)//event: arg 1: expected native")
			}
			res0 := arg0Val.Event()
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(event.Event)")
			return res0Obj
		},
	},
	"Go(*app.Window)//invalidate": {
		Doc:   "(*app.Window).Invalidate",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *app.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//invalidate: arg 1: expected native of type *app.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//invalidate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Window)//invalidate: arg 1: expected native")
			}
			arg0Val.Invalidate()
			return arg0
		},
	},
	"Go(*app.Window)//option": {
		Doc:   "(*app.Window).Option",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *app.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//option: arg 1: expected native of type *app.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//option: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Window)//option: arg 1: expected native")
			}
			var arg1Val []app.Option
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]app.Option, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal app.Option
						if natOk {
							natVal, natValOk = nat.Value.(app.Option)
						}
						if natValOk {
							arg1Val[i] = natVal
						} else {
							var u func(unit.Metric, *app.Config)
							switch fn := it.(type) {
							case env.Function:
								if fn.Argsn != 2 {
									ps.FailureFlag = true
									return env.NewError("Go(*app.Window)//option: arg 2: block item: function has invalid number of arguments (expected 2)")
								}
								u = func(farg0 unit.Metric, farg1 *app.Config) {
									var farg0Val, farg1Val env.Object
									farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*unit.Metric)")
									farg1Val = *env.NewNative(ps.Idx, farg1, "Go(*app.Config)")
									actualFn := fn
									_ = actualFn
									evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val, farg1Val)
								}
							case env.Integer:
								if fn.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("Go(*app.Window)//option: arg 2: block item: expected integer to be 0 or nil")
								}
								u = nil
							default:
								ps.FailureFlag = true
								return env.NewError("Go(*app.Window)//option: arg 2: block item: expected function or nil")
							}
							arg1Val[i] = app.Option(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]app.Option)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//option: arg 2: expected native of type []app.Option")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//option: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Window)//option: arg 2: expected block, native or nil")
			}
			arg0Val.Option(arg1Val...)
			return arg0
		},
	},
	"Go(*app.Window)//perform": {
		Doc:   "(*app.Window).Perform",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *app.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//perform: arg 1: expected native of type *app.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//perform: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Window)//perform: arg 1: expected native")
			}
			var arg1Val system.Action
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal system.Action
				if natOk {
					natVal, natValOk = nat.Value.(system.Action)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint
					if v, ok := arg1.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*app.Window)//perform: arg 2: expected integer")
					}
					arg1Val = system.Action(u)
				}
			}
			arg0Val.Perform(arg1Val)
			return arg0
		},
	},
	"Go(*app.Window)//run": {
		Doc:   "(*app.Window).Run",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *app.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*app.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//run: arg 1: expected native of type *app.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//run: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Window)//run: arg 1: expected native")
			}
			var arg1Val func()
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//run: arg 2: function has invalid number of arguments (expected 0)")
				}
				arg1Val = func() {
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx)
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*app.Window)//run: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*app.Window)//run: arg 2: expected function or nil")
			}
			arg0Val.Run(arg1Val)
			return arg0
		},
	},
	"Go(*clip.Op)//push": {
		Doc:   "clip.Op.Push",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Op
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Op)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Op)//push: arg 1: expected native of type *clip.Op")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Op)//push: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Op)//push: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Op)//push: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Op)//push: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Op)//push: arg 2: expected native")
			}
			res0 := (*arg0Val).Push(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.Stack)")
			return res0Obj
		},
	},
	"Go(*clip.Outline)//op": {
		Doc:   "clip.Outline.Op",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Outline
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Outline)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Outline)//op: arg 1: expected native of type *clip.Outline")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Outline)//op: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Outline)//op: arg 1: expected native")
			}
			res0 := (*arg0Val).Op()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.Op)")
			return res0Obj
		},
	},
	"Go(*clip.Outline)//path!": {
		Doc:   "Set *clip.Outline Path value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.Outline
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.Outline)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Outline)//path!: arg 1: expected native of type *clip.Outline")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Outline)//path!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Outline)//path!: arg 1: expected native")
			}
			var newVal *clip.PathSpec
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*clip.PathSpec)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Outline)//path!: arg 2: expected native of type *clip.PathSpec")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Outline)//path!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Outline)//path!: arg 2: expected native")
			}
			self.Path = *newVal
			return arg0
		},
	},
	"Go(*clip.Outline)//path?": {
		Doc:   "Get *clip.Outline Path value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.Outline
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.Outline)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Outline)//path?: arg 1: expected native of type *clip.Outline")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Outline)//path?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Outline)//path?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Path, "Go(*clip.PathSpec)")
			return resObj
		},
	},
	"Go(*clip.Path)//arc": {
		Doc:   "(*clip.Path).Arc",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//arc: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//arc: arg 2: expected native")
			}
			var arg2Val *f32.Point
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc: arg 3: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//arc: arg 3: expected native")
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//arc: arg 4: expected decimal")
			}
			arg0Val.Arc(*arg1Val, *arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*clip.Path)//arc-to": {
		Doc:   "(*clip.Path).ArcTo",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc-to: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//arc-to: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc-to: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc-to: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//arc-to: arg 2: expected native")
			}
			var arg2Val *f32.Point
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc-to: arg 3: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//arc-to: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//arc-to: arg 3: expected native")
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//arc-to: arg 4: expected decimal")
			}
			arg0Val.ArcTo(*arg1Val, *arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*clip.Path)//begin": {
		Doc:   "(*clip.Path).Begin",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//begin: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//begin: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//begin: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//begin: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//begin: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//begin: arg 2: expected native")
			}
			arg0Val.Begin(arg1Val)
			return arg0
		},
	},
	"Go(*clip.Path)//close": {
		Doc:   "(*clip.Path).Close",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//close: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//close: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//close: arg 1: expected native")
			}
			arg0Val.Close()
			return arg0
		},
	},
	"Go(*clip.Path)//cube": {
		Doc:   "(*clip.Path).Cube",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//cube: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//cube: arg 2: expected native")
			}
			var arg2Val *f32.Point
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube: arg 3: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//cube: arg 3: expected native")
			}
			var arg3Val *f32.Point
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube: arg 4: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//cube: arg 4: expected native")
			}
			arg0Val.Cube(*arg1Val, *arg2Val, *arg3Val)
			return arg0
		},
	},
	"Go(*clip.Path)//cube-to": {
		Doc:   "(*clip.Path).CubeTo",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube-to: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//cube-to: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube-to: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube-to: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//cube-to: arg 2: expected native")
			}
			var arg2Val *f32.Point
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube-to: arg 3: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube-to: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//cube-to: arg 3: expected native")
			}
			var arg3Val *f32.Point
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube-to: arg 4: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//cube-to: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//cube-to: arg 4: expected native")
			}
			arg0Val.CubeTo(*arg1Val, *arg2Val, *arg3Val)
			return arg0
		},
	},
	"Go(*clip.Path)//end": {
		Doc:   "(*clip.Path).End",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//end: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//end: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//end: arg 1: expected native")
			}
			res0 := arg0Val.End()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.PathSpec)")
			return res0Obj
		},
	},
	"Go(*clip.Path)//line": {
		Doc:   "(*clip.Path).Line",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//line: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//line: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//line: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//line: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//line: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//line: arg 2: expected native")
			}
			arg0Val.Line(*arg1Val)
			return arg0
		},
	},
	"Go(*clip.Path)//line-to": {
		Doc:   "(*clip.Path).LineTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//line-to: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//line-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//line-to: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//line-to: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//line-to: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//line-to: arg 2: expected native")
			}
			arg0Val.LineTo(*arg1Val)
			return arg0
		},
	},
	"Go(*clip.Path)//move": {
		Doc:   "(*clip.Path).Move",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//move: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//move: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//move: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//move: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//move: arg 2: expected native")
			}
			arg0Val.Move(*arg1Val)
			return arg0
		},
	},
	"Go(*clip.Path)//move-to": {
		Doc:   "(*clip.Path).MoveTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//move-to: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//move-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//move-to: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//move-to: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//move-to: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//move-to: arg 2: expected native")
			}
			arg0Val.MoveTo(*arg1Val)
			return arg0
		},
	},
	"Go(*clip.Path)//pos": {
		Doc:   "(*clip.Path).Pos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//pos: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//pos: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//pos: arg 1: expected native")
			}
			res0 := arg0Val.Pos()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"Go(*clip.Path)//quad": {
		Doc:   "(*clip.Path).Quad",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//quad: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//quad: arg 2: expected native")
			}
			var arg2Val *f32.Point
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad: arg 3: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//quad: arg 3: expected native")
			}
			arg0Val.Quad(*arg1Val, *arg2Val)
			return arg0
		},
	},
	"Go(*clip.Path)//quad-to": {
		Doc:   "(*clip.Path).QuadTo",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Path
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Path)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad-to: arg 1: expected native of type *clip.Path")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//quad-to: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad-to: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad-to: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//quad-to: arg 2: expected native")
			}
			var arg2Val *f32.Point
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad-to: arg 3: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Path)//quad-to: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Path)//quad-to: arg 3: expected native")
			}
			arg0Val.QuadTo(*arg1Val, *arg2Val)
			return arg0
		},
	},
	"Go(*clip.RRect)//ne!": {
		Doc:   "Set *clip.RRect NE value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//ne!: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//ne!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//ne!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//ne!: arg 2: expected integer")
			}
			self.NE = newVal
			return arg0
		},
	},
	"Go(*clip.RRect)//ne?": {
		Doc:   "Get *clip.RRect NE value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//ne?: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//ne?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//ne?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.NE))
			return resObj
		},
	},
	"Go(*clip.RRect)//nw!": {
		Doc:   "Set *clip.RRect NW value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//nw!: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//nw!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//nw!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//nw!: arg 2: expected integer")
			}
			self.NW = newVal
			return arg0
		},
	},
	"Go(*clip.RRect)//nw?": {
		Doc:   "Get *clip.RRect NW value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//nw?: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//nw?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//nw?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.NW))
			return resObj
		},
	},
	"Go(*clip.RRect)//op": {
		Doc:   "clip.RRect.Op",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//op: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//op: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//op: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//op: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//op: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//op: arg 2: expected native")
			}
			res0 := (*arg0Val).Op(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.Op)")
			return res0Obj
		},
	},
	"Go(*clip.RRect)//path": {
		Doc:   "clip.RRect.Path",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//path: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//path: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//path: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//path: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//path: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//path: arg 2: expected native")
			}
			res0 := (*arg0Val).Path(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.PathSpec)")
			return res0Obj
		},
	},
	"Go(*clip.RRect)//push": {
		Doc:   "clip.RRect.Push",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//push: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//push: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//push: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//push: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//push: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//push: arg 2: expected native")
			}
			res0 := (*arg0Val).Push(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.Stack)")
			return res0Obj
		},
	},
	"Go(*clip.RRect)//rect!": {
		Doc:   "Set *clip.RRect Rect value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//rect!: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//rect!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//rect!: arg 1: expected native")
			}
			var newVal image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//rect!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//rect!: arg 2: expected native")
			}
			self.Rect = newVal
			return arg0
		},
	},
	"Go(*clip.RRect)//rect?": {
		Doc:   "Get *clip.RRect Rect value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//rect?: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//rect?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//rect?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Rect, "Go(image.Rectangle)")
			return resObj
		},
	},
	"Go(*clip.RRect)//se!": {
		Doc:   "Set *clip.RRect SE value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//se!: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//se!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//se!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//se!: arg 2: expected integer")
			}
			self.SE = newVal
			return arg0
		},
	},
	"Go(*clip.RRect)//se?": {
		Doc:   "Get *clip.RRect SE value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//se?: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//se?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//se?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.SE))
			return resObj
		},
	},
	"Go(*clip.RRect)//sw!": {
		Doc:   "Set *clip.RRect SW value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//sw!: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//sw!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//sw!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//sw!: arg 2: expected integer")
			}
			self.SW = newVal
			return arg0
		},
	},
	"Go(*clip.RRect)//sw?": {
		Doc:   "Get *clip.RRect SW value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.RRect
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.RRect)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//sw?: arg 1: expected native of type *clip.RRect")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.RRect)//sw?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.RRect)//sw?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.SW))
			return resObj
		},
	},
	"Go(*clip.Stack)//pop": {
		Doc:   "clip.Stack.Pop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Stack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Stack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stack)//pop: arg 1: expected native of type *clip.Stack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stack)//pop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Stack)//pop: arg 1: expected native")
			}
			(*arg0Val).Pop()
			return arg0
		},
	},
	"Go(*clip.Stroke)//op": {
		Doc:   "clip.Stroke.Op",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clip.Stroke
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clip.Stroke)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//op: arg 1: expected native of type *clip.Stroke")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//op: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Stroke)//op: arg 1: expected native")
			}
			res0 := (*arg0Val).Op()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.Op)")
			return res0Obj
		},
	},
	"Go(*clip.Stroke)//path!": {
		Doc:   "Set *clip.Stroke Path value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.Stroke
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.Stroke)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//path!: arg 1: expected native of type *clip.Stroke")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//path!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Stroke)//path!: arg 1: expected native")
			}
			var newVal *clip.PathSpec
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*clip.PathSpec)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//path!: arg 2: expected native of type *clip.PathSpec")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//path!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Stroke)//path!: arg 2: expected native")
			}
			self.Path = *newVal
			return arg0
		},
	},
	"Go(*clip.Stroke)//path?": {
		Doc:   "Get *clip.Stroke Path value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.Stroke
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.Stroke)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//path?: arg 1: expected native of type *clip.Stroke")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//path?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Stroke)//path?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Path, "Go(*clip.PathSpec)")
			return resObj
		},
	},
	"Go(*clip.Stroke)//width!": {
		Doc:   "Set *clip.Stroke Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.Stroke
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.Stroke)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//width!: arg 1: expected native of type *clip.Stroke")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Stroke)//width!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Stroke)//width!: arg 2: expected decimal")
			}
			self.Width = newVal
			return arg0
		},
	},
	"Go(*clip.Stroke)//width?": {
		Doc:   "Get *clip.Stroke Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clip.Stroke
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clip.Stroke)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//width?: arg 1: expected native of type *clip.Stroke")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clip.Stroke)//width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clip.Stroke)//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Width))
			return resObj
		},
	},
	"Go(*clipboard.ReadCmd)//implements-command": {
		Doc:   "clipboard.ReadCmd.ImplementsCommand",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clipboard.ReadCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clipboard.ReadCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.ReadCmd)//implements-command: arg 1: expected native of type *clipboard.ReadCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.ReadCmd)//implements-command: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.ReadCmd)//implements-command: arg 1: expected native")
			}
			(*arg0Val).ImplementsCommand()
			return arg0
		},
	},
	"Go(*clipboard.ReadCmd)//tag!": {
		Doc:   "Set *clipboard.ReadCmd Tag value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clipboard.ReadCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clipboard.ReadCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.ReadCmd)//tag!: arg 1: expected native of type *clipboard.ReadCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.ReadCmd)//tag!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.ReadCmd)//tag!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.ReadCmd)//tag!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.ReadCmd)//tag!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.ReadCmd)//tag!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.ReadCmd)//tag!: arg 2: expected native")
			}
			self.Tag = newVal
			return arg0
		},
	},
	"Go(*clipboard.ReadCmd)//tag?": {
		Doc:   "Get *clipboard.ReadCmd Tag value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clipboard.ReadCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clipboard.ReadCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.ReadCmd)//tag?: arg 1: expected native of type *clipboard.ReadCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.ReadCmd)//tag?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.ReadCmd)//tag?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Tag, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*clipboard.WriteCmd)//data!": {
		Doc:   "Set *clipboard.WriteCmd Data value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clipboard.WriteCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clipboard.WriteCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//data!: arg 1: expected native of type *clipboard.WriteCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//data!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.WriteCmd)//data!: arg 1: expected native")
			}
			var newVal io.ReadCloser
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(io.ReadCloser)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//data!: arg 2: expected native of type io.ReadCloser")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.WriteCmd)//data!: arg 2: expected native")
			}
			self.Data = newVal
			return arg0
		},
	},
	"Go(*clipboard.WriteCmd)//data?": {
		Doc:   "Get *clipboard.WriteCmd Data value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clipboard.WriteCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clipboard.WriteCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//data?: arg 1: expected native of type *clipboard.WriteCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//data?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.WriteCmd)//data?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Data, "Go(io.ReadCloser)")
			return resObj
		},
	},
	"Go(*clipboard.WriteCmd)//implements-command": {
		Doc:   "clipboard.WriteCmd.ImplementsCommand",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *clipboard.WriteCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*clipboard.WriteCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//implements-command: arg 1: expected native of type *clipboard.WriteCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//implements-command: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.WriteCmd)//implements-command: arg 1: expected native")
			}
			(*arg0Val).ImplementsCommand()
			return arg0
		},
	},
	"Go(*clipboard.WriteCmd)//type!": {
		Doc:   "Set *clipboard.WriteCmd Type value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clipboard.WriteCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clipboard.WriteCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//type!: arg 1: expected native of type *clipboard.WriteCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//type!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.WriteCmd)//type!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.WriteCmd)//type!: arg 2: expected string")
			}
			self.Type = newVal
			return arg0
		},
	},
	"Go(*clipboard.WriteCmd)//type?": {
		Doc:   "Get *clipboard.WriteCmd Type value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *clipboard.WriteCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*clipboard.WriteCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//type?: arg 1: expected native of type *clipboard.WriteCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*clipboard.WriteCmd)//type?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*clipboard.WriteCmd)//type?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Type)
			return resObj
		},
	},
	"Go(*f32.Affine2D)//elems": {
		Doc:   "f32.Affine2D.Elems",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//elems: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//elems: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//elems: arg 1: expected native")
			}
			res0, res1, res2, res3, res4, res5 := (*arg0Val).Elems()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewDecimal(float64(res1))
			var res2Obj env.Object
			res2Obj = *env.NewDecimal(float64(res2))
			var res3Obj env.Object
			res3Obj = *env.NewDecimal(float64(res3))
			var res4Obj env.Object
			res4Obj = *env.NewDecimal(float64(res4))
			var res5Obj env.Object
			res5Obj = *env.NewDecimal(float64(res5))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
				res3Obj,
				res4Obj,
				res5Obj,
			}))
		},
	},
	"Go(*f32.Affine2D)//invert": {
		Doc:   "f32.Affine2D.Invert",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//invert: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//invert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//invert: arg 1: expected native")
			}
			res0 := (*arg0Val).Invert()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Affine2D)")
			return res0Obj
		},
	},
	"Go(*f32.Affine2D)//mul": {
		Doc:   "f32.Affine2D.Mul",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//mul: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//mul: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//mul: arg 1: expected native")
			}
			var arg1Val *f32.Affine2D
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//mul: arg 2: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//mul: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//mul: arg 2: expected native")
			}
			res0 := (*arg0Val).Mul(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Affine2D)")
			return res0Obj
		},
	},
	"Go(*f32.Affine2D)//offset": {
		Doc:   "f32.Affine2D.Offset",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//offset: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//offset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//offset: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//offset: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//offset: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//offset: arg 2: expected native")
			}
			res0 := (*arg0Val).Offset(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Affine2D)")
			return res0Obj
		},
	},
	"Go(*f32.Affine2D)//rotate": {
		Doc:   "f32.Affine2D.Rotate",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//rotate: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//rotate: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//rotate: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//rotate: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//rotate: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//rotate: arg 2: expected native")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//rotate: arg 3: expected decimal")
			}
			res0 := (*arg0Val).Rotate(*arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Affine2D)")
			return res0Obj
		},
	},
	"Go(*f32.Affine2D)//scale": {
		Doc:   "f32.Affine2D.Scale",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//scale: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//scale: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//scale: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//scale: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//scale: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//scale: arg 2: expected native")
			}
			var arg2Val *f32.Point
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//scale: arg 3: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//scale: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//scale: arg 3: expected native")
			}
			res0 := (*arg0Val).Scale(*arg1Val, *arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Affine2D)")
			return res0Obj
		},
	},
	"Go(*f32.Affine2D)//shear": {
		Doc:   "f32.Affine2D.Shear",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//shear: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//shear: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//shear: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//shear: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//shear: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//shear: arg 2: expected native")
			}
			var arg2Val float32
			if v, ok := arg2.(env.Decimal); ok {
				arg2Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//shear: arg 3: expected decimal")
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//shear: arg 4: expected decimal")
			}
			res0 := (*arg0Val).Shear(*arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Affine2D)")
			return res0Obj
		},
	},
	"Go(*f32.Affine2D)//split": {
		Doc:   "(*f32.Affine2D).Split",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//split: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//split: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//split: arg 1: expected native")
			}
			res0, res1 := arg0Val.Split()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Affine2D)")
			var res1Obj env.Object
			res1Obj = *env.NewNative(ps.Idx, &res1, "Go(*f32.Point)")
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*f32.Affine2D)//string": {
		Doc:   "f32.Affine2D.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//string: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//string: arg 1: expected native")
			}
			res0 := (*arg0Val).String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*f32.Affine2D)//transform": {
		Doc:   "f32.Affine2D.Transform",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//transform: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//transform: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//transform: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//transform: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Affine2D)//transform: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Affine2D)//transform: arg 2: expected native")
			}
			res0 := (*arg0Val).Transform(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"Go(*f32.Point)//add": {
		Doc:   "f32.Point.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//add: arg 1: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//add: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//add: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//add: arg 2: expected native")
			}
			res0 := (*arg0Val).Add(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"Go(*f32.Point)//div": {
		Doc:   "f32.Point.Div",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//div: arg 1: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//div: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//div: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//div: arg 2: expected decimal")
			}
			res0 := (*arg0Val).Div(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"Go(*f32.Point)//mul": {
		Doc:   "f32.Point.Mul",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//mul: arg 1: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//mul: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//mul: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//mul: arg 2: expected decimal")
			}
			res0 := (*arg0Val).Mul(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"Go(*f32.Point)//round": {
		Doc:   "f32.Point.Round",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//round: arg 1: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//round: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//round: arg 1: expected native")
			}
			res0 := (*arg0Val).Round()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(image.Point)")
			return res0Obj
		},
	},
	"Go(*f32.Point)//string": {
		Doc:   "f32.Point.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//string: arg 1: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//string: arg 1: expected native")
			}
			res0 := (*arg0Val).String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*f32.Point)//sub": {
		Doc:   "f32.Point.Sub",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//sub: arg 1: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//sub: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//sub: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//sub: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//sub: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//sub: arg 2: expected native")
			}
			res0 := (*arg0Val).Sub(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"Go(*f32.Point)//x!": {
		Doc:   "Set *f32.Point X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *f32.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//x!: arg 1: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//x!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//x!: arg 2: expected decimal")
			}
			self.X = newVal
			return arg0
		},
	},
	"Go(*f32.Point)//x?": {
		Doc:   "Get *f32.Point X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *f32.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//x?: arg 1: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.X))
			return resObj
		},
	},
	"Go(*f32.Point)//y!": {
		Doc:   "Set *f32.Point Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *f32.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//y!: arg 1: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//y!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//y!: arg 2: expected decimal")
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*f32.Point)//y?": {
		Doc:   "Get *f32.Point Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *f32.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//y?: arg 1: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*f32.Point)//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*f32.Point)//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Y))
			return resObj
		},
	},
	"Go(*font.Font)//style!": {
		Doc:   "Set *font.Font Style value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *font.Font
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//style!: arg 1: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.Font)//style!: arg 1: expected native")
			}
			var newVal font.Style
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal font.Style
				if natOk {
					natVal, natValOk = nat.Value.(font.Style)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*font.Font)//style!: arg 2: expected integer")
					}
					newVal = font.Style(u)
				}
			}
			self.Style = newVal
			return arg0
		},
	},
	"Go(*font.Font)//style?": {
		Doc:   "Get *font.Font Style value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *font.Font
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//style?: arg 1: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.Font)//style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Style)))
			return resObj
		},
	},
	"Go(*font.Font)//typeface!": {
		Doc:   "Set *font.Font Typeface value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *font.Font
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//typeface!: arg 1: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//typeface!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.Font)//typeface!: arg 1: expected native")
			}
			var newVal font.Typeface
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal font.Typeface
				if natOk {
					natVal, natValOk = nat.Value.(font.Typeface)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*font.Font)//typeface!: arg 2: expected string")
					}
					newVal = font.Typeface(u)
				}
			}
			self.Typeface = newVal
			return arg0
		},
	},
	"Go(*font.Font)//typeface?": {
		Doc:   "Get *font.Font Typeface value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *font.Font
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//typeface?: arg 1: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//typeface?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.Font)//typeface?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.Typeface))
			return resObj
		},
	},
	"Go(*font.Font)//weight!": {
		Doc:   "Set *font.Font Weight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *font.Font
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//weight!: arg 1: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//weight!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.Font)//weight!: arg 1: expected native")
			}
			var newVal font.Weight
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal font.Weight
				if natOk {
					natVal, natValOk = nat.Value.(font.Weight)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*font.Font)//weight!: arg 2: expected integer")
					}
					newVal = font.Weight(u)
				}
			}
			self.Weight = newVal
			return arg0
		},
	},
	"Go(*font.Font)//weight?": {
		Doc:   "Get *font.Font Weight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *font.Font
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//weight?: arg 1: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.Font)//weight?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.Font)//weight?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Weight)))
			return resObj
		},
	},
	"Go(*font.FontFace)//face!": {
		Doc:   "Set *font.FontFace Face value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *font.FontFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*font.FontFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//face!: arg 1: expected native of type *font.FontFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//face!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.FontFace)//face!: arg 1: expected native")
			}
			var newVal font.Face
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_font_Face(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//face!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//face!: arg 2: expected native of type font.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//face!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.FontFace)//face!: arg 2: expected native")
			}
			self.Face = newVal
			return arg0
		},
	},
	"Go(*font.FontFace)//face?": {
		Doc:   "Get *font.FontFace Face value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *font.FontFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*font.FontFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//face?: arg 1: expected native of type *font.FontFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//face?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.FontFace)//face?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Face, "Go(font.Face)")
			return resObj
		},
	},
	"Go(*font.FontFace)//font!": {
		Doc:   "Set *font.FontFace Font value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *font.FontFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*font.FontFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//font!: arg 1: expected native of type *font.FontFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//font!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.FontFace)//font!: arg 1: expected native")
			}
			var newVal *font.Font
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//font!: arg 2: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//font!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.FontFace)//font!: arg 2: expected native")
			}
			self.Font = *newVal
			return arg0
		},
	},
	"Go(*font.FontFace)//font?": {
		Doc:   "Get *font.FontFace Font value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *font.FontFace
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*font.FontFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//font?: arg 1: expected native of type *font.FontFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*font.FontFace)//font?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*font.FontFace)//font?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Font, "Go(*font.Font)")
			return resObj
		},
	},
	"Go(*gesture.Click)//add": {
		Doc:   "(*gesture.Click).Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Click
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Click)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//add: arg 1: expected native of type *gesture.Click")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Click)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Click)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(*gesture.Click)//hovered": {
		Doc:   "(*gesture.Click).Hovered",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Click
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Click)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//hovered: arg 1: expected native of type *gesture.Click")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//hovered: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Click)//hovered: arg 1: expected native")
			}
			res0 := arg0Val.Hovered()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*gesture.Click)//pressed": {
		Doc:   "(*gesture.Click).Pressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Click
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Click)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//pressed: arg 1: expected native of type *gesture.Click")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Click)//pressed: arg 1: expected native")
			}
			res0 := arg0Val.Pressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*gesture.Click)//update": {
		Doc:   "(*gesture.Click).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Click
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Click)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//update: arg 1: expected native of type *gesture.Click")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Click)//update: arg 1: expected native")
			}
			var arg1Val *input.Source
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*input.Source)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//update: arg 2: expected native of type *input.Source")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Click)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Click)//update: arg 2: expected native")
			}
			res0, res1 := arg0Val.Update(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*gesture.ClickEvent)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*gesture.ClickEvent)//implements-event": {
		Doc:   "gesture.ClickEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//implements-event: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*gesture.ClickEvent)//kind!": {
		Doc:   "Set *gesture.ClickEvent Kind value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//kind!: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//kind!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//kind!: arg 1: expected native")
			}
			var newVal gesture.ClickKind
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal gesture.ClickKind
				if natOk {
					natVal, natValOk = nat.Value.(gesture.ClickKind)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*gesture.ClickEvent)//kind!: arg 2: expected integer")
					}
					newVal = gesture.ClickKind(u)
				}
			}
			self.Kind = newVal
			return arg0
		},
	},
	"Go(*gesture.ClickEvent)//kind?": {
		Doc:   "Get *gesture.ClickEvent Kind value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//kind?: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//kind?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//kind?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Kind)))
			return resObj
		},
	},
	"Go(*gesture.ClickEvent)//modifiers!": {
		Doc:   "Set *gesture.ClickEvent Modifiers value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//modifiers!: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//modifiers!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//modifiers!: arg 1: expected native")
			}
			var newVal key.Modifiers
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.Modifiers
				if natOk {
					natVal, natValOk = nat.Value.(key.Modifiers)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*gesture.ClickEvent)//modifiers!: arg 2: expected integer")
					}
					newVal = key.Modifiers(u)
				}
			}
			self.Modifiers = newVal
			return arg0
		},
	},
	"Go(*gesture.ClickEvent)//modifiers?": {
		Doc:   "Get *gesture.ClickEvent Modifiers value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//modifiers?: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//modifiers?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//modifiers?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(self.Modifiers)))
			return resObj
		},
	},
	"Go(*gesture.ClickEvent)//num-clicks!": {
		Doc:   "Set *gesture.ClickEvent NumClicks value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//num-clicks!: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//num-clicks!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//num-clicks!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//num-clicks!: arg 2: expected integer")
			}
			self.NumClicks = newVal
			return arg0
		},
	},
	"Go(*gesture.ClickEvent)//num-clicks?": {
		Doc:   "Get *gesture.ClickEvent NumClicks value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//num-clicks?: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//num-clicks?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//num-clicks?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.NumClicks))
			return resObj
		},
	},
	"Go(*gesture.ClickEvent)//position!": {
		Doc:   "Set *gesture.ClickEvent Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//position!: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//position!: arg 1: expected native")
			}
			var newVal image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//position!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//position!: arg 2: expected native")
			}
			self.Position = newVal
			return arg0
		},
	},
	"Go(*gesture.ClickEvent)//position?": {
		Doc:   "Get *gesture.ClickEvent Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//position?: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "Go(image.Point)")
			return resObj
		},
	},
	"Go(*gesture.ClickEvent)//source!": {
		Doc:   "Set *gesture.ClickEvent Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//source!: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//source!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//source!: arg 1: expected native")
			}
			var newVal pointer.Source
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal pointer.Source
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Source)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*gesture.ClickEvent)//source!: arg 2: expected integer")
					}
					newVal = pointer.Source(u)
				}
			}
			self.Source = newVal
			return arg0
		},
	},
	"Go(*gesture.ClickEvent)//source?": {
		Doc:   "Get *gesture.ClickEvent Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *gesture.ClickEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*gesture.ClickEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//source?: arg 1: expected native of type *gesture.ClickEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.ClickEvent)//source?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.ClickEvent)//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Source)))
			return resObj
		},
	},
	"Go(*gesture.Drag)//add": {
		Doc:   "(*gesture.Drag).Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Drag
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Drag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//add: arg 1: expected native of type *gesture.Drag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Drag)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Drag)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(*gesture.Drag)//dragging": {
		Doc:   "(*gesture.Drag).Dragging",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Drag
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Drag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//dragging: arg 1: expected native of type *gesture.Drag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//dragging: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Drag)//dragging: arg 1: expected native")
			}
			res0 := arg0Val.Dragging()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*gesture.Drag)//pressed": {
		Doc:   "(*gesture.Drag).Pressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Drag
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Drag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//pressed: arg 1: expected native of type *gesture.Drag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Drag)//pressed: arg 1: expected native")
			}
			res0 := arg0Val.Pressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*gesture.Drag)//update": {
		Doc:   "(*gesture.Drag).Update",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Drag
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Drag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//update: arg 1: expected native of type *gesture.Drag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Drag)//update: arg 1: expected native")
			}
			var arg1Val *unit.Metric
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//update: arg 2: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Drag)//update: arg 2: expected native")
			}
			var arg2Val *input.Source
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*input.Source)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//update: arg 3: expected native of type *input.Source")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Drag)//update: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Drag)//update: arg 3: expected native")
			}
			var arg3Val gesture.Axis
			{
				nat, natOk := arg3.(env.Native)
				var natValOk bool
				var natVal gesture.Axis
				if natOk {
					natVal, natValOk = nat.Value.(gesture.Axis)
				}
				if natValOk {
					arg3Val = natVal
				} else {
					var u uint8
					if v, ok := arg3.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*gesture.Drag)//update: arg 4: expected integer")
					}
					arg3Val = gesture.Axis(u)
				}
			}
			res0, res1 := arg0Val.Update(*arg1Val, *arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*pointer.Event)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*gesture.Hover)//add": {
		Doc:   "(*gesture.Hover).Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Hover
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Hover)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Hover)//add: arg 1: expected native of type *gesture.Hover")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Hover)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Hover)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Hover)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Hover)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Hover)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(*gesture.Hover)//update": {
		Doc:   "(*gesture.Hover).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Hover
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Hover)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Hover)//update: arg 1: expected native of type *gesture.Hover")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Hover)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Hover)//update: arg 1: expected native")
			}
			var arg1Val *input.Source
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*input.Source)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Hover)//update: arg 2: expected native of type *input.Source")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Hover)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Hover)//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*gesture.Scroll)//add": {
		Doc:   "(*gesture.Scroll).Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Scroll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Scroll)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Scroll)//add: arg 1: expected native of type *gesture.Scroll")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Scroll)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Scroll)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Scroll)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Scroll)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Scroll)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(*gesture.Scroll)//state": {
		Doc:   "(*gesture.Scroll).State",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Scroll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Scroll)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Scroll)//state: arg 1: expected native of type *gesture.Scroll")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Scroll)//state: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Scroll)//state: arg 1: expected native")
			}
			res0 := arg0Val.State()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint8(res0)))
			return res0Obj
		},
	},
	"Go(*gesture.Scroll)//stop": {
		Doc:   "(*gesture.Scroll).Stop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *gesture.Scroll
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*gesture.Scroll)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Scroll)//stop: arg 1: expected native of type *gesture.Scroll")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*gesture.Scroll)//stop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*gesture.Scroll)//stop: arg 1: expected native")
			}
			arg0Val.Stop()
			return arg0
		},
	},
	"Go(*headless.Window)//frame": {
		Doc:   "(*headless.Window).Frame",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *headless.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*headless.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//frame: arg 1: expected native of type *headless.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//frame: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*headless.Window)//frame: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//frame: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//frame: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*headless.Window)//frame: arg 2: expected native")
			}
			resErr := arg0Val.Frame(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*headless.Window)//release": {
		Doc:   "(*headless.Window).Release",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *headless.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*headless.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//release: arg 1: expected native of type *headless.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//release: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*headless.Window)//release: arg 1: expected native")
			}
			arg0Val.Release()
			return arg0
		},
	},
	"Go(*headless.Window)//screenshot": {
		Doc:   "(*headless.Window).Screenshot",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *headless.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*headless.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//screenshot: arg 1: expected native of type *headless.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//screenshot: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*headless.Window)//screenshot: arg 1: expected native")
			}
			var arg1Val *image.RGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*image.RGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//screenshot: arg 2: expected native of type *image.RGBA")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//screenshot: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*headless.Window)//screenshot: arg 2: expected native")
			}
			resErr := arg0Val.Screenshot(arg1Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(*headless.Window)//size": {
		Doc:   "(*headless.Window).Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *headless.Window
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*headless.Window)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//size: arg 1: expected native of type *headless.Window")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*headless.Window)//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*headless.Window)//size: arg 1: expected native")
			}
			res0 := arg0Val.Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(image.Point)")
			return res0Obj
		},
	},
	"Go(*input.EditorState)//selection!": {
		Doc:   "Set *input.EditorState Selection value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.EditorState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.EditorState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//selection!: arg 1: expected native of type *input.EditorState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//selection!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.EditorState)//selection!: arg 1: expected native")
			}
			var newVal struct {
				Transform f32.Affine2D
				key.Range
				key.Caret
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(struct {
					Transform f32.Affine2D
					key.Range
					key.Caret
				})
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//selection!: arg 2: expected native of type struct{Transform f32.Affine2D; key.Range; key.Caret}")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.EditorState)//selection!: arg 2: expected native")
			}
			self.Selection = newVal
			return arg0
		},
	},
	"Go(*input.EditorState)//selection?": {
		Doc:   "Get *input.EditorState Selection value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.EditorState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.EditorState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//selection?: arg 1: expected native of type *input.EditorState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//selection?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.EditorState)//selection?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Selection, "Go(struct{Transform f32.Affine2D; key.Range; key.Caret})")
			return resObj
		},
	},
	"Go(*input.EditorState)//snippet!": {
		Doc:   "Set *input.EditorState Snippet value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.EditorState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.EditorState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//snippet!: arg 1: expected native of type *input.EditorState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//snippet!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.EditorState)//snippet!: arg 1: expected native")
			}
			var newVal *key.Snippet
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*key.Snippet)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//snippet!: arg 2: expected native of type *key.Snippet")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//snippet!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.EditorState)//snippet!: arg 2: expected native")
			}
			self.Snippet = *newVal
			return arg0
		},
	},
	"Go(*input.EditorState)//snippet?": {
		Doc:   "Get *input.EditorState Snippet value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.EditorState
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.EditorState)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//snippet?: arg 1: expected native of type *input.EditorState")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.EditorState)//snippet?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.EditorState)//snippet?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Snippet, "Go(*key.Snippet)")
			return resObj
		},
	},
	"Go(*input.Router)//action-at": {
		Doc:   "(*input.Router).ActionAt",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//action-at: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//action-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//action-at: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//action-at: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//action-at: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//action-at: arg 2: expected native")
			}
			res0, res1 := arg0Val.ActionAt(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint(res0)))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*input.Router)//append-semantics": {
		Doc:   "(*input.Router).AppendSemantics",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//append-semantics: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//append-semantics: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//append-semantics: arg 1: expected native")
			}
			var arg1Val []input.SemanticNode
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]input.SemanticNode, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(input.SemanticNode)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*input.Router)//append-semantics: arg 2: block item: expected native of type input.SemanticNode")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*input.Router)//append-semantics: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]input.SemanticNode)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//append-semantics: arg 2: expected native of type []input.SemanticNode")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//append-semantics: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//append-semantics: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.AppendSemantics(arg1Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(input.SemanticNode)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"Go(*input.Router)//click-focus": {
		Doc:   "(*input.Router).ClickFocus",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//click-focus: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//click-focus: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//click-focus: arg 1: expected native")
			}
			arg0Val.ClickFocus()
			return arg0
		},
	},
	"Go(*input.Router)//clipboard-requested": {
		Doc:   "(*input.Router).ClipboardRequested",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//clipboard-requested: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//clipboard-requested: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//clipboard-requested: arg 1: expected native")
			}
			res0 := arg0Val.ClipboardRequested()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*input.Router)//cursor": {
		Doc:   "(*input.Router).Cursor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//cursor: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//cursor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//cursor: arg 1: expected native")
			}
			res0 := arg0Val.Cursor()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, byte(res0), "Go(byte)")
			return res0Obj
		},
	},
	"Go(*input.Router)//editor-state": {
		Doc:   "(*input.Router).EditorState",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//editor-state: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//editor-state: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//editor-state: arg 1: expected native")
			}
			res0 := arg0Val.EditorState()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*input.EditorState)")
			return res0Obj
		},
	},
	"Go(*input.Router)//event": {
		Doc:   "(*input.Router).Event",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//event: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//event: arg 1: expected native")
			}
			var arg1Val []event.Filter
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]event.Filter, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.RyeCtx:
						var err error
						arg1Val[i], err = ctxTo_event_Filter(ps, v)
						if err != nil {
							ps.FailureFlag = true
							return env.NewError("Go(*input.Router)//event: arg 2: block item: " + err.Error() + "")
						}
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(event.Filter)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*input.Router)//event: arg 2: block item: expected native of type event.Filter")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*input.Router)//event: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*input.Router)//event: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]event.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//event: arg 2: expected native of type []event.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//event: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//event: arg 2: expected block, native or nil")
			}
			res0, res1 := arg0Val.Event(arg1Val...)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(event.Event)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*input.Router)//frame": {
		Doc:   "(*input.Router).Frame",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//frame: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//frame: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//frame: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//frame: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//frame: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//frame: arg 2: expected native")
			}
			arg0Val.Frame(arg1Val)
			return arg0
		},
	},
	"Go(*input.Router)//move-focus": {
		Doc:   "(*input.Router).MoveFocus",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//move-focus: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//move-focus: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//move-focus: arg 1: expected native")
			}
			var arg1Val key.FocusDirection
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.FocusDirection
				if natOk {
					natVal, natValOk = nat.Value.(key.FocusDirection)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*input.Router)//move-focus: arg 2: expected integer")
					}
					arg1Val = key.FocusDirection(u)
				}
			}
			arg0Val.MoveFocus(arg1Val)
			return arg0
		},
	},
	"Go(*input.Router)//queue": {
		Doc:   "(*input.Router).Queue",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//queue: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//queue: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//queue: arg 1: expected native")
			}
			var arg1Val []event.Event
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]event.Event, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.RyeCtx:
						var err error
						arg1Val[i], err = ctxTo_event_Event(ps, v)
						if err != nil {
							ps.FailureFlag = true
							return env.NewError("Go(*input.Router)//queue: arg 2: block item: " + err.Error() + "")
						}
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(event.Event)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*input.Router)//queue: arg 2: block item: expected native of type event.Event")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*input.Router)//queue: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*input.Router)//queue: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]event.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//queue: arg 2: expected native of type []event.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//queue: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//queue: arg 2: expected block, native or nil")
			}
			arg0Val.Queue(arg1Val...)
			return arg0
		},
	},
	"Go(*input.Router)//reveal-focus": {
		Doc:   "(*input.Router).RevealFocus",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//reveal-focus: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//reveal-focus: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//reveal-focus: arg 1: expected native")
			}
			var arg1Val image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//reveal-focus: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//reveal-focus: arg 2: expected native")
			}
			arg0Val.RevealFocus(arg1Val)
			return arg0
		},
	},
	"Go(*input.Router)//scroll-focus": {
		Doc:   "(*input.Router).ScrollFocus",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//scroll-focus: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//scroll-focus: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//scroll-focus: arg 1: expected native")
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//scroll-focus: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//scroll-focus: arg 2: expected native")
			}
			arg0Val.ScrollFocus(arg1Val)
			return arg0
		},
	},
	"Go(*input.Router)//semantic-at": {
		Doc:   "(*input.Router).SemanticAt",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//semantic-at: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//semantic-at: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//semantic-at: arg 1: expected native")
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//semantic-at: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//semantic-at: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//semantic-at: arg 2: expected native")
			}
			res0, res1 := arg0Val.SemanticAt(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint(res0)))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*input.Router)//source": {
		Doc:   "(*input.Router).Source",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//source: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//source: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//source: arg 1: expected native")
			}
			res0 := arg0Val.Source()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*input.Source)")
			return res0Obj
		},
	},
	"Go(*input.Router)//text-input-hint": {
		Doc:   "(*input.Router).TextInputHint",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//text-input-hint: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//text-input-hint: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//text-input-hint: arg 1: expected native")
			}
			res0, res1 := arg0Val.TextInputHint()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint8(res0)))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*input.Router)//text-input-state": {
		Doc:   "(*input.Router).TextInputState",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//text-input-state: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//text-input-state: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//text-input-state: arg 1: expected native")
			}
			res0 := arg0Val.TextInputState()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint8(res0)))
			return res0Obj
		},
	},
	"Go(*input.Router)//wakeup-time": {
		Doc:   "(*input.Router).WakeupTime",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//wakeup-time: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//wakeup-time: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//wakeup-time: arg 1: expected native")
			}
			res0, res1 := arg0Val.WakeupTime()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(time.Time)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*input.Router)//write-clipboard": {
		Doc:   "(*input.Router).WriteClipboard",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Router
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Router)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//write-clipboard: arg 1: expected native of type *input.Router")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Router)//write-clipboard: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Router)//write-clipboard: arg 1: expected native")
			}
			res0, res1, res2 := arg0Val.WriteClipboard()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			{
				items := make([]env.Object, len(res1))
				for i, it := range res1 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(byte)")
				}
				res1Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var res2Obj env.Object
			res2Obj = *env.NewInteger(boolToInt64(res2))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
				res2Obj,
			}))
		},
	},
	"Go(*input.SemanticDesc)//bounds!": {
		Doc:   "Set *input.SemanticDesc Bounds value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//bounds!: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//bounds!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//bounds!: arg 1: expected native")
			}
			var newVal image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//bounds!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//bounds!: arg 2: expected native")
			}
			self.Bounds = newVal
			return arg0
		},
	},
	"Go(*input.SemanticDesc)//bounds?": {
		Doc:   "Get *input.SemanticDesc Bounds value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//bounds?: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//bounds?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//bounds?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Bounds, "Go(image.Rectangle)")
			return resObj
		},
	},
	"Go(*input.SemanticDesc)//class!": {
		Doc:   "Set *input.SemanticDesc Class value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//class!: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//class!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//class!: arg 1: expected native")
			}
			var newVal semantic.ClassOp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal semantic.ClassOp
				if natOk {
					natVal, natValOk = nat.Value.(semantic.ClassOp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*input.SemanticDesc)//class!: arg 2: expected integer")
					}
					newVal = semantic.ClassOp(u)
				}
			}
			self.Class = newVal
			return arg0
		},
	},
	"Go(*input.SemanticDesc)//class?": {
		Doc:   "Get *input.SemanticDesc Class value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//class?: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//class?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//class?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Class)))
			return resObj
		},
	},
	"Go(*input.SemanticDesc)//description!": {
		Doc:   "Set *input.SemanticDesc Description value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//description!: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//description!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//description!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//description!: arg 2: expected string")
			}
			self.Description = newVal
			return arg0
		},
	},
	"Go(*input.SemanticDesc)//description?": {
		Doc:   "Get *input.SemanticDesc Description value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//description?: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//description?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//description?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Description)
			return resObj
		},
	},
	"Go(*input.SemanticDesc)//disabled!": {
		Doc:   "Set *input.SemanticDesc Disabled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//disabled!: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//disabled!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//disabled!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//disabled!: arg 2: expected integer")
			}
			self.Disabled = newVal
			return arg0
		},
	},
	"Go(*input.SemanticDesc)//disabled?": {
		Doc:   "Get *input.SemanticDesc Disabled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//disabled?: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//disabled?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//disabled?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Disabled))
			return resObj
		},
	},
	"Go(*input.SemanticDesc)//gestures!": {
		Doc:   "Set *input.SemanticDesc Gestures value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//gestures!: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//gestures!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//gestures!: arg 1: expected native")
			}
			var newVal input.SemanticGestures
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal input.SemanticGestures
				if natOk {
					natVal, natValOk = nat.Value.(input.SemanticGestures)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u int
					if v, ok := arg1.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*input.SemanticDesc)//gestures!: arg 2: expected integer")
					}
					newVal = input.SemanticGestures(u)
				}
			}
			self.Gestures = newVal
			return arg0
		},
	},
	"Go(*input.SemanticDesc)//gestures?": {
		Doc:   "Get *input.SemanticDesc Gestures value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//gestures?: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//gestures?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//gestures?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(self.Gestures)))
			return resObj
		},
	},
	"Go(*input.SemanticDesc)//label!": {
		Doc:   "Set *input.SemanticDesc Label value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//label!: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//label!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//label!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//label!: arg 2: expected string")
			}
			self.Label = newVal
			return arg0
		},
	},
	"Go(*input.SemanticDesc)//label?": {
		Doc:   "Get *input.SemanticDesc Label value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//label?: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//label?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//label?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Label)
			return resObj
		},
	},
	"Go(*input.SemanticDesc)//selected!": {
		Doc:   "Set *input.SemanticDesc Selected value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//selected!: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//selected!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//selected!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//selected!: arg 2: expected integer")
			}
			self.Selected = newVal
			return arg0
		},
	},
	"Go(*input.SemanticDesc)//selected?": {
		Doc:   "Get *input.SemanticDesc Selected value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticDesc
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//selected?: arg 1: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticDesc)//selected?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticDesc)//selected?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Selected))
			return resObj
		},
	},
	"Go(*input.SemanticNode)//children!": {
		Doc:   "Set *input.SemanticNode Children value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticNode
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticNode)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//children!: arg 1: expected native of type *input.SemanticNode")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//children!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticNode)//children!: arg 1: expected native")
			}
			var newVal []input.SemanticNode
			switch v := arg1.(type) {
			case env.Block:
				newVal = make([]input.SemanticNode, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						newVal[i], ok = v.Value.(input.SemanticNode)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*input.SemanticNode)//children!: arg 2: block item: expected native of type input.SemanticNode")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*input.SemanticNode)//children!: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.([]input.SemanticNode)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//children!: arg 2: expected native of type []input.SemanticNode")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//children!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticNode)//children!: arg 2: expected block, native or nil")
			}
			self.Children = newVal
			return arg0
		},
	},
	"Go(*input.SemanticNode)//children?": {
		Doc:   "Get *input.SemanticNode Children value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticNode
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticNode)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//children?: arg 1: expected native of type *input.SemanticNode")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//children?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticNode)//children?: arg 1: expected native")
			}
			var resObj env.Object
			{
				items := make([]env.Object, len(self.Children))
				for i, it := range self.Children {
					items[i] = *env.NewNative(ps.Idx, it, "Go(input.SemanticNode)")
				}
				resObj = *env.NewBlock(*env.NewTSeries(items))
			}
			return resObj
		},
	},
	"Go(*input.SemanticNode)//desc!": {
		Doc:   "Set *input.SemanticNode Desc value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticNode
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticNode)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//desc!: arg 1: expected native of type *input.SemanticNode")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//desc!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticNode)//desc!: arg 1: expected native")
			}
			var newVal *input.SemanticDesc
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*input.SemanticDesc)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//desc!: arg 2: expected native of type *input.SemanticDesc")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//desc!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticNode)//desc!: arg 2: expected native")
			}
			self.Desc = *newVal
			return arg0
		},
	},
	"Go(*input.SemanticNode)//desc?": {
		Doc:   "Get *input.SemanticNode Desc value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticNode
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticNode)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//desc?: arg 1: expected native of type *input.SemanticNode")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//desc?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticNode)//desc?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Desc, "Go(*input.SemanticDesc)")
			return resObj
		},
	},
	"Go(*input.SemanticNode)//id!": {
		Doc:   "Set *input.SemanticNode ID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticNode
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticNode)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//id!: arg 1: expected native of type *input.SemanticNode")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//id!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticNode)//id!: arg 1: expected native")
			}
			var newVal input.SemanticID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal input.SemanticID
				if natOk {
					natVal, natValOk = nat.Value.(input.SemanticID)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint
					if v, ok := arg1.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*input.SemanticNode)//id!: arg 2: expected integer")
					}
					newVal = input.SemanticID(u)
				}
			}
			self.ID = newVal
			return arg0
		},
	},
	"Go(*input.SemanticNode)//id?": {
		Doc:   "Get *input.SemanticNode ID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticNode
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticNode)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//id?: arg 1: expected native of type *input.SemanticNode")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//id?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticNode)//id?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(self.ID)))
			return resObj
		},
	},
	"Go(*input.SemanticNode)//parent-id!": {
		Doc:   "Set *input.SemanticNode ParentID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticNode
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticNode)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//parent-id!: arg 1: expected native of type *input.SemanticNode")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//parent-id!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticNode)//parent-id!: arg 1: expected native")
			}
			var newVal input.SemanticID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal input.SemanticID
				if natOk {
					natVal, natValOk = nat.Value.(input.SemanticID)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint
					if v, ok := arg1.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*input.SemanticNode)//parent-id!: arg 2: expected integer")
					}
					newVal = input.SemanticID(u)
				}
			}
			self.ParentID = newVal
			return arg0
		},
	},
	"Go(*input.SemanticNode)//parent-id?": {
		Doc:   "Get *input.SemanticNode ParentID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SemanticNode
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SemanticNode)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//parent-id?: arg 1: expected native of type *input.SemanticNode")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SemanticNode)//parent-id?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SemanticNode)//parent-id?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(self.ParentID)))
			return resObj
		},
	},
	"Go(*input.Source)//enabled": {
		Doc:   "input.Source.Enabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Source
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Source)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//enabled: arg 1: expected native of type *input.Source")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//enabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Source)//enabled: arg 1: expected native")
			}
			res0 := (*arg0Val).Enabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*input.Source)//event": {
		Doc:   "input.Source.Event",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Source
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Source)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//event: arg 1: expected native of type *input.Source")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Source)//event: arg 1: expected native")
			}
			var arg1Val []event.Filter
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]event.Filter, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.RyeCtx:
						var err error
						arg1Val[i], err = ctxTo_event_Filter(ps, v)
						if err != nil {
							ps.FailureFlag = true
							return env.NewError("Go(*input.Source)//event: arg 2: block item: " + err.Error() + "")
						}
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(event.Filter)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*input.Source)//event: arg 2: block item: expected native of type event.Filter")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*input.Source)//event: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*input.Source)//event: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]event.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//event: arg 2: expected native of type []event.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//event: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Source)//event: arg 2: expected block, native or nil")
			}
			res0, res1 := (*arg0Val).Event(arg1Val...)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(event.Event)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*input.Source)//execute": {
		Doc:   "input.Source.Execute",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Source
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Source)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//execute: arg 1: expected native of type *input.Source")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//execute: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Source)//execute: arg 1: expected native")
			}
			var arg1Val input.Command
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_input_Command(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//execute: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(input.Command)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//execute: arg 2: expected native of type input.Command")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//execute: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Source)//execute: arg 2: expected native")
			}
			(*arg0Val).Execute(arg1Val)
			return arg0
		},
	},
	"Go(*input.Source)//focused": {
		Doc:   "input.Source.Focused",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.Source
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.Source)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//focused: arg 1: expected native of type *input.Source")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//focused: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Source)//focused: arg 1: expected native")
			}
			var arg1Val event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//focused: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//focused: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.Source)//focused: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.Source)//focused: arg 2: expected native")
			}
			res0 := (*arg0Val).Focused(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*input.SystemEvent)//event!": {
		Doc:   "Set *input.SystemEvent Event value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SystemEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SystemEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SystemEvent)//event!: arg 1: expected native of type *input.SystemEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SystemEvent)//event!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SystemEvent)//event!: arg 1: expected native")
			}
			var newVal event.Event
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Event(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SystemEvent)//event!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SystemEvent)//event!: arg 2: expected native of type event.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SystemEvent)//event!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SystemEvent)//event!: arg 2: expected native")
			}
			self.Event = newVal
			return arg0
		},
	},
	"Go(*input.SystemEvent)//event?": {
		Doc:   "Get *input.SystemEvent Event value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *input.SystemEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*input.SystemEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SystemEvent)//event?: arg 1: expected native of type *input.SystemEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SystemEvent)//event?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SystemEvent)//event?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Event, "Go(event.Event)")
			return resObj
		},
	},
	"Go(*input.SystemEvent)//implements-event": {
		Doc:   "input.SystemEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *input.SystemEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*input.SystemEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SystemEvent)//implements-event: arg 1: expected native of type *input.SystemEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*input.SystemEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*input.SystemEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*key.Caret)//ascent!": {
		Doc:   "Set *key.Caret Ascent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Caret
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Caret)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//ascent!: arg 1: expected native of type *key.Caret")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//ascent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Caret)//ascent!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.Caret)//ascent!: arg 2: expected decimal")
			}
			self.Ascent = newVal
			return arg0
		},
	},
	"Go(*key.Caret)//ascent?": {
		Doc:   "Get *key.Caret Ascent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Caret
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Caret)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//ascent?: arg 1: expected native of type *key.Caret")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//ascent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Caret)//ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Ascent))
			return resObj
		},
	},
	"Go(*key.Caret)//descent!": {
		Doc:   "Set *key.Caret Descent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Caret
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Caret)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//descent!: arg 1: expected native of type *key.Caret")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//descent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Caret)//descent!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.Caret)//descent!: arg 2: expected decimal")
			}
			self.Descent = newVal
			return arg0
		},
	},
	"Go(*key.Caret)//descent?": {
		Doc:   "Get *key.Caret Descent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Caret
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Caret)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//descent?: arg 1: expected native of type *key.Caret")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//descent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Caret)//descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Descent))
			return resObj
		},
	},
	"Go(*key.Caret)//pos!": {
		Doc:   "Set *key.Caret Pos value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Caret
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Caret)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//pos!: arg 1: expected native of type *key.Caret")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//pos!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Caret)//pos!: arg 1: expected native")
			}
			var newVal *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//pos!: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//pos!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Caret)//pos!: arg 2: expected native")
			}
			self.Pos = *newVal
			return arg0
		},
	},
	"Go(*key.Caret)//pos?": {
		Doc:   "Get *key.Caret Pos value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Caret
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Caret)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//pos?: arg 1: expected native of type *key.Caret")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Caret)//pos?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Caret)//pos?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Pos, "Go(*f32.Point)")
			return resObj
		},
	},
	"Go(*key.EditEvent)//implements-event": {
		Doc:   "key.EditEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *key.EditEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*key.EditEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//implements-event: arg 1: expected native of type *key.EditEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.EditEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*key.EditEvent)//range!": {
		Doc:   "Set *key.EditEvent Range value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.EditEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.EditEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//range!: arg 1: expected native of type *key.EditEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//range!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.EditEvent)//range!: arg 1: expected native")
			}
			var newVal *key.Range
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*key.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//range!: arg 2: expected native of type *key.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//range!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.EditEvent)//range!: arg 2: expected native")
			}
			self.Range = *newVal
			return arg0
		},
	},
	"Go(*key.EditEvent)//range?": {
		Doc:   "Get *key.EditEvent Range value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.EditEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.EditEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//range?: arg 1: expected native of type *key.EditEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//range?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.EditEvent)//range?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Range, "Go(*key.Range)")
			return resObj
		},
	},
	"Go(*key.EditEvent)//text!": {
		Doc:   "Set *key.EditEvent Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.EditEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.EditEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//text!: arg 1: expected native of type *key.EditEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.EditEvent)//text!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.EditEvent)//text!: arg 2: expected string")
			}
			self.Text = newVal
			return arg0
		},
	},
	"Go(*key.EditEvent)//text?": {
		Doc:   "Get *key.EditEvent Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.EditEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.EditEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//text?: arg 1: expected native of type *key.EditEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.EditEvent)//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.EditEvent)//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"Go(*key.Event)//implements-event": {
		Doc:   "key.Event.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *key.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*key.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//implements-event: arg 1: expected native of type *key.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Event)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*key.Event)//modifiers!": {
		Doc:   "Set *key.Event Modifiers value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//modifiers!: arg 1: expected native of type *key.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//modifiers!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Event)//modifiers!: arg 1: expected native")
			}
			var newVal key.Modifiers
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.Modifiers
				if natOk {
					natVal, natValOk = nat.Value.(key.Modifiers)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*key.Event)//modifiers!: arg 2: expected integer")
					}
					newVal = key.Modifiers(u)
				}
			}
			self.Modifiers = newVal
			return arg0
		},
	},
	"Go(*key.Event)//modifiers?": {
		Doc:   "Get *key.Event Modifiers value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//modifiers?: arg 1: expected native of type *key.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//modifiers?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Event)//modifiers?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(self.Modifiers)))
			return resObj
		},
	},
	"Go(*key.Event)//name!": {
		Doc:   "Set *key.Event Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//name!: arg 1: expected native of type *key.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Event)//name!: arg 1: expected native")
			}
			var newVal key.Name
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.Name
				if natOk {
					natVal, natValOk = nat.Value.(key.Name)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*key.Event)//name!: arg 2: expected string")
					}
					newVal = key.Name(u)
				}
			}
			self.Name = newVal
			return arg0
		},
	},
	"Go(*key.Event)//name?": {
		Doc:   "Get *key.Event Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//name?: arg 1: expected native of type *key.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Event)//name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.Name))
			return resObj
		},
	},
	"Go(*key.Event)//state!": {
		Doc:   "Set *key.Event State value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//state!: arg 1: expected native of type *key.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//state!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Event)//state!: arg 1: expected native")
			}
			var newVal key.State
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.State
				if natOk {
					natVal, natValOk = nat.Value.(key.State)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*key.Event)//state!: arg 2: expected integer")
					}
					newVal = key.State(u)
				}
			}
			self.State = newVal
			return arg0
		},
	},
	"Go(*key.Event)//state?": {
		Doc:   "Get *key.Event State value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//state?: arg 1: expected native of type *key.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Event)//state?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Event)//state?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.State)))
			return resObj
		},
	},
	"Go(*key.Filter)//focus!": {
		Doc:   "Set *key.Filter Focus value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//focus!: arg 1: expected native of type *key.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//focus!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Filter)//focus!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//focus!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//focus!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//focus!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Filter)//focus!: arg 2: expected native")
			}
			self.Focus = newVal
			return arg0
		},
	},
	"Go(*key.Filter)//focus?": {
		Doc:   "Get *key.Filter Focus value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//focus?: arg 1: expected native of type *key.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//focus?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Filter)//focus?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Focus, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*key.Filter)//implements-filter": {
		Doc:   "key.Filter.ImplementsFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *key.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*key.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//implements-filter: arg 1: expected native of type *key.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//implements-filter: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Filter)//implements-filter: arg 1: expected native")
			}
			(*arg0Val).ImplementsFilter()
			return arg0
		},
	},
	"Go(*key.Filter)//name!": {
		Doc:   "Set *key.Filter Name value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//name!: arg 1: expected native of type *key.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//name!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Filter)//name!: arg 1: expected native")
			}
			var newVal key.Name
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.Name
				if natOk {
					natVal, natValOk = nat.Value.(key.Name)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*key.Filter)//name!: arg 2: expected string")
					}
					newVal = key.Name(u)
				}
			}
			self.Name = newVal
			return arg0
		},
	},
	"Go(*key.Filter)//name?": {
		Doc:   "Get *key.Filter Name value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//name?: arg 1: expected native of type *key.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//name?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Filter)//name?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.Name))
			return resObj
		},
	},
	"Go(*key.Filter)//optional!": {
		Doc:   "Set *key.Filter Optional value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//optional!: arg 1: expected native of type *key.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//optional!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Filter)//optional!: arg 1: expected native")
			}
			var newVal key.Modifiers
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.Modifiers
				if natOk {
					natVal, natValOk = nat.Value.(key.Modifiers)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*key.Filter)//optional!: arg 2: expected integer")
					}
					newVal = key.Modifiers(u)
				}
			}
			self.Optional = newVal
			return arg0
		},
	},
	"Go(*key.Filter)//optional?": {
		Doc:   "Get *key.Filter Optional value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//optional?: arg 1: expected native of type *key.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//optional?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Filter)//optional?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(self.Optional)))
			return resObj
		},
	},
	"Go(*key.Filter)//required!": {
		Doc:   "Set *key.Filter Required value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//required!: arg 1: expected native of type *key.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//required!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Filter)//required!: arg 1: expected native")
			}
			var newVal key.Modifiers
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.Modifiers
				if natOk {
					natVal, natValOk = nat.Value.(key.Modifiers)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*key.Filter)//required!: arg 2: expected integer")
					}
					newVal = key.Modifiers(u)
				}
			}
			self.Required = newVal
			return arg0
		},
	},
	"Go(*key.Filter)//required?": {
		Doc:   "Get *key.Filter Required value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//required?: arg 1: expected native of type *key.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Filter)//required?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Filter)//required?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(self.Required)))
			return resObj
		},
	},
	"Go(*key.FocusCmd)//implements-command": {
		Doc:   "key.FocusCmd.ImplementsCommand",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *key.FocusCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*key.FocusCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusCmd)//implements-command: arg 1: expected native of type *key.FocusCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusCmd)//implements-command: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusCmd)//implements-command: arg 1: expected native")
			}
			(*arg0Val).ImplementsCommand()
			return arg0
		},
	},
	"Go(*key.FocusCmd)//tag!": {
		Doc:   "Set *key.FocusCmd Tag value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.FocusCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.FocusCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusCmd)//tag!: arg 1: expected native of type *key.FocusCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusCmd)//tag!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusCmd)//tag!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusCmd)//tag!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusCmd)//tag!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusCmd)//tag!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusCmd)//tag!: arg 2: expected native")
			}
			self.Tag = newVal
			return arg0
		},
	},
	"Go(*key.FocusCmd)//tag?": {
		Doc:   "Get *key.FocusCmd Tag value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.FocusCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.FocusCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusCmd)//tag?: arg 1: expected native of type *key.FocusCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusCmd)//tag?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusCmd)//tag?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Tag, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*key.FocusEvent)//focus!": {
		Doc:   "Set *key.FocusEvent Focus value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.FocusEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.FocusEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusEvent)//focus!: arg 1: expected native of type *key.FocusEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusEvent)//focus!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusEvent)//focus!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusEvent)//focus!: arg 2: expected integer")
			}
			self.Focus = newVal
			return arg0
		},
	},
	"Go(*key.FocusEvent)//focus?": {
		Doc:   "Get *key.FocusEvent Focus value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.FocusEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.FocusEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusEvent)//focus?: arg 1: expected native of type *key.FocusEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusEvent)//focus?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusEvent)//focus?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Focus))
			return resObj
		},
	},
	"Go(*key.FocusEvent)//implements-event": {
		Doc:   "key.FocusEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *key.FocusEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*key.FocusEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusEvent)//implements-event: arg 1: expected native of type *key.FocusEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*key.FocusFilter)//implements-filter": {
		Doc:   "key.FocusFilter.ImplementsFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *key.FocusFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*key.FocusFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusFilter)//implements-filter: arg 1: expected native of type *key.FocusFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusFilter)//implements-filter: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusFilter)//implements-filter: arg 1: expected native")
			}
			(*arg0Val).ImplementsFilter()
			return arg0
		},
	},
	"Go(*key.FocusFilter)//target!": {
		Doc:   "Set *key.FocusFilter Target value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.FocusFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.FocusFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusFilter)//target!: arg 1: expected native of type *key.FocusFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusFilter)//target!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusFilter)//target!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusFilter)//target!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusFilter)//target!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusFilter)//target!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusFilter)//target!: arg 2: expected native")
			}
			self.Target = newVal
			return arg0
		},
	},
	"Go(*key.FocusFilter)//target?": {
		Doc:   "Get *key.FocusFilter Target value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.FocusFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.FocusFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusFilter)//target?: arg 1: expected native of type *key.FocusFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.FocusFilter)//target?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.FocusFilter)//target?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Target, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*key.InputHintOp)//add": {
		Doc:   "key.InputHintOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *key.InputHintOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*key.InputHintOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//add: arg 1: expected native of type *key.InputHintOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.InputHintOp)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.InputHintOp)//add: arg 2: expected native")
			}
			(*arg0Val).Add(arg1Val)
			return arg0
		},
	},
	"Go(*key.InputHintOp)//hint!": {
		Doc:   "Set *key.InputHintOp Hint value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.InputHintOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.InputHintOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//hint!: arg 1: expected native of type *key.InputHintOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//hint!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.InputHintOp)//hint!: arg 1: expected native")
			}
			var newVal key.InputHint
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.InputHint
				if natOk {
					natVal, natValOk = nat.Value.(key.InputHint)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*key.InputHintOp)//hint!: arg 2: expected integer")
					}
					newVal = key.InputHint(u)
				}
			}
			self.Hint = newVal
			return arg0
		},
	},
	"Go(*key.InputHintOp)//hint?": {
		Doc:   "Get *key.InputHintOp Hint value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.InputHintOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.InputHintOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//hint?: arg 1: expected native of type *key.InputHintOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//hint?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.InputHintOp)//hint?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Hint)))
			return resObj
		},
	},
	"Go(*key.InputHintOp)//tag!": {
		Doc:   "Set *key.InputHintOp Tag value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.InputHintOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.InputHintOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//tag!: arg 1: expected native of type *key.InputHintOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//tag!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.InputHintOp)//tag!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//tag!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//tag!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//tag!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.InputHintOp)//tag!: arg 2: expected native")
			}
			self.Tag = newVal
			return arg0
		},
	},
	"Go(*key.InputHintOp)//tag?": {
		Doc:   "Get *key.InputHintOp Tag value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.InputHintOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.InputHintOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//tag?: arg 1: expected native of type *key.InputHintOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.InputHintOp)//tag?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.InputHintOp)//tag?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Tag, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*key.Range)//end!": {
		Doc:   "Set *key.Range End value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Range
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Range)//end!: arg 1: expected native of type *key.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Range)//end!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Range)//end!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.Range)//end!: arg 2: expected integer")
			}
			self.End = newVal
			return arg0
		},
	},
	"Go(*key.Range)//end?": {
		Doc:   "Get *key.Range End value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Range
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Range)//end?: arg 1: expected native of type *key.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Range)//end?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Range)//end?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.End))
			return resObj
		},
	},
	"Go(*key.Range)//start!": {
		Doc:   "Set *key.Range Start value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Range
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Range)//start!: arg 1: expected native of type *key.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Range)//start!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Range)//start!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.Range)//start!: arg 2: expected integer")
			}
			self.Start = newVal
			return arg0
		},
	},
	"Go(*key.Range)//start?": {
		Doc:   "Get *key.Range Start value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Range
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Range)//start?: arg 1: expected native of type *key.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Range)//start?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Range)//start?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Start))
			return resObj
		},
	},
	"Go(*key.SelectionCmd)//ascent!": {
		Doc:   "Set *key.SelectionCmd Ascent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//ascent!: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//ascent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//ascent!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//ascent!: arg 2: expected decimal")
			}
			self.Ascent = newVal
			return arg0
		},
	},
	"Go(*key.SelectionCmd)//ascent?": {
		Doc:   "Get *key.SelectionCmd Ascent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//ascent?: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//ascent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Ascent))
			return resObj
		},
	},
	"Go(*key.SelectionCmd)//caret!": {
		Doc:   "Set *key.SelectionCmd Caret value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//caret!: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//caret!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//caret!: arg 1: expected native")
			}
			var newVal *key.Caret
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*key.Caret)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//caret!: arg 2: expected native of type *key.Caret")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//caret!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//caret!: arg 2: expected native")
			}
			self.Caret = *newVal
			return arg0
		},
	},
	"Go(*key.SelectionCmd)//caret?": {
		Doc:   "Get *key.SelectionCmd Caret value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//caret?: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//caret?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//caret?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Caret, "Go(*key.Caret)")
			return resObj
		},
	},
	"Go(*key.SelectionCmd)//descent!": {
		Doc:   "Set *key.SelectionCmd Descent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//descent!: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//descent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//descent!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//descent!: arg 2: expected decimal")
			}
			self.Descent = newVal
			return arg0
		},
	},
	"Go(*key.SelectionCmd)//descent?": {
		Doc:   "Get *key.SelectionCmd Descent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//descent?: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//descent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Descent))
			return resObj
		},
	},
	"Go(*key.SelectionCmd)//end!": {
		Doc:   "Set *key.SelectionCmd End value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//end!: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//end!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//end!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//end!: arg 2: expected integer")
			}
			self.End = newVal
			return arg0
		},
	},
	"Go(*key.SelectionCmd)//end?": {
		Doc:   "Get *key.SelectionCmd End value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//end?: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//end?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//end?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.End))
			return resObj
		},
	},
	"Go(*key.SelectionCmd)//implements-command": {
		Doc:   "key.SelectionCmd.ImplementsCommand",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//implements-command: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//implements-command: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//implements-command: arg 1: expected native")
			}
			(*arg0Val).ImplementsCommand()
			return arg0
		},
	},
	"Go(*key.SelectionCmd)//pos!": {
		Doc:   "Set *key.SelectionCmd Pos value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//pos!: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//pos!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//pos!: arg 1: expected native")
			}
			var newVal *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//pos!: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//pos!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//pos!: arg 2: expected native")
			}
			self.Pos = *newVal
			return arg0
		},
	},
	"Go(*key.SelectionCmd)//pos?": {
		Doc:   "Get *key.SelectionCmd Pos value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//pos?: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//pos?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//pos?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Pos, "Go(*f32.Point)")
			return resObj
		},
	},
	"Go(*key.SelectionCmd)//range!": {
		Doc:   "Set *key.SelectionCmd Range value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//range!: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//range!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//range!: arg 1: expected native")
			}
			var newVal *key.Range
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*key.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//range!: arg 2: expected native of type *key.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//range!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//range!: arg 2: expected native")
			}
			self.Range = *newVal
			return arg0
		},
	},
	"Go(*key.SelectionCmd)//range?": {
		Doc:   "Get *key.SelectionCmd Range value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//range?: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//range?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//range?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Range, "Go(*key.Range)")
			return resObj
		},
	},
	"Go(*key.SelectionCmd)//start!": {
		Doc:   "Set *key.SelectionCmd Start value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//start!: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//start!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//start!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//start!: arg 2: expected integer")
			}
			self.Start = newVal
			return arg0
		},
	},
	"Go(*key.SelectionCmd)//start?": {
		Doc:   "Get *key.SelectionCmd Start value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//start?: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//start?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//start?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Start))
			return resObj
		},
	},
	"Go(*key.SelectionCmd)//tag!": {
		Doc:   "Set *key.SelectionCmd Tag value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//tag!: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//tag!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//tag!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//tag!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//tag!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//tag!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//tag!: arg 2: expected native")
			}
			self.Tag = newVal
			return arg0
		},
	},
	"Go(*key.SelectionCmd)//tag?": {
		Doc:   "Get *key.SelectionCmd Tag value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SelectionCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SelectionCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//tag?: arg 1: expected native of type *key.SelectionCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SelectionCmd)//tag?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SelectionCmd)//tag?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Tag, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*key.Snippet)//end!": {
		Doc:   "Set *key.Snippet End value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Snippet
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Snippet)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//end!: arg 1: expected native of type *key.Snippet")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//end!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//end!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//end!: arg 2: expected integer")
			}
			self.End = newVal
			return arg0
		},
	},
	"Go(*key.Snippet)//end?": {
		Doc:   "Get *key.Snippet End value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Snippet
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Snippet)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//end?: arg 1: expected native of type *key.Snippet")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//end?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//end?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.End))
			return resObj
		},
	},
	"Go(*key.Snippet)//range!": {
		Doc:   "Set *key.Snippet Range value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Snippet
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Snippet)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//range!: arg 1: expected native of type *key.Snippet")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//range!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//range!: arg 1: expected native")
			}
			var newVal *key.Range
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*key.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//range!: arg 2: expected native of type *key.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//range!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//range!: arg 2: expected native")
			}
			self.Range = *newVal
			return arg0
		},
	},
	"Go(*key.Snippet)//range?": {
		Doc:   "Get *key.Snippet Range value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Snippet
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Snippet)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//range?: arg 1: expected native of type *key.Snippet")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//range?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//range?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Range, "Go(*key.Range)")
			return resObj
		},
	},
	"Go(*key.Snippet)//start!": {
		Doc:   "Set *key.Snippet Start value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Snippet
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Snippet)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//start!: arg 1: expected native of type *key.Snippet")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//start!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//start!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//start!: arg 2: expected integer")
			}
			self.Start = newVal
			return arg0
		},
	},
	"Go(*key.Snippet)//start?": {
		Doc:   "Get *key.Snippet Start value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Snippet
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Snippet)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//start?: arg 1: expected native of type *key.Snippet")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//start?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//start?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Start))
			return resObj
		},
	},
	"Go(*key.Snippet)//text!": {
		Doc:   "Set *key.Snippet Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Snippet
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Snippet)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//text!: arg 1: expected native of type *key.Snippet")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//text!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//text!: arg 2: expected string")
			}
			self.Text = newVal
			return arg0
		},
	},
	"Go(*key.Snippet)//text?": {
		Doc:   "Get *key.Snippet Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.Snippet
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.Snippet)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//text?: arg 1: expected native of type *key.Snippet")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.Snippet)//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.Snippet)//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"Go(*key.SnippetCmd)//end!": {
		Doc:   "Set *key.SnippetCmd End value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//end!: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//end!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//end!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//end!: arg 2: expected integer")
			}
			self.End = newVal
			return arg0
		},
	},
	"Go(*key.SnippetCmd)//end?": {
		Doc:   "Get *key.SnippetCmd End value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//end?: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//end?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//end?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.End))
			return resObj
		},
	},
	"Go(*key.SnippetCmd)//implements-command": {
		Doc:   "key.SnippetCmd.ImplementsCommand",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//implements-command: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//implements-command: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//implements-command: arg 1: expected native")
			}
			(*arg0Val).ImplementsCommand()
			return arg0
		},
	},
	"Go(*key.SnippetCmd)//range!": {
		Doc:   "Set *key.SnippetCmd Range value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//range!: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//range!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//range!: arg 1: expected native")
			}
			var newVal *key.Range
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*key.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//range!: arg 2: expected native of type *key.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//range!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//range!: arg 2: expected native")
			}
			self.Range = *newVal
			return arg0
		},
	},
	"Go(*key.SnippetCmd)//range?": {
		Doc:   "Get *key.SnippetCmd Range value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//range?: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//range?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//range?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Range, "Go(*key.Range)")
			return resObj
		},
	},
	"Go(*key.SnippetCmd)//snippet!": {
		Doc:   "Set *key.SnippetCmd Snippet value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//snippet!: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//snippet!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//snippet!: arg 1: expected native")
			}
			var newVal *key.Snippet
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*key.Snippet)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//snippet!: arg 2: expected native of type *key.Snippet")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//snippet!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//snippet!: arg 2: expected native")
			}
			self.Snippet = *newVal
			return arg0
		},
	},
	"Go(*key.SnippetCmd)//snippet?": {
		Doc:   "Get *key.SnippetCmd Snippet value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//snippet?: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//snippet?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//snippet?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Snippet, "Go(*key.Snippet)")
			return resObj
		},
	},
	"Go(*key.SnippetCmd)//start!": {
		Doc:   "Set *key.SnippetCmd Start value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//start!: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//start!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//start!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//start!: arg 2: expected integer")
			}
			self.Start = newVal
			return arg0
		},
	},
	"Go(*key.SnippetCmd)//start?": {
		Doc:   "Get *key.SnippetCmd Start value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//start?: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//start?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//start?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Start))
			return resObj
		},
	},
	"Go(*key.SnippetCmd)//tag!": {
		Doc:   "Set *key.SnippetCmd Tag value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//tag!: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//tag!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//tag!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//tag!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//tag!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//tag!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//tag!: arg 2: expected native")
			}
			self.Tag = newVal
			return arg0
		},
	},
	"Go(*key.SnippetCmd)//tag?": {
		Doc:   "Get *key.SnippetCmd Tag value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//tag?: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//tag?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//tag?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Tag, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*key.SnippetCmd)//text!": {
		Doc:   "Set *key.SnippetCmd Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//text!: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//text!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//text!: arg 2: expected string")
			}
			self.Text = newVal
			return arg0
		},
	},
	"Go(*key.SnippetCmd)//text?": {
		Doc:   "Get *key.SnippetCmd Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SnippetCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SnippetCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//text?: arg 1: expected native of type *key.SnippetCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SnippetCmd)//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SnippetCmd)//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"Go(*key.SoftKeyboardCmd)//implements-command": {
		Doc:   "key.SoftKeyboardCmd.ImplementsCommand",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *key.SoftKeyboardCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*key.SoftKeyboardCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SoftKeyboardCmd)//implements-command: arg 1: expected native of type *key.SoftKeyboardCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SoftKeyboardCmd)//implements-command: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SoftKeyboardCmd)//implements-command: arg 1: expected native")
			}
			(*arg0Val).ImplementsCommand()
			return arg0
		},
	},
	"Go(*key.SoftKeyboardCmd)//show!": {
		Doc:   "Set *key.SoftKeyboardCmd Show value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SoftKeyboardCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SoftKeyboardCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SoftKeyboardCmd)//show!: arg 1: expected native of type *key.SoftKeyboardCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SoftKeyboardCmd)//show!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SoftKeyboardCmd)//show!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*key.SoftKeyboardCmd)//show!: arg 2: expected integer")
			}
			self.Show = newVal
			return arg0
		},
	},
	"Go(*key.SoftKeyboardCmd)//show?": {
		Doc:   "Get *key.SoftKeyboardCmd Show value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *key.SoftKeyboardCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*key.SoftKeyboardCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SoftKeyboardCmd)//show?: arg 1: expected native of type *key.SoftKeyboardCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*key.SoftKeyboardCmd)//show?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*key.SoftKeyboardCmd)//show?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Show))
			return resObj
		},
	},
	"Go(*layout.Background)//layout": {
		Doc:   "layout.Background.Layout",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Background
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Background)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Background)//layout: arg 1: expected native of type *layout.Background")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Background)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Background)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Background)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Background)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Background)//layout: arg 2: expected native")
			}
			var arg2Val layout.Widget
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg2.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Background)//layout: arg 3: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*layout.Background)//layout: arg 3: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*layout.Background)//layout: arg 3: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Background)//layout: arg 3: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Background)//layout: arg 3: expected function or nil")
					}
					arg2Val = layout.Widget(u)
				}
			}
			var arg3Val layout.Widget
			{
				nat, natOk := arg3.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg3Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg3.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Background)//layout: arg 4: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*layout.Background)//layout: arg 4: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*layout.Background)//layout: arg 4: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Background)//layout: arg 4: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Background)//layout: arg 4: expected function or nil")
					}
					arg3Val = layout.Widget(u)
				}
			}
			res0 := (*arg0Val).Layout(*arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*layout.Constraints)//add-min": {
		Doc:   "layout.Constraints.AddMin",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Constraints
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Constraints)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//add-min: arg 1: expected native of type *layout.Constraints")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//add-min: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//add-min: arg 1: expected native")
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//add-min: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//add-min: arg 2: expected native")
			}
			res0 := (*arg0Val).AddMin(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Constraints)")
			return res0Obj
		},
	},
	"Go(*layout.Constraints)//constrain": {
		Doc:   "layout.Constraints.Constrain",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Constraints
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Constraints)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//constrain: arg 1: expected native of type *layout.Constraints")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//constrain: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//constrain: arg 1: expected native")
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//constrain: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//constrain: arg 2: expected native")
			}
			res0 := (*arg0Val).Constrain(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(image.Point)")
			return res0Obj
		},
	},
	"Go(*layout.Constraints)//max!": {
		Doc:   "Set *layout.Constraints Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Constraints
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Constraints)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//max!: arg 1: expected native of type *layout.Constraints")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//max!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//max!: arg 1: expected native")
			}
			var newVal image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//max!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//max!: arg 2: expected native")
			}
			self.Max = newVal
			return arg0
		},
	},
	"Go(*layout.Constraints)//max?": {
		Doc:   "Get *layout.Constraints Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Constraints
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Constraints)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//max?: arg 1: expected native of type *layout.Constraints")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//max?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//max?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Max, "Go(image.Point)")
			return resObj
		},
	},
	"Go(*layout.Constraints)//min!": {
		Doc:   "Set *layout.Constraints Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Constraints
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Constraints)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//min!: arg 1: expected native of type *layout.Constraints")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//min!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//min!: arg 1: expected native")
			}
			var newVal image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//min!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//min!: arg 2: expected native")
			}
			self.Min = newVal
			return arg0
		},
	},
	"Go(*layout.Constraints)//min?": {
		Doc:   "Get *layout.Constraints Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Constraints
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Constraints)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//min?: arg 1: expected native of type *layout.Constraints")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//min?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//min?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Min, "Go(image.Point)")
			return resObj
		},
	},
	"Go(*layout.Constraints)//sub-max": {
		Doc:   "layout.Constraints.SubMax",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Constraints
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Constraints)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//sub-max: arg 1: expected native of type *layout.Constraints")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//sub-max: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//sub-max: arg 1: expected native")
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Constraints)//sub-max: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Constraints)//sub-max: arg 2: expected native")
			}
			res0 := (*arg0Val).SubMax(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Constraints)")
			return res0Obj
		},
	},
	"Go(*layout.Context)//constraints!": {
		Doc:   "Set *layout.Context Constraints value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//constraints!: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//constraints!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//constraints!: arg 1: expected native")
			}
			var newVal *layout.Constraints
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*layout.Constraints)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//constraints!: arg 2: expected native of type *layout.Constraints")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//constraints!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//constraints!: arg 2: expected native")
			}
			self.Constraints = *newVal
			return arg0
		},
	},
	"Go(*layout.Context)//constraints?": {
		Doc:   "Get *layout.Context Constraints value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//constraints?: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//constraints?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//constraints?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Constraints, "Go(*layout.Constraints)")
			return resObj
		},
	},
	"Go(*layout.Context)//disabled": {
		Doc:   "layout.Context.Disabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//disabled: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//disabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//disabled: arg 1: expected native")
			}
			res0 := (*arg0Val).Disabled()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Context)")
			return res0Obj
		},
	},
	"Go(*layout.Context)//dp": {
		Doc:   "layout.Context.Dp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//dp: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//dp: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//dp: arg 1: expected native")
			}
			var arg1Val unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Context)//dp: arg 2: expected decimal")
					}
					arg1Val = unit.Dp(u)
				}
			}
			res0 := (*arg0Val).Dp(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*layout.Context)//enabled": {
		Doc:   "layout.Context.Enabled",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//enabled: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//enabled: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//enabled: arg 1: expected native")
			}
			res0 := (*arg0Val).Enabled()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*layout.Context)//event": {
		Doc:   "layout.Context.Event",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//event: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//event: arg 1: expected native")
			}
			var arg1Val []event.Filter
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]event.Filter, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.RyeCtx:
						var err error
						arg1Val[i], err = ctxTo_event_Filter(ps, v)
						if err != nil {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Context)//event: arg 2: block item: " + err.Error() + "")
						}
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(event.Filter)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Context)//event: arg 2: block item: expected native of type event.Filter")
						}
					case env.Integer:
						if v.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Context)//event: arg 2: block item: expected integer to be 0 or nil")
						}
						arg1Val[i] = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Context)//event: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]event.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//event: arg 2: expected native of type []event.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//event: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//event: arg 2: expected block, native or nil")
			}
			res0, res1 := (*arg0Val).Event(arg1Val...)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(event.Event)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*layout.Context)//execute": {
		Doc:   "layout.Context.Execute",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//execute: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//execute: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//execute: arg 1: expected native")
			}
			var arg1Val input.Command
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_input_Command(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//execute: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(input.Command)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//execute: arg 2: expected native of type input.Command")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//execute: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//execute: arg 2: expected native")
			}
			(*arg0Val).Execute(arg1Val)
			return arg0
		},
	},
	"Go(*layout.Context)//focused": {
		Doc:   "layout.Context.Focused",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//focused: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//focused: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//focused: arg 1: expected native")
			}
			var arg1Val event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//focused: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//focused: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//focused: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//focused: arg 2: expected native")
			}
			res0 := (*arg0Val).Focused(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*layout.Context)//locale!": {
		Doc:   "Set *layout.Context Locale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//locale!: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//locale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//locale!: arg 1: expected native")
			}
			var newVal *system.Locale
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*system.Locale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//locale!: arg 2: expected native of type *system.Locale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//locale!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//locale!: arg 2: expected native")
			}
			self.Locale = *newVal
			return arg0
		},
	},
	"Go(*layout.Context)//locale?": {
		Doc:   "Get *layout.Context Locale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//locale?: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//locale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//locale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Locale, "Go(*system.Locale)")
			return resObj
		},
	},
	"Go(*layout.Context)//metric!": {
		Doc:   "Set *layout.Context Metric value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//metric!: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//metric!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//metric!: arg 1: expected native")
			}
			var newVal *unit.Metric
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//metric!: arg 2: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//metric!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//metric!: arg 2: expected native")
			}
			self.Metric = *newVal
			return arg0
		},
	},
	"Go(*layout.Context)//metric?": {
		Doc:   "Get *layout.Context Metric value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//metric?: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//metric?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//metric?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Metric, "Go(*unit.Metric)")
			return resObj
		},
	},
	"Go(*layout.Context)//now!": {
		Doc:   "Set *layout.Context Now value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//now!: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//now!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//now!: arg 1: expected native")
			}
			var newVal time.Time
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(time.Time)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//now!: arg 2: expected native of type time.Time")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//now!: arg 2: expected native")
			}
			self.Now = newVal
			return arg0
		},
	},
	"Go(*layout.Context)//now?": {
		Doc:   "Get *layout.Context Now value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//now?: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//now?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//now?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Now, "Go(time.Time)")
			return resObj
		},
	},
	"Go(*layout.Context)//ops!": {
		Doc:   "Set *layout.Context Ops value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//ops!: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//ops!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//ops!: arg 1: expected native")
			}
			var newVal *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//ops!: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//ops!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//ops!: arg 2: expected native")
			}
			self.Ops = newVal
			return arg0
		},
	},
	"Go(*layout.Context)//ops?": {
		Doc:   "Get *layout.Context Ops value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//ops?: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//ops?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//ops?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Ops, "Go(*op.Ops)")
			return resObj
		},
	},
	"Go(*layout.Context)//reset": {
		Doc:   "(*layout.Context).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//reset: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"Go(*layout.Context)//source!": {
		Doc:   "Set *layout.Context Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//source!: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//source!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//source!: arg 1: expected native")
			}
			var newVal *input.Source
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*input.Source)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//source!: arg 2: expected native of type *input.Source")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//source!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//source!: arg 2: expected native")
			}
			self.Source = *newVal
			return arg0
		},
	},
	"Go(*layout.Context)//source?": {
		Doc:   "Get *layout.Context Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//source?: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//source?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Source, "Go(*input.Source)")
			return resObj
		},
	},
	"Go(*layout.Context)//sp": {
		Doc:   "layout.Context.Sp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//sp: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//sp: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//sp: arg 1: expected native")
			}
			var arg1Val unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Context)//sp: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Context)//sp: arg 2: expected native")
			}
			res0 := (*arg0Val).Sp(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*layout.Dimensions)//baseline!": {
		Doc:   "Set *layout.Dimensions Baseline value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Dimensions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Dimensions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Dimensions)//baseline!: arg 1: expected native of type *layout.Dimensions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Dimensions)//baseline!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Dimensions)//baseline!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Dimensions)//baseline!: arg 2: expected integer")
			}
			self.Baseline = newVal
			return arg0
		},
	},
	"Go(*layout.Dimensions)//baseline?": {
		Doc:   "Get *layout.Dimensions Baseline value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Dimensions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Dimensions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Dimensions)//baseline?: arg 1: expected native of type *layout.Dimensions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Dimensions)//baseline?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Dimensions)//baseline?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Baseline))
			return resObj
		},
	},
	"Go(*layout.Dimensions)//size!": {
		Doc:   "Set *layout.Dimensions Size value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Dimensions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Dimensions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Dimensions)//size!: arg 1: expected native of type *layout.Dimensions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Dimensions)//size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Dimensions)//size!: arg 1: expected native")
			}
			var newVal image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Dimensions)//size!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Dimensions)//size!: arg 2: expected native")
			}
			self.Size = newVal
			return arg0
		},
	},
	"Go(*layout.Dimensions)//size?": {
		Doc:   "Get *layout.Dimensions Size value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Dimensions
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Dimensions)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Dimensions)//size?: arg 1: expected native of type *layout.Dimensions")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Dimensions)//size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Dimensions)//size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Size, "Go(image.Point)")
			return resObj
		},
	},
	"Go(*layout.Flex)//alignment!": {
		Doc:   "Set *layout.Flex Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Flex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Flex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//alignment!: arg 1: expected native of type *layout.Flex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//alignment!: arg 1: expected native")
			}
			var newVal layout.Alignment
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(layout.Alignment)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Flex)//alignment!: arg 2: expected integer")
					}
					newVal = layout.Alignment(u)
				}
			}
			self.Alignment = newVal
			return arg0
		},
	},
	"Go(*layout.Flex)//alignment?": {
		Doc:   "Get *layout.Flex Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Flex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Flex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//alignment?: arg 1: expected native of type *layout.Flex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Alignment)))
			return resObj
		},
	},
	"Go(*layout.Flex)//axis!": {
		Doc:   "Set *layout.Flex Axis value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Flex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Flex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//axis!: arg 1: expected native of type *layout.Flex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//axis!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//axis!: arg 1: expected native")
			}
			var newVal layout.Axis
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Flex)//axis!: arg 2: expected integer")
					}
					newVal = layout.Axis(u)
				}
			}
			self.Axis = newVal
			return arg0
		},
	},
	"Go(*layout.Flex)//axis?": {
		Doc:   "Get *layout.Flex Axis value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Flex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Flex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//axis?: arg 1: expected native of type *layout.Flex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//axis?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//axis?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Axis)))
			return resObj
		},
	},
	"Go(*layout.Flex)//layout": {
		Doc:   "layout.Flex.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Flex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Flex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//layout: arg 1: expected native of type *layout.Flex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//layout: arg 2: expected native")
			}
			var arg2Val []layout.FlexChild
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]layout.FlexChild, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg2Val[i], ok = v.Value.(layout.FlexChild)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Flex)//layout: arg 3: block item: expected native of type layout.FlexChild")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Flex)//layout: arg 3: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]layout.FlexChild)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//layout: arg 3: expected native of type []layout.FlexChild")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//layout: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//layout: arg 3: expected block, native or nil")
			}
			res0 := (*arg0Val).Layout(*arg1Val, arg2Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*layout.Flex)//spacing!": {
		Doc:   "Set *layout.Flex Spacing value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Flex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Flex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//spacing!: arg 1: expected native of type *layout.Flex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//spacing!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//spacing!: arg 1: expected native")
			}
			var newVal layout.Spacing
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Spacing
				if natOk {
					natVal, natValOk = nat.Value.(layout.Spacing)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Flex)//spacing!: arg 2: expected integer")
					}
					newVal = layout.Spacing(u)
				}
			}
			self.Spacing = newVal
			return arg0
		},
	},
	"Go(*layout.Flex)//spacing?": {
		Doc:   "Get *layout.Flex Spacing value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Flex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Flex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//spacing?: arg 1: expected native of type *layout.Flex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//spacing?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//spacing?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Spacing)))
			return resObj
		},
	},
	"Go(*layout.Flex)//weight-sum!": {
		Doc:   "Set *layout.Flex WeightSum value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Flex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Flex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//weight-sum!: arg 1: expected native of type *layout.Flex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//weight-sum!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//weight-sum!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//weight-sum!: arg 2: expected decimal")
			}
			self.WeightSum = newVal
			return arg0
		},
	},
	"Go(*layout.Flex)//weight-sum?": {
		Doc:   "Get *layout.Flex WeightSum value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Flex
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Flex)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//weight-sum?: arg 1: expected native of type *layout.Flex")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Flex)//weight-sum?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Flex)//weight-sum?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.WeightSum))
			return resObj
		},
	},
	"Go(*layout.Inset)//bottom!": {
		Doc:   "Set *layout.Inset Bottom value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Inset
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//bottom!: arg 1: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//bottom!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Inset)//bottom!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Inset)//bottom!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Bottom = newVal
			return arg0
		},
	},
	"Go(*layout.Inset)//bottom?": {
		Doc:   "Get *layout.Inset Bottom value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Inset
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//bottom?: arg 1: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//bottom?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Inset)//bottom?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Bottom)))
			return resObj
		},
	},
	"Go(*layout.Inset)//layout": {
		Doc:   "layout.Inset.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Inset
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//layout: arg 1: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Inset)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Inset)//layout: arg 2: expected native")
			}
			var arg2Val layout.Widget
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg2.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Inset)//layout: arg 3: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*layout.Inset)//layout: arg 3: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*layout.Inset)//layout: arg 3: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Inset)//layout: arg 3: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Inset)//layout: arg 3: expected function or nil")
					}
					arg2Val = layout.Widget(u)
				}
			}
			res0 := (*arg0Val).Layout(*arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*layout.Inset)//left!": {
		Doc:   "Set *layout.Inset Left value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Inset
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//left!: arg 1: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//left!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Inset)//left!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Inset)//left!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Left = newVal
			return arg0
		},
	},
	"Go(*layout.Inset)//left?": {
		Doc:   "Get *layout.Inset Left value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Inset
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//left?: arg 1: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//left?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Inset)//left?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Left)))
			return resObj
		},
	},
	"Go(*layout.Inset)//right!": {
		Doc:   "Set *layout.Inset Right value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Inset
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//right!: arg 1: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//right!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Inset)//right!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Inset)//right!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Right = newVal
			return arg0
		},
	},
	"Go(*layout.Inset)//right?": {
		Doc:   "Get *layout.Inset Right value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Inset
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//right?: arg 1: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//right?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Inset)//right?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Right)))
			return resObj
		},
	},
	"Go(*layout.Inset)//top!": {
		Doc:   "Set *layout.Inset Top value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Inset
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//top!: arg 1: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//top!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Inset)//top!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Inset)//top!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Top = newVal
			return arg0
		},
	},
	"Go(*layout.Inset)//top?": {
		Doc:   "Get *layout.Inset Top value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Inset
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//top?: arg 1: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Inset)//top?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Inset)//top?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Top)))
			return resObj
		},
	},
	"Go(*layout.List)//alignment!": {
		Doc:   "Set *layout.List Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//alignment!: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//alignment!: arg 1: expected native")
			}
			var newVal layout.Alignment
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(layout.Alignment)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.List)//alignment!: arg 2: expected integer")
					}
					newVal = layout.Alignment(u)
				}
			}
			self.Alignment = newVal
			return arg0
		},
	},
	"Go(*layout.List)//alignment?": {
		Doc:   "Get *layout.List Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//alignment?: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Alignment)))
			return resObj
		},
	},
	"Go(*layout.List)//axis!": {
		Doc:   "Set *layout.List Axis value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//axis!: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//axis!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//axis!: arg 1: expected native")
			}
			var newVal layout.Axis
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.List)//axis!: arg 2: expected integer")
					}
					newVal = layout.Axis(u)
				}
			}
			self.Axis = newVal
			return arg0
		},
	},
	"Go(*layout.List)//axis?": {
		Doc:   "Get *layout.List Axis value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//axis?: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//axis?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//axis?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Axis)))
			return resObj
		},
	},
	"Go(*layout.List)//dragging": {
		Doc:   "(*layout.List).Dragging",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//dragging: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//dragging: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//dragging: arg 1: expected native")
			}
			res0 := arg0Val.Dragging()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*layout.List)//layout": {
		Doc:   "(*layout.List).Layout",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//layout: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//layout: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//layout: arg 3: expected integer")
			}
			var arg3Val layout.ListElement
			{
				nat, natOk := arg3.(env.Native)
				var natValOk bool
				var natVal layout.ListElement
				if natOk {
					natVal, natValOk = nat.Value.(layout.ListElement)
				}
				if natValOk {
					arg3Val = natVal
				} else {
					var u func(layout.Context, int) layout.Dimensions
					switch fn := arg3.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.List)//layout: arg 4: function has invalid number of arguments (expected 2)")
						}
						u = func(farg0 layout.Context, farg1 int) layout.Dimensions {
							var farg0Val, farg1Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							farg1Val = *env.NewInteger(int64(farg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val, farg1Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*layout.List)//layout: arg 4: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*layout.List)//layout: arg 4: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.List)//layout: arg 4: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*layout.List)//layout: arg 4: expected function or nil")
					}
					arg3Val = layout.ListElement(u)
				}
			}
			res0 := arg0Val.Layout(*arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*layout.List)//position!": {
		Doc:   "Set *layout.List Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//position!: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//position!: arg 1: expected native")
			}
			var newVal *layout.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//position!: arg 2: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//position!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//position!: arg 2: expected native")
			}
			self.Position = *newVal
			return arg0
		},
	},
	"Go(*layout.List)//position?": {
		Doc:   "Get *layout.List Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//position?: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Position, "Go(*layout.Position)")
			return resObj
		},
	},
	"Go(*layout.List)//scroll-by": {
		Doc:   "(*layout.List).ScrollBy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//scroll-by: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//scroll-by: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//scroll-by: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//scroll-by: arg 2: expected decimal")
			}
			arg0Val.ScrollBy(arg1Val)
			return arg0
		},
	},
	"Go(*layout.List)//scroll-to": {
		Doc:   "(*layout.List).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//scroll-to: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//scroll-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//scroll-to: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//scroll-to: arg 2: expected integer")
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"Go(*layout.List)//scroll-to-end!": {
		Doc:   "Set *layout.List ScrollToEnd value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//scroll-to-end!: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//scroll-to-end!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//scroll-to-end!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//scroll-to-end!: arg 2: expected integer")
			}
			self.ScrollToEnd = newVal
			return arg0
		},
	},
	"Go(*layout.List)//scroll-to-end?": {
		Doc:   "Get *layout.List ScrollToEnd value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//scroll-to-end?: arg 1: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.List)//scroll-to-end?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.List)//scroll-to-end?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ScrollToEnd))
			return resObj
		},
	},
	"Go(*layout.Position)//before-end!": {
		Doc:   "Set *layout.Position BeforeEnd value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//before-end!: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//before-end!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//before-end!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//before-end!: arg 2: expected integer")
			}
			self.BeforeEnd = newVal
			return arg0
		},
	},
	"Go(*layout.Position)//before-end?": {
		Doc:   "Get *layout.Position BeforeEnd value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//before-end?: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//before-end?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//before-end?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.BeforeEnd))
			return resObj
		},
	},
	"Go(*layout.Position)//count!": {
		Doc:   "Set *layout.Position Count value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//count!: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//count!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//count!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//count!: arg 2: expected integer")
			}
			self.Count = newVal
			return arg0
		},
	},
	"Go(*layout.Position)//count?": {
		Doc:   "Get *layout.Position Count value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//count?: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//count?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//count?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Count))
			return resObj
		},
	},
	"Go(*layout.Position)//first!": {
		Doc:   "Set *layout.Position First value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//first!: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//first!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//first!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//first!: arg 2: expected integer")
			}
			self.First = newVal
			return arg0
		},
	},
	"Go(*layout.Position)//first?": {
		Doc:   "Get *layout.Position First value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//first?: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//first?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//first?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.First))
			return resObj
		},
	},
	"Go(*layout.Position)//length!": {
		Doc:   "Set *layout.Position Length value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//length!: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//length!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//length!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//length!: arg 2: expected integer")
			}
			self.Length = newVal
			return arg0
		},
	},
	"Go(*layout.Position)//length?": {
		Doc:   "Get *layout.Position Length value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//length?: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//length?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//length?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Length))
			return resObj
		},
	},
	"Go(*layout.Position)//offset!": {
		Doc:   "Set *layout.Position Offset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//offset!: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//offset!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//offset!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//offset!: arg 2: expected integer")
			}
			self.Offset = newVal
			return arg0
		},
	},
	"Go(*layout.Position)//offset-last!": {
		Doc:   "Set *layout.Position OffsetLast value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//offset-last!: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//offset-last!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//offset-last!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//offset-last!: arg 2: expected integer")
			}
			self.OffsetLast = newVal
			return arg0
		},
	},
	"Go(*layout.Position)//offset-last?": {
		Doc:   "Get *layout.Position OffsetLast value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//offset-last?: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//offset-last?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//offset-last?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.OffsetLast))
			return resObj
		},
	},
	"Go(*layout.Position)//offset?": {
		Doc:   "Get *layout.Position Offset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Position
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//offset?: arg 1: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Position)//offset?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Position)//offset?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Offset))
			return resObj
		},
	},
	"Go(*layout.Spacer)//height!": {
		Doc:   "Set *layout.Spacer Height value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//height!: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//height!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Spacer)//height!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Spacer)//height!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Height = newVal
			return arg0
		},
	},
	"Go(*layout.Spacer)//height?": {
		Doc:   "Get *layout.Spacer Height value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//height?: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//height?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Spacer)//height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Height)))
			return resObj
		},
	},
	"Go(*layout.Spacer)//layout": {
		Doc:   "layout.Spacer.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//layout: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Spacer)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Spacer)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*layout.Spacer)//width!": {
		Doc:   "Set *layout.Spacer Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//width!: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Spacer)//width!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Spacer)//width!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Width = newVal
			return arg0
		},
	},
	"Go(*layout.Spacer)//width?": {
		Doc:   "Get *layout.Spacer Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Spacer
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Spacer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//width?: arg 1: expected native of type *layout.Spacer")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Spacer)//width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Spacer)//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Width)))
			return resObj
		},
	},
	"Go(*layout.Stack)//alignment!": {
		Doc:   "Set *layout.Stack Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Stack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Stack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Stack)//alignment!: arg 1: expected native of type *layout.Stack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Stack)//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Stack)//alignment!: arg 1: expected native")
			}
			var newVal layout.Direction
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Direction
				if natOk {
					natVal, natValOk = nat.Value.(layout.Direction)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Stack)//alignment!: arg 2: expected integer")
					}
					newVal = layout.Direction(u)
				}
			}
			self.Alignment = newVal
			return arg0
		},
	},
	"Go(*layout.Stack)//alignment?": {
		Doc:   "Get *layout.Stack Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *layout.Stack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*layout.Stack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Stack)//alignment?: arg 1: expected native of type *layout.Stack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Stack)//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Stack)//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Alignment)))
			return resObj
		},
	},
	"Go(*layout.Stack)//layout": {
		Doc:   "layout.Stack.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Stack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Stack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Stack)//layout: arg 1: expected native of type *layout.Stack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Stack)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Stack)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Stack)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Stack)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Stack)//layout: arg 2: expected native")
			}
			var arg2Val []layout.StackChild
			switch v := arg2.(type) {
			case env.Block:
				arg2Val = make([]layout.StackChild, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg2Val[i], ok = v.Value.(layout.StackChild)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*layout.Stack)//layout: arg 3: block item: expected native of type layout.StackChild")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*layout.Stack)//layout: arg 3: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.([]layout.StackChild)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Stack)//layout: arg 3: expected native of type []layout.StackChild")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*layout.Stack)//layout: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*layout.Stack)//layout: arg 3: expected block, native or nil")
			}
			res0 := (*arg0Val).Layout(*arg1Val, arg2Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.ButtonLayoutStyle)//background!": {
		Doc:   "Set *material.ButtonLayoutStyle Background value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonLayoutStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonLayoutStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//background!: arg 1: expected native of type *material.ButtonLayoutStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//background!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonLayoutStyle)//background!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//background!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonLayoutStyle)//background!: arg 2: expected native")
			}
			self.Background = newVal
			return arg0
		},
	},
	"Go(*material.ButtonLayoutStyle)//background?": {
		Doc:   "Get *material.ButtonLayoutStyle Background value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonLayoutStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonLayoutStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//background?: arg 1: expected native of type *material.ButtonLayoutStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//background?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonLayoutStyle)//background?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Background, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.ButtonLayoutStyle)//button!": {
		Doc:   "Set *material.ButtonLayoutStyle Button value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonLayoutStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonLayoutStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//button!: arg 1: expected native of type *material.ButtonLayoutStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//button!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonLayoutStyle)//button!: arg 1: expected native")
			}
			var newVal *widget.Clickable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//button!: arg 2: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//button!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonLayoutStyle)//button!: arg 2: expected native")
			}
			self.Button = newVal
			return arg0
		},
	},
	"Go(*material.ButtonLayoutStyle)//button?": {
		Doc:   "Get *material.ButtonLayoutStyle Button value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonLayoutStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonLayoutStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//button?: arg 1: expected native of type *material.ButtonLayoutStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//button?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonLayoutStyle)//button?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Button, "Go(*widget.Clickable)")
			return resObj
		},
	},
	"Go(*material.ButtonLayoutStyle)//corner-radius!": {
		Doc:   "Set *material.ButtonLayoutStyle CornerRadius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonLayoutStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonLayoutStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//corner-radius!: arg 1: expected native of type *material.ButtonLayoutStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//corner-radius!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonLayoutStyle)//corner-radius!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ButtonLayoutStyle)//corner-radius!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.CornerRadius = newVal
			return arg0
		},
	},
	"Go(*material.ButtonLayoutStyle)//corner-radius?": {
		Doc:   "Get *material.ButtonLayoutStyle CornerRadius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonLayoutStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonLayoutStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//corner-radius?: arg 1: expected native of type *material.ButtonLayoutStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//corner-radius?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonLayoutStyle)//corner-radius?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.CornerRadius)))
			return resObj
		},
	},
	"Go(*material.ButtonLayoutStyle)//layout": {
		Doc:   "material.ButtonLayoutStyle.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.ButtonLayoutStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.ButtonLayoutStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//layout: arg 1: expected native of type *material.ButtonLayoutStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonLayoutStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonLayoutStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonLayoutStyle)//layout: arg 2: expected native")
			}
			var arg2Val layout.Widget
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg2.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*material.ButtonLayoutStyle)//layout: arg 3: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*material.ButtonLayoutStyle)//layout: arg 3: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*material.ButtonLayoutStyle)//layout: arg 3: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*material.ButtonLayoutStyle)//layout: arg 3: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*material.ButtonLayoutStyle)//layout: arg 3: expected function or nil")
					}
					arg2Val = layout.Widget(u)
				}
			}
			res0 := (*arg0Val).Layout(*arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.ButtonStyle)//background!": {
		Doc:   "Set *material.ButtonStyle Background value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//background!: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//background!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//background!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//background!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//background!: arg 2: expected native")
			}
			self.Background = newVal
			return arg0
		},
	},
	"Go(*material.ButtonStyle)//background?": {
		Doc:   "Get *material.ButtonStyle Background value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//background?: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//background?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//background?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Background, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.ButtonStyle)//button!": {
		Doc:   "Set *material.ButtonStyle Button value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//button!: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//button!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//button!: arg 1: expected native")
			}
			var newVal *widget.Clickable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//button!: arg 2: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//button!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//button!: arg 2: expected native")
			}
			self.Button = newVal
			return arg0
		},
	},
	"Go(*material.ButtonStyle)//button?": {
		Doc:   "Get *material.ButtonStyle Button value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//button?: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//button?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//button?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Button, "Go(*widget.Clickable)")
			return resObj
		},
	},
	"Go(*material.ButtonStyle)//color!": {
		Doc:   "Set *material.ButtonStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//color!: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.ButtonStyle)//color?": {
		Doc:   "Get *material.ButtonStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//color?: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.ButtonStyle)//corner-radius!": {
		Doc:   "Set *material.ButtonStyle CornerRadius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//corner-radius!: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//corner-radius!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//corner-radius!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ButtonStyle)//corner-radius!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.CornerRadius = newVal
			return arg0
		},
	},
	"Go(*material.ButtonStyle)//corner-radius?": {
		Doc:   "Get *material.ButtonStyle CornerRadius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//corner-radius?: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//corner-radius?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//corner-radius?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.CornerRadius)))
			return resObj
		},
	},
	"Go(*material.ButtonStyle)//font!": {
		Doc:   "Set *material.ButtonStyle Font value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//font!: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//font!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//font!: arg 1: expected native")
			}
			var newVal *font.Font
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//font!: arg 2: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//font!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//font!: arg 2: expected native")
			}
			self.Font = *newVal
			return arg0
		},
	},
	"Go(*material.ButtonStyle)//font?": {
		Doc:   "Get *material.ButtonStyle Font value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//font?: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//font?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//font?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Font, "Go(*font.Font)")
			return resObj
		},
	},
	"Go(*material.ButtonStyle)//inset!": {
		Doc:   "Set *material.ButtonStyle Inset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//inset!: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//inset!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//inset!: arg 1: expected native")
			}
			var newVal *layout.Inset
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//inset!: arg 2: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//inset!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//inset!: arg 2: expected native")
			}
			self.Inset = *newVal
			return arg0
		},
	},
	"Go(*material.ButtonStyle)//inset?": {
		Doc:   "Get *material.ButtonStyle Inset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//inset?: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//inset?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//inset?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Inset, "Go(*layout.Inset)")
			return resObj
		},
	},
	"Go(*material.ButtonStyle)//layout": {
		Doc:   "material.ButtonStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//layout: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.ButtonStyle)//text!": {
		Doc:   "Set *material.ButtonStyle Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//text!: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//text!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//text!: arg 2: expected string")
			}
			self.Text = newVal
			return arg0
		},
	},
	"Go(*material.ButtonStyle)//text-size!": {
		Doc:   "Set *material.ButtonStyle TextSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//text-size!: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//text-size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//text-size!: arg 1: expected native")
			}
			var newVal unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//text-size!: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//text-size!: arg 2: expected native")
			}
			self.TextSize = newVal
			return arg0
		},
	},
	"Go(*material.ButtonStyle)//text-size?": {
		Doc:   "Get *material.ButtonStyle TextSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//text-size?: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//text-size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//text-size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextSize, "Go(unit.Sp)")
			return resObj
		},
	},
	"Go(*material.ButtonStyle)//text?": {
		Doc:   "Get *material.ButtonStyle Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//text?: arg 1: expected native of type *material.ButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ButtonStyle)//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ButtonStyle)//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"Go(*material.CheckBoxStyle)//check-box!": {
		Doc:   "Set *material.CheckBoxStyle CheckBox value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.CheckBoxStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.CheckBoxStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.CheckBoxStyle)//check-box!: arg 1: expected native of type *material.CheckBoxStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.CheckBoxStyle)//check-box!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.CheckBoxStyle)//check-box!: arg 1: expected native")
			}
			var newVal *widget.Bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.CheckBoxStyle)//check-box!: arg 2: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.CheckBoxStyle)//check-box!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.CheckBoxStyle)//check-box!: arg 2: expected native")
			}
			self.CheckBox = newVal
			return arg0
		},
	},
	"Go(*material.CheckBoxStyle)//check-box?": {
		Doc:   "Get *material.CheckBoxStyle CheckBox value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.CheckBoxStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.CheckBoxStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.CheckBoxStyle)//check-box?: arg 1: expected native of type *material.CheckBoxStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.CheckBoxStyle)//check-box?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.CheckBoxStyle)//check-box?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.CheckBox, "Go(*widget.Bool)")
			return resObj
		},
	},
	"Go(*material.CheckBoxStyle)//layout": {
		Doc:   "material.CheckBoxStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.CheckBoxStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.CheckBoxStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.CheckBoxStyle)//layout: arg 1: expected native of type *material.CheckBoxStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.CheckBoxStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.CheckBoxStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.CheckBoxStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.CheckBoxStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.CheckBoxStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.DecorationsStyle)//actions!": {
		Doc:   "Set *material.DecorationsStyle Actions value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//actions!: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//actions!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//actions!: arg 1: expected native")
			}
			var newVal system.Action
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal system.Action
				if natOk {
					natVal, natValOk = nat.Value.(system.Action)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint
					if v, ok := arg1.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.DecorationsStyle)//actions!: arg 2: expected integer")
					}
					newVal = system.Action(u)
				}
			}
			self.Actions = newVal
			return arg0
		},
	},
	"Go(*material.DecorationsStyle)//actions?": {
		Doc:   "Get *material.DecorationsStyle Actions value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//actions?: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//actions?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//actions?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(self.Actions)))
			return resObj
		},
	},
	"Go(*material.DecorationsStyle)//background!": {
		Doc:   "Set *material.DecorationsStyle Background value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//background!: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//background!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//background!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//background!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//background!: arg 2: expected native")
			}
			self.Background = newVal
			return arg0
		},
	},
	"Go(*material.DecorationsStyle)//background?": {
		Doc:   "Get *material.DecorationsStyle Background value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//background?: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//background?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//background?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Background, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.DecorationsStyle)//decorations!": {
		Doc:   "Set *material.DecorationsStyle Decorations value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//decorations!: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//decorations!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//decorations!: arg 1: expected native")
			}
			var newVal *widget.Decorations
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Decorations)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//decorations!: arg 2: expected native of type *widget.Decorations")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//decorations!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//decorations!: arg 2: expected native")
			}
			self.Decorations = newVal
			return arg0
		},
	},
	"Go(*material.DecorationsStyle)//decorations?": {
		Doc:   "Get *material.DecorationsStyle Decorations value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//decorations?: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//decorations?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//decorations?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Decorations, "Go(*widget.Decorations)")
			return resObj
		},
	},
	"Go(*material.DecorationsStyle)//foreground!": {
		Doc:   "Set *material.DecorationsStyle Foreground value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//foreground!: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//foreground!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//foreground!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//foreground!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//foreground!: arg 2: expected native")
			}
			self.Foreground = newVal
			return arg0
		},
	},
	"Go(*material.DecorationsStyle)//foreground?": {
		Doc:   "Get *material.DecorationsStyle Foreground value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//foreground?: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//foreground?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//foreground?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Foreground, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.DecorationsStyle)//layout": {
		Doc:   "material.DecorationsStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//layout: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.DecorationsStyle)//title!": {
		Doc:   "Set *material.DecorationsStyle Title value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//title!: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//title!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//title!: arg 1: expected native")
			}
			var newVal *material.LabelStyle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//title!: arg 2: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//title!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//title!: arg 2: expected native")
			}
			self.Title = *newVal
			return arg0
		},
	},
	"Go(*material.DecorationsStyle)//title?": {
		Doc:   "Get *material.DecorationsStyle Title value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.DecorationsStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.DecorationsStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//title?: arg 1: expected native of type *material.DecorationsStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.DecorationsStyle)//title?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.DecorationsStyle)//title?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Title, "Go(*material.LabelStyle)")
			return resObj
		},
	},
	"Go(*material.EditorStyle)//color!": {
		Doc:   "Set *material.EditorStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//color!: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.EditorStyle)//color?": {
		Doc:   "Get *material.EditorStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//color?: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.EditorStyle)//editor!": {
		Doc:   "Set *material.EditorStyle Editor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//editor!: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//editor!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//editor!: arg 1: expected native")
			}
			var newVal *widget.Editor
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//editor!: arg 2: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//editor!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//editor!: arg 2: expected native")
			}
			self.Editor = newVal
			return arg0
		},
	},
	"Go(*material.EditorStyle)//editor?": {
		Doc:   "Get *material.EditorStyle Editor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//editor?: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//editor?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//editor?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Editor, "Go(*widget.Editor)")
			return resObj
		},
	},
	"Go(*material.EditorStyle)//font!": {
		Doc:   "Set *material.EditorStyle Font value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//font!: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//font!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//font!: arg 1: expected native")
			}
			var newVal *font.Font
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//font!: arg 2: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//font!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//font!: arg 2: expected native")
			}
			self.Font = *newVal
			return arg0
		},
	},
	"Go(*material.EditorStyle)//font?": {
		Doc:   "Get *material.EditorStyle Font value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//font?: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//font?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//font?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Font, "Go(*font.Font)")
			return resObj
		},
	},
	"Go(*material.EditorStyle)//hint!": {
		Doc:   "Set *material.EditorStyle Hint value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//hint!: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//hint!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//hint!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//hint!: arg 2: expected string")
			}
			self.Hint = newVal
			return arg0
		},
	},
	"Go(*material.EditorStyle)//hint-color!": {
		Doc:   "Set *material.EditorStyle HintColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//hint-color!: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//hint-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//hint-color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//hint-color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//hint-color!: arg 2: expected native")
			}
			self.HintColor = newVal
			return arg0
		},
	},
	"Go(*material.EditorStyle)//hint-color?": {
		Doc:   "Get *material.EditorStyle HintColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//hint-color?: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//hint-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//hint-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.HintColor, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.EditorStyle)//hint?": {
		Doc:   "Get *material.EditorStyle Hint value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//hint?: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//hint?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//hint?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Hint)
			return resObj
		},
	},
	"Go(*material.EditorStyle)//layout": {
		Doc:   "material.EditorStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//layout: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.EditorStyle)//line-height!": {
		Doc:   "Set *material.EditorStyle LineHeight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//line-height!: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//line-height!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//line-height!: arg 1: expected native")
			}
			var newVal unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//line-height!: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//line-height!: arg 2: expected native")
			}
			self.LineHeight = newVal
			return arg0
		},
	},
	"Go(*material.EditorStyle)//line-height-scale!": {
		Doc:   "Set *material.EditorStyle LineHeightScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//line-height-scale!: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//line-height-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//line-height-scale!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//line-height-scale!: arg 2: expected decimal")
			}
			self.LineHeightScale = newVal
			return arg0
		},
	},
	"Go(*material.EditorStyle)//line-height-scale?": {
		Doc:   "Get *material.EditorStyle LineHeightScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//line-height-scale?: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//line-height-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//line-height-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineHeightScale))
			return resObj
		},
	},
	"Go(*material.EditorStyle)//line-height?": {
		Doc:   "Get *material.EditorStyle LineHeight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//line-height?: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//line-height?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//line-height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.LineHeight, "Go(unit.Sp)")
			return resObj
		},
	},
	"Go(*material.EditorStyle)//selection-color!": {
		Doc:   "Set *material.EditorStyle SelectionColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//selection-color!: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//selection-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//selection-color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//selection-color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//selection-color!: arg 2: expected native")
			}
			self.SelectionColor = newVal
			return arg0
		},
	},
	"Go(*material.EditorStyle)//selection-color?": {
		Doc:   "Get *material.EditorStyle SelectionColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//selection-color?: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//selection-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//selection-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SelectionColor, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.EditorStyle)//text-size!": {
		Doc:   "Set *material.EditorStyle TextSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//text-size!: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//text-size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//text-size!: arg 1: expected native")
			}
			var newVal unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//text-size!: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//text-size!: arg 2: expected native")
			}
			self.TextSize = newVal
			return arg0
		},
	},
	"Go(*material.EditorStyle)//text-size?": {
		Doc:   "Get *material.EditorStyle TextSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.EditorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.EditorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//text-size?: arg 1: expected native of type *material.EditorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.EditorStyle)//text-size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.EditorStyle)//text-size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextSize, "Go(unit.Sp)")
			return resObj
		},
	},
	"Go(*material.IconButtonStyle)//background!": {
		Doc:   "Set *material.IconButtonStyle Background value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//background!: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//background!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//background!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//background!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//background!: arg 2: expected native")
			}
			self.Background = newVal
			return arg0
		},
	},
	"Go(*material.IconButtonStyle)//background?": {
		Doc:   "Get *material.IconButtonStyle Background value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//background?: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//background?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//background?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Background, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.IconButtonStyle)//button!": {
		Doc:   "Set *material.IconButtonStyle Button value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//button!: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//button!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//button!: arg 1: expected native")
			}
			var newVal *widget.Clickable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//button!: arg 2: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//button!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//button!: arg 2: expected native")
			}
			self.Button = newVal
			return arg0
		},
	},
	"Go(*material.IconButtonStyle)//button?": {
		Doc:   "Get *material.IconButtonStyle Button value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//button?: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//button?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//button?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Button, "Go(*widget.Clickable)")
			return resObj
		},
	},
	"Go(*material.IconButtonStyle)//color!": {
		Doc:   "Set *material.IconButtonStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//color!: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.IconButtonStyle)//color?": {
		Doc:   "Get *material.IconButtonStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//color?: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.IconButtonStyle)//description!": {
		Doc:   "Set *material.IconButtonStyle Description value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//description!: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//description!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//description!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//description!: arg 2: expected string")
			}
			self.Description = newVal
			return arg0
		},
	},
	"Go(*material.IconButtonStyle)//description?": {
		Doc:   "Get *material.IconButtonStyle Description value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//description?: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//description?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//description?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Description)
			return resObj
		},
	},
	"Go(*material.IconButtonStyle)//icon!": {
		Doc:   "Set *material.IconButtonStyle Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//icon!: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//icon!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//icon!: arg 1: expected native")
			}
			var newVal *widget.Icon
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//icon!: arg 2: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//icon!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//icon!: arg 2: expected native")
			}
			self.Icon = newVal
			return arg0
		},
	},
	"Go(*material.IconButtonStyle)//icon?": {
		Doc:   "Get *material.IconButtonStyle Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//icon?: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//icon?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//icon?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "Go(*widget.Icon)")
			return resObj
		},
	},
	"Go(*material.IconButtonStyle)//inset!": {
		Doc:   "Set *material.IconButtonStyle Inset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//inset!: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//inset!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//inset!: arg 1: expected native")
			}
			var newVal *layout.Inset
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*layout.Inset)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//inset!: arg 2: expected native of type *layout.Inset")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//inset!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//inset!: arg 2: expected native")
			}
			self.Inset = *newVal
			return arg0
		},
	},
	"Go(*material.IconButtonStyle)//inset?": {
		Doc:   "Get *material.IconButtonStyle Inset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//inset?: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//inset?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//inset?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Inset, "Go(*layout.Inset)")
			return resObj
		},
	},
	"Go(*material.IconButtonStyle)//layout": {
		Doc:   "material.IconButtonStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//layout: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.IconButtonStyle)//size!": {
		Doc:   "Set *material.IconButtonStyle Size value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//size!: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//size!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.IconButtonStyle)//size!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Size = newVal
			return arg0
		},
	},
	"Go(*material.IconButtonStyle)//size?": {
		Doc:   "Get *material.IconButtonStyle Size value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.IconButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.IconButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//size?: arg 1: expected native of type *material.IconButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.IconButtonStyle)//size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.IconButtonStyle)//size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Size)))
			return resObj
		},
	},
	"Go(*material.LabelStyle)//alignment!": {
		Doc:   "Set *material.LabelStyle Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//alignment!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//alignment!: arg 1: expected native")
			}
			var newVal text.Alignment
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(text.Alignment)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.LabelStyle)//alignment!: arg 2: expected integer")
					}
					newVal = text.Alignment(u)
				}
			}
			self.Alignment = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//alignment?": {
		Doc:   "Get *material.LabelStyle Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//alignment?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Alignment)))
			return resObj
		},
	},
	"Go(*material.LabelStyle)//color!": {
		Doc:   "Set *material.LabelStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//color!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//color?": {
		Doc:   "Get *material.LabelStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//color?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.LabelStyle)//font!": {
		Doc:   "Set *material.LabelStyle Font value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//font!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//font!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//font!: arg 1: expected native")
			}
			var newVal *font.Font
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//font!: arg 2: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//font!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//font!: arg 2: expected native")
			}
			self.Font = *newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//font?": {
		Doc:   "Get *material.LabelStyle Font value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//font?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//font?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//font?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Font, "Go(*font.Font)")
			return resObj
		},
	},
	"Go(*material.LabelStyle)//layout": {
		Doc:   "material.LabelStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//layout: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.LabelStyle)//line-height!": {
		Doc:   "Set *material.LabelStyle LineHeight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//line-height!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//line-height!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//line-height!: arg 1: expected native")
			}
			var newVal unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//line-height!: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//line-height!: arg 2: expected native")
			}
			self.LineHeight = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//line-height-scale!": {
		Doc:   "Set *material.LabelStyle LineHeightScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//line-height-scale!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//line-height-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//line-height-scale!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//line-height-scale!: arg 2: expected decimal")
			}
			self.LineHeightScale = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//line-height-scale?": {
		Doc:   "Get *material.LabelStyle LineHeightScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//line-height-scale?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//line-height-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//line-height-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineHeightScale))
			return resObj
		},
	},
	"Go(*material.LabelStyle)//line-height?": {
		Doc:   "Get *material.LabelStyle LineHeight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//line-height?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//line-height?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//line-height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.LineHeight, "Go(unit.Sp)")
			return resObj
		},
	},
	"Go(*material.LabelStyle)//max-lines!": {
		Doc:   "Set *material.LabelStyle MaxLines value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//max-lines!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//max-lines!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//max-lines!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//max-lines!: arg 2: expected integer")
			}
			self.MaxLines = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//max-lines?": {
		Doc:   "Get *material.LabelStyle MaxLines value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//max-lines?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//max-lines?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//max-lines?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.MaxLines))
			return resObj
		},
	},
	"Go(*material.LabelStyle)//selection-color!": {
		Doc:   "Set *material.LabelStyle SelectionColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//selection-color!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//selection-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//selection-color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//selection-color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//selection-color!: arg 2: expected native")
			}
			self.SelectionColor = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//selection-color?": {
		Doc:   "Get *material.LabelStyle SelectionColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//selection-color?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//selection-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//selection-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.SelectionColor, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.LabelStyle)//shaper!": {
		Doc:   "Set *material.LabelStyle Shaper value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//shaper!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//shaper!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//shaper!: arg 1: expected native")
			}
			var newVal *text.Shaper
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*text.Shaper)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//shaper!: arg 2: expected native of type *text.Shaper")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//shaper!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//shaper!: arg 2: expected native")
			}
			self.Shaper = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//shaper?": {
		Doc:   "Get *material.LabelStyle Shaper value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//shaper?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//shaper?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//shaper?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Shaper, "Go(*text.Shaper)")
			return resObj
		},
	},
	"Go(*material.LabelStyle)//state!": {
		Doc:   "Set *material.LabelStyle State value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//state!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//state!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//state!: arg 1: expected native")
			}
			var newVal *widget.Selectable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//state!: arg 2: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//state!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//state!: arg 2: expected native")
			}
			self.State = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//state?": {
		Doc:   "Get *material.LabelStyle State value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//state?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//state?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//state?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.State, "Go(*widget.Selectable)")
			return resObj
		},
	},
	"Go(*material.LabelStyle)//text!": {
		Doc:   "Set *material.LabelStyle Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//text!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//text!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//text!: arg 2: expected string")
			}
			self.Text = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//text-size!": {
		Doc:   "Set *material.LabelStyle TextSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//text-size!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//text-size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//text-size!: arg 1: expected native")
			}
			var newVal unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//text-size!: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//text-size!: arg 2: expected native")
			}
			self.TextSize = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//text-size?": {
		Doc:   "Get *material.LabelStyle TextSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//text-size?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//text-size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//text-size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextSize, "Go(unit.Sp)")
			return resObj
		},
	},
	"Go(*material.LabelStyle)//text?": {
		Doc:   "Get *material.LabelStyle Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//text?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"Go(*material.LabelStyle)//truncator!": {
		Doc:   "Set *material.LabelStyle Truncator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//truncator!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//truncator!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//truncator!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//truncator!: arg 2: expected string")
			}
			self.Truncator = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//truncator?": {
		Doc:   "Get *material.LabelStyle Truncator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//truncator?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//truncator?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//truncator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Truncator)
			return resObj
		},
	},
	"Go(*material.LabelStyle)//wrap-policy!": {
		Doc:   "Set *material.LabelStyle WrapPolicy value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//wrap-policy!: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//wrap-policy!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//wrap-policy!: arg 1: expected native")
			}
			var newVal text.WrapPolicy
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.WrapPolicy
				if natOk {
					natVal, natValOk = nat.Value.(text.WrapPolicy)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.LabelStyle)//wrap-policy!: arg 2: expected integer")
					}
					newVal = text.WrapPolicy(u)
				}
			}
			self.WrapPolicy = newVal
			return arg0
		},
	},
	"Go(*material.LabelStyle)//wrap-policy?": {
		Doc:   "Get *material.LabelStyle WrapPolicy value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LabelStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LabelStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//wrap-policy?: arg 1: expected native of type *material.LabelStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LabelStyle)//wrap-policy?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LabelStyle)//wrap-policy?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.WrapPolicy)))
			return resObj
		},
	},
	"Go(*material.ListStyle)//anchor-strategy!": {
		Doc:   "Set *material.ListStyle AnchorStrategy value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//anchor-strategy!: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//anchor-strategy!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//anchor-strategy!: arg 1: expected native")
			}
			var newVal material.AnchorStrategy
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal material.AnchorStrategy
				if natOk {
					natVal, natValOk = nat.Value.(material.AnchorStrategy)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ListStyle)//anchor-strategy!: arg 2: expected integer")
					}
					newVal = material.AnchorStrategy(u)
				}
			}
			self.AnchorStrategy = newVal
			return arg0
		},
	},
	"Go(*material.ListStyle)//anchor-strategy!-1": {
		Doc:   "Set *material.ListStyle AnchorStrategy value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//anchor-strategy!-1: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//anchor-strategy!-1: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//anchor-strategy!-1: arg 1: expected native")
			}
			var newVal material.AnchorStrategy
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal material.AnchorStrategy
				if natOk {
					natVal, natValOk = nat.Value.(material.AnchorStrategy)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ListStyle)//anchor-strategy!-1: arg 2: expected integer")
					}
					newVal = material.AnchorStrategy(u)
				}
			}
			self.AnchorStrategy = newVal
			return arg0
		},
	},
	"Go(*material.ListStyle)//anchor-strategy?": {
		Doc:   "Get *material.ListStyle AnchorStrategy value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//anchor-strategy?: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//anchor-strategy?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//anchor-strategy?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.AnchorStrategy)))
			return resObj
		},
	},
	"Go(*material.ListStyle)//anchor-strategy?-1": {
		Doc:   "Get *material.ListStyle AnchorStrategy value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//anchor-strategy?-1: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//anchor-strategy?-1: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//anchor-strategy?-1: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.AnchorStrategy)))
			return resObj
		},
	},
	"Go(*material.ListStyle)//indicator!": {
		Doc:   "Set *material.ListStyle Indicator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//indicator!: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//indicator!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//indicator!: arg 1: expected native")
			}
			var newVal *material.ScrollIndicatorStyle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//indicator!: arg 2: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//indicator!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//indicator!: arg 2: expected native")
			}
			self.Indicator = *newVal
			return arg0
		},
	},
	"Go(*material.ListStyle)//indicator?": {
		Doc:   "Get *material.ListStyle Indicator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//indicator?: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//indicator?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//indicator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Indicator, "Go(*material.ScrollIndicatorStyle)")
			return resObj
		},
	},
	"Go(*material.ListStyle)//layout": {
		Doc:   "material.ListStyle.Layout",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//layout: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//layout: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//layout: arg 3: expected integer")
			}
			var arg3Val layout.ListElement
			{
				nat, natOk := arg3.(env.Native)
				var natValOk bool
				var natVal layout.ListElement
				if natOk {
					natVal, natValOk = nat.Value.(layout.ListElement)
				}
				if natValOk {
					arg3Val = natVal
				} else {
					var u func(layout.Context, int) layout.Dimensions
					switch fn := arg3.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
							return env.NewError("Go(*material.ListStyle)//layout: arg 4: function has invalid number of arguments (expected 2)")
						}
						u = func(farg0 layout.Context, farg1 int) layout.Dimensions {
							var farg0Val, farg1Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							farg1Val = *env.NewInteger(int64(farg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val, farg1Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*material.ListStyle)//layout: arg 4: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*material.ListStyle)//layout: arg 4: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*material.ListStyle)//layout: arg 4: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*material.ListStyle)//layout: arg 4: expected function or nil")
					}
					arg3Val = layout.ListElement(u)
				}
			}
			res0 := (*arg0Val).Layout(*arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.ListStyle)//scrollbar!": {
		Doc:   "Set *material.ListStyle Scrollbar value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar!: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//scrollbar!: arg 1: expected native")
			}
			var newVal *widget.Scrollbar
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar!: arg 2: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//scrollbar!: arg 2: expected native")
			}
			self.Scrollbar = newVal
			return arg0
		},
	},
	"Go(*material.ListStyle)//scrollbar-style!": {
		Doc:   "Set *material.ListStyle ScrollbarStyle value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar-style!: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar-style!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//scrollbar-style!: arg 1: expected native")
			}
			var newVal *material.ScrollbarStyle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*material.ScrollbarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar-style!: arg 2: expected native of type *material.ScrollbarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar-style!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//scrollbar-style!: arg 2: expected native")
			}
			self.ScrollbarStyle = *newVal
			return arg0
		},
	},
	"Go(*material.ListStyle)//scrollbar-style?": {
		Doc:   "Get *material.ListStyle ScrollbarStyle value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar-style?: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar-style?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//scrollbar-style?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.ScrollbarStyle, "Go(*material.ScrollbarStyle)")
			return resObj
		},
	},
	"Go(*material.ListStyle)//scrollbar?": {
		Doc:   "Get *material.ListStyle Scrollbar value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar?: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//scrollbar?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//scrollbar?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scrollbar, "Go(*widget.Scrollbar)")
			return resObj
		},
	},
	"Go(*material.ListStyle)//track!": {
		Doc:   "Set *material.ListStyle Track value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//track!: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//track!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//track!: arg 1: expected native")
			}
			var newVal *material.ScrollTrackStyle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*material.ScrollTrackStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//track!: arg 2: expected native of type *material.ScrollTrackStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//track!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//track!: arg 2: expected native")
			}
			self.Track = *newVal
			return arg0
		},
	},
	"Go(*material.ListStyle)//track?": {
		Doc:   "Get *material.ListStyle Track value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//track?: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//track?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//track?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Track, "Go(*material.ScrollTrackStyle)")
			return resObj
		},
	},
	"Go(*material.ListStyle)//width": {
		Doc:   "material.ListStyle.Width",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.ListStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.ListStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//width: arg 1: expected native of type *material.ListStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ListStyle)//width: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ListStyle)//width: arg 1: expected native")
			}
			res0 := (*arg0Val).Width()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(float32(res0)))
			return res0Obj
		},
	},
	"Go(*material.LoaderStyle)//color!": {
		Doc:   "Set *material.LoaderStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LoaderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LoaderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LoaderStyle)//color!: arg 1: expected native of type *material.LoaderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LoaderStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LoaderStyle)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LoaderStyle)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LoaderStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.LoaderStyle)//color?": {
		Doc:   "Get *material.LoaderStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.LoaderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.LoaderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LoaderStyle)//color?: arg 1: expected native of type *material.LoaderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LoaderStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LoaderStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.LoaderStyle)//layout": {
		Doc:   "material.LoaderStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.LoaderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.LoaderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LoaderStyle)//layout: arg 1: expected native of type *material.LoaderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LoaderStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LoaderStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LoaderStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.LoaderStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.LoaderStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.Palette)//bg!": {
		Doc:   "Set *material.Palette Bg value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Palette
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Palette)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//bg!: arg 1: expected native of type *material.Palette")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//bg!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//bg!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//bg!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//bg!: arg 2: expected native")
			}
			self.Bg = newVal
			return arg0
		},
	},
	"Go(*material.Palette)//bg?": {
		Doc:   "Get *material.Palette Bg value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Palette
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Palette)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//bg?: arg 1: expected native of type *material.Palette")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//bg?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//bg?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Bg, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.Palette)//contrast-bg!": {
		Doc:   "Set *material.Palette ContrastBg value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Palette
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Palette)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//contrast-bg!: arg 1: expected native of type *material.Palette")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//contrast-bg!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//contrast-bg!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//contrast-bg!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//contrast-bg!: arg 2: expected native")
			}
			self.ContrastBg = newVal
			return arg0
		},
	},
	"Go(*material.Palette)//contrast-bg?": {
		Doc:   "Get *material.Palette ContrastBg value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Palette
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Palette)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//contrast-bg?: arg 1: expected native of type *material.Palette")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//contrast-bg?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//contrast-bg?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ContrastBg, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.Palette)//contrast-fg!": {
		Doc:   "Set *material.Palette ContrastFg value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Palette
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Palette)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//contrast-fg!: arg 1: expected native of type *material.Palette")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//contrast-fg!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//contrast-fg!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//contrast-fg!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//contrast-fg!: arg 2: expected native")
			}
			self.ContrastFg = newVal
			return arg0
		},
	},
	"Go(*material.Palette)//contrast-fg?": {
		Doc:   "Get *material.Palette ContrastFg value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Palette
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Palette)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//contrast-fg?: arg 1: expected native of type *material.Palette")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//contrast-fg?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//contrast-fg?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ContrastFg, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.Palette)//fg!": {
		Doc:   "Set *material.Palette Fg value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Palette
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Palette)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//fg!: arg 1: expected native of type *material.Palette")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//fg!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//fg!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//fg!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//fg!: arg 2: expected native")
			}
			self.Fg = newVal
			return arg0
		},
	},
	"Go(*material.Palette)//fg?": {
		Doc:   "Get *material.Palette Fg value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Palette
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Palette)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//fg?: arg 1: expected native of type *material.Palette")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Palette)//fg?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Palette)//fg?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Fg, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.ProgressBarStyle)//color!": {
		Doc:   "Set *material.ProgressBarStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//color!: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.ProgressBarStyle)//color?": {
		Doc:   "Get *material.ProgressBarStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//color?: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.ProgressBarStyle)//height!": {
		Doc:   "Set *material.ProgressBarStyle Height value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//height!: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//height!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//height!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ProgressBarStyle)//height!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Height = newVal
			return arg0
		},
	},
	"Go(*material.ProgressBarStyle)//height?": {
		Doc:   "Get *material.ProgressBarStyle Height value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//height?: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//height?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Height)))
			return resObj
		},
	},
	"Go(*material.ProgressBarStyle)//layout": {
		Doc:   "material.ProgressBarStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//layout: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.ProgressBarStyle)//progress!": {
		Doc:   "Set *material.ProgressBarStyle Progress value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//progress!: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//progress!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//progress!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//progress!: arg 2: expected decimal")
			}
			self.Progress = newVal
			return arg0
		},
	},
	"Go(*material.ProgressBarStyle)//progress?": {
		Doc:   "Get *material.ProgressBarStyle Progress value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//progress?: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//progress?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//progress?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Progress))
			return resObj
		},
	},
	"Go(*material.ProgressBarStyle)//radius!": {
		Doc:   "Set *material.ProgressBarStyle Radius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//radius!: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//radius!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//radius!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ProgressBarStyle)//radius!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Radius = newVal
			return arg0
		},
	},
	"Go(*material.ProgressBarStyle)//radius?": {
		Doc:   "Get *material.ProgressBarStyle Radius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//radius?: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//radius?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//radius?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Radius)))
			return resObj
		},
	},
	"Go(*material.ProgressBarStyle)//track-color!": {
		Doc:   "Set *material.ProgressBarStyle TrackColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//track-color!: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//track-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//track-color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//track-color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//track-color!: arg 2: expected native")
			}
			self.TrackColor = newVal
			return arg0
		},
	},
	"Go(*material.ProgressBarStyle)//track-color?": {
		Doc:   "Get *material.ProgressBarStyle TrackColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressBarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressBarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//track-color?: arg 1: expected native of type *material.ProgressBarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressBarStyle)//track-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressBarStyle)//track-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TrackColor, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.ProgressCircleStyle)//color!": {
		Doc:   "Set *material.ProgressCircleStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressCircleStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressCircleStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//color!: arg 1: expected native of type *material.ProgressCircleStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressCircleStyle)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressCircleStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.ProgressCircleStyle)//color?": {
		Doc:   "Get *material.ProgressCircleStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressCircleStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressCircleStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//color?: arg 1: expected native of type *material.ProgressCircleStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressCircleStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.ProgressCircleStyle)//layout": {
		Doc:   "material.ProgressCircleStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.ProgressCircleStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.ProgressCircleStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//layout: arg 1: expected native of type *material.ProgressCircleStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressCircleStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressCircleStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.ProgressCircleStyle)//progress!": {
		Doc:   "Set *material.ProgressCircleStyle Progress value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressCircleStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressCircleStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//progress!: arg 1: expected native of type *material.ProgressCircleStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//progress!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressCircleStyle)//progress!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressCircleStyle)//progress!: arg 2: expected decimal")
			}
			self.Progress = newVal
			return arg0
		},
	},
	"Go(*material.ProgressCircleStyle)//progress?": {
		Doc:   "Get *material.ProgressCircleStyle Progress value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ProgressCircleStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ProgressCircleStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//progress?: arg 1: expected native of type *material.ProgressCircleStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ProgressCircleStyle)//progress?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ProgressCircleStyle)//progress?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Progress))
			return resObj
		},
	},
	"Go(*material.RadioButtonStyle)//group!": {
		Doc:   "Set *material.RadioButtonStyle Group value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.RadioButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.RadioButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//group!: arg 1: expected native of type *material.RadioButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//group!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.RadioButtonStyle)//group!: arg 1: expected native")
			}
			var newVal *widget.Enum
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Enum)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//group!: arg 2: expected native of type *widget.Enum")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//group!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.RadioButtonStyle)//group!: arg 2: expected native")
			}
			self.Group = newVal
			return arg0
		},
	},
	"Go(*material.RadioButtonStyle)//group?": {
		Doc:   "Get *material.RadioButtonStyle Group value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.RadioButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.RadioButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//group?: arg 1: expected native of type *material.RadioButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//group?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.RadioButtonStyle)//group?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Group, "Go(*widget.Enum)")
			return resObj
		},
	},
	"Go(*material.RadioButtonStyle)//key!": {
		Doc:   "Set *material.RadioButtonStyle Key value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.RadioButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.RadioButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//key!: arg 1: expected native of type *material.RadioButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//key!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.RadioButtonStyle)//key!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.RadioButtonStyle)//key!: arg 2: expected string")
			}
			self.Key = newVal
			return arg0
		},
	},
	"Go(*material.RadioButtonStyle)//key?": {
		Doc:   "Get *material.RadioButtonStyle Key value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.RadioButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.RadioButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//key?: arg 1: expected native of type *material.RadioButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//key?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.RadioButtonStyle)//key?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Key)
			return resObj
		},
	},
	"Go(*material.RadioButtonStyle)//layout": {
		Doc:   "material.RadioButtonStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.RadioButtonStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.RadioButtonStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//layout: arg 1: expected native of type *material.RadioButtonStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.RadioButtonStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.RadioButtonStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.RadioButtonStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.ScrollIndicatorStyle)//color!": {
		Doc:   "Set *material.ScrollIndicatorStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollIndicatorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//color!: arg 1: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.ScrollIndicatorStyle)//color?": {
		Doc:   "Get *material.ScrollIndicatorStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollIndicatorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//color?: arg 1: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.ScrollIndicatorStyle)//corner-radius!": {
		Doc:   "Set *material.ScrollIndicatorStyle CornerRadius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollIndicatorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//corner-radius!: arg 1: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//corner-radius!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//corner-radius!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ScrollIndicatorStyle)//corner-radius!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.CornerRadius = newVal
			return arg0
		},
	},
	"Go(*material.ScrollIndicatorStyle)//corner-radius?": {
		Doc:   "Get *material.ScrollIndicatorStyle CornerRadius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollIndicatorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//corner-radius?: arg 1: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//corner-radius?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//corner-radius?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.CornerRadius)))
			return resObj
		},
	},
	"Go(*material.ScrollIndicatorStyle)//hover-color!": {
		Doc:   "Set *material.ScrollIndicatorStyle HoverColor value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollIndicatorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//hover-color!: arg 1: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//hover-color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//hover-color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//hover-color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//hover-color!: arg 2: expected native")
			}
			self.HoverColor = newVal
			return arg0
		},
	},
	"Go(*material.ScrollIndicatorStyle)//hover-color?": {
		Doc:   "Get *material.ScrollIndicatorStyle HoverColor value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollIndicatorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//hover-color?: arg 1: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//hover-color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//hover-color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.HoverColor, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.ScrollIndicatorStyle)//major-min-len!": {
		Doc:   "Set *material.ScrollIndicatorStyle MajorMinLen value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollIndicatorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//major-min-len!: arg 1: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//major-min-len!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//major-min-len!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ScrollIndicatorStyle)//major-min-len!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.MajorMinLen = newVal
			return arg0
		},
	},
	"Go(*material.ScrollIndicatorStyle)//major-min-len?": {
		Doc:   "Get *material.ScrollIndicatorStyle MajorMinLen value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollIndicatorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//major-min-len?: arg 1: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//major-min-len?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//major-min-len?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.MajorMinLen)))
			return resObj
		},
	},
	"Go(*material.ScrollIndicatorStyle)//minor-width!": {
		Doc:   "Set *material.ScrollIndicatorStyle MinorWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollIndicatorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//minor-width!: arg 1: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//minor-width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//minor-width!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ScrollIndicatorStyle)//minor-width!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.MinorWidth = newVal
			return arg0
		},
	},
	"Go(*material.ScrollIndicatorStyle)//minor-width?": {
		Doc:   "Get *material.ScrollIndicatorStyle MinorWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollIndicatorStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//minor-width?: arg 1: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollIndicatorStyle)//minor-width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollIndicatorStyle)//minor-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.MinorWidth)))
			return resObj
		},
	},
	"Go(*material.ScrollTrackStyle)//color!": {
		Doc:   "Set *material.ScrollTrackStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollTrackStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollTrackStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//color!: arg 1: expected native of type *material.ScrollTrackStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollTrackStyle)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollTrackStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.ScrollTrackStyle)//color?": {
		Doc:   "Get *material.ScrollTrackStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollTrackStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollTrackStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//color?: arg 1: expected native of type *material.ScrollTrackStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollTrackStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.ScrollTrackStyle)//major-padding!": {
		Doc:   "Set *material.ScrollTrackStyle MajorPadding value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollTrackStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollTrackStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//major-padding!: arg 1: expected native of type *material.ScrollTrackStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//major-padding!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollTrackStyle)//major-padding!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ScrollTrackStyle)//major-padding!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.MajorPadding = newVal
			return arg0
		},
	},
	"Go(*material.ScrollTrackStyle)//major-padding?": {
		Doc:   "Get *material.ScrollTrackStyle MajorPadding value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollTrackStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollTrackStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//major-padding?: arg 1: expected native of type *material.ScrollTrackStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//major-padding?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollTrackStyle)//major-padding?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.MajorPadding)))
			return resObj
		},
	},
	"Go(*material.ScrollTrackStyle)//minor-padding!": {
		Doc:   "Set *material.ScrollTrackStyle MinorPadding value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollTrackStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollTrackStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//minor-padding!: arg 1: expected native of type *material.ScrollTrackStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//minor-padding!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollTrackStyle)//minor-padding!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ScrollTrackStyle)//minor-padding!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.MinorPadding = newVal
			return arg0
		},
	},
	"Go(*material.ScrollTrackStyle)//minor-padding?": {
		Doc:   "Get *material.ScrollTrackStyle MinorPadding value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollTrackStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollTrackStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//minor-padding?: arg 1: expected native of type *material.ScrollTrackStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollTrackStyle)//minor-padding?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollTrackStyle)//minor-padding?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.MinorPadding)))
			return resObj
		},
	},
	"Go(*material.ScrollbarStyle)//indicator!": {
		Doc:   "Set *material.ScrollbarStyle Indicator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollbarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollbarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//indicator!: arg 1: expected native of type *material.ScrollbarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//indicator!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//indicator!: arg 1: expected native")
			}
			var newVal *material.ScrollIndicatorStyle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*material.ScrollIndicatorStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//indicator!: arg 2: expected native of type *material.ScrollIndicatorStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//indicator!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//indicator!: arg 2: expected native")
			}
			self.Indicator = *newVal
			return arg0
		},
	},
	"Go(*material.ScrollbarStyle)//indicator?": {
		Doc:   "Get *material.ScrollbarStyle Indicator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollbarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollbarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//indicator?: arg 1: expected native of type *material.ScrollbarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//indicator?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//indicator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Indicator, "Go(*material.ScrollIndicatorStyle)")
			return resObj
		},
	},
	"Go(*material.ScrollbarStyle)//layout": {
		Doc:   "material.ScrollbarStyle.Layout",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.ScrollbarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.ScrollbarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//layout: arg 1: expected native of type *material.ScrollbarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//layout: arg 2: expected native")
			}
			var arg2Val layout.Axis
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u uint8
					if v, ok := arg2.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.ScrollbarStyle)//layout: arg 3: expected integer")
					}
					arg2Val = layout.Axis(u)
				}
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//layout: arg 4: expected decimal")
			}
			var arg4Val float32
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//layout: arg 5: expected decimal")
			}
			res0 := (*arg0Val).Layout(*arg1Val, arg2Val, arg3Val, arg4Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.ScrollbarStyle)//scrollbar!": {
		Doc:   "Set *material.ScrollbarStyle Scrollbar value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollbarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollbarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//scrollbar!: arg 1: expected native of type *material.ScrollbarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//scrollbar!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//scrollbar!: arg 1: expected native")
			}
			var newVal *widget.Scrollbar
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//scrollbar!: arg 2: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//scrollbar!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//scrollbar!: arg 2: expected native")
			}
			self.Scrollbar = newVal
			return arg0
		},
	},
	"Go(*material.ScrollbarStyle)//scrollbar?": {
		Doc:   "Get *material.ScrollbarStyle Scrollbar value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollbarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollbarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//scrollbar?: arg 1: expected native of type *material.ScrollbarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//scrollbar?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//scrollbar?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Scrollbar, "Go(*widget.Scrollbar)")
			return resObj
		},
	},
	"Go(*material.ScrollbarStyle)//track!": {
		Doc:   "Set *material.ScrollbarStyle Track value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollbarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollbarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//track!: arg 1: expected native of type *material.ScrollbarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//track!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//track!: arg 1: expected native")
			}
			var newVal *material.ScrollTrackStyle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*material.ScrollTrackStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//track!: arg 2: expected native of type *material.ScrollTrackStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//track!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//track!: arg 2: expected native")
			}
			self.Track = *newVal
			return arg0
		},
	},
	"Go(*material.ScrollbarStyle)//track?": {
		Doc:   "Get *material.ScrollbarStyle Track value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.ScrollbarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.ScrollbarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//track?: arg 1: expected native of type *material.ScrollbarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//track?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//track?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Track, "Go(*material.ScrollTrackStyle)")
			return resObj
		},
	},
	"Go(*material.ScrollbarStyle)//width": {
		Doc:   "material.ScrollbarStyle.Width",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.ScrollbarStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.ScrollbarStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//width: arg 1: expected native of type *material.ScrollbarStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.ScrollbarStyle)//width: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.ScrollbarStyle)//width: arg 1: expected native")
			}
			res0 := (*arg0Val).Width()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(float32(res0)))
			return res0Obj
		},
	},
	"Go(*material.SliderStyle)//axis!": {
		Doc:   "Set *material.SliderStyle Axis value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SliderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SliderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//axis!: arg 1: expected native of type *material.SliderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//axis!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//axis!: arg 1: expected native")
			}
			var newVal layout.Axis
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.SliderStyle)//axis!: arg 2: expected integer")
					}
					newVal = layout.Axis(u)
				}
			}
			self.Axis = newVal
			return arg0
		},
	},
	"Go(*material.SliderStyle)//axis?": {
		Doc:   "Get *material.SliderStyle Axis value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SliderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SliderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//axis?: arg 1: expected native of type *material.SliderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//axis?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//axis?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Axis)))
			return resObj
		},
	},
	"Go(*material.SliderStyle)//color!": {
		Doc:   "Set *material.SliderStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SliderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SliderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//color!: arg 1: expected native of type *material.SliderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.SliderStyle)//color?": {
		Doc:   "Get *material.SliderStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SliderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SliderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//color?: arg 1: expected native of type *material.SliderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.SliderStyle)//finger-size!": {
		Doc:   "Set *material.SliderStyle FingerSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SliderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SliderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//finger-size!: arg 1: expected native of type *material.SliderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//finger-size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//finger-size!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.SliderStyle)//finger-size!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.FingerSize = newVal
			return arg0
		},
	},
	"Go(*material.SliderStyle)//finger-size?": {
		Doc:   "Get *material.SliderStyle FingerSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SliderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SliderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//finger-size?: arg 1: expected native of type *material.SliderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//finger-size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//finger-size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.FingerSize)))
			return resObj
		},
	},
	"Go(*material.SliderStyle)//float!": {
		Doc:   "Set *material.SliderStyle Float value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SliderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SliderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//float!: arg 1: expected native of type *material.SliderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//float!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//float!: arg 1: expected native")
			}
			var newVal *widget.Float
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//float!: arg 2: expected native of type *widget.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//float!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//float!: arg 2: expected native")
			}
			self.Float = newVal
			return arg0
		},
	},
	"Go(*material.SliderStyle)//float?": {
		Doc:   "Get *material.SliderStyle Float value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SliderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SliderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//float?: arg 1: expected native of type *material.SliderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//float?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//float?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Float, "Go(*widget.Float)")
			return resObj
		},
	},
	"Go(*material.SliderStyle)//layout": {
		Doc:   "material.SliderStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.SliderStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.SliderStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//layout: arg 1: expected native of type *material.SliderStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SliderStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SliderStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.SwitchStyle)//color!": {
		Doc:   "Set *material.SwitchStyle Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SwitchStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SwitchStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//color!: arg 1: expected native of type *material.SwitchStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//color!: arg 1: expected native")
			}
			var newVal struct {
				Enabled  color.NRGBA
				Disabled color.NRGBA
				Track    color.NRGBA
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(struct {
					Enabled  color.NRGBA
					Disabled color.NRGBA
					Track    color.NRGBA
				})
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//color!: arg 2: expected native of type struct{Enabled color.NRGBA; Disabled color.NRGBA; Track color.NRGBA}")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*material.SwitchStyle)//color?": {
		Doc:   "Get *material.SwitchStyle Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SwitchStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SwitchStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//color?: arg 1: expected native of type *material.SwitchStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(struct{Enabled color.NRGBA; Disabled color.NRGBA; Track color.NRGBA})")
			return resObj
		},
	},
	"Go(*material.SwitchStyle)//description!": {
		Doc:   "Set *material.SwitchStyle Description value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SwitchStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SwitchStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//description!: arg 1: expected native of type *material.SwitchStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//description!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//description!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//description!: arg 2: expected string")
			}
			self.Description = newVal
			return arg0
		},
	},
	"Go(*material.SwitchStyle)//description?": {
		Doc:   "Get *material.SwitchStyle Description value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SwitchStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SwitchStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//description?: arg 1: expected native of type *material.SwitchStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//description?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//description?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Description)
			return resObj
		},
	},
	"Go(*material.SwitchStyle)//layout": {
		Doc:   "material.SwitchStyle.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.SwitchStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.SwitchStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//layout: arg 1: expected native of type *material.SwitchStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*material.SwitchStyle)//switch!": {
		Doc:   "Set *material.SwitchStyle Switch value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SwitchStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SwitchStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//switch!: arg 1: expected native of type *material.SwitchStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//switch!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//switch!: arg 1: expected native")
			}
			var newVal *widget.Bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//switch!: arg 2: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//switch!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//switch!: arg 2: expected native")
			}
			self.Switch = newVal
			return arg0
		},
	},
	"Go(*material.SwitchStyle)//switch?": {
		Doc:   "Get *material.SwitchStyle Switch value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.SwitchStyle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.SwitchStyle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//switch?: arg 1: expected native of type *material.SwitchStyle")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.SwitchStyle)//switch?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.SwitchStyle)//switch?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Switch, "Go(*widget.Bool)")
			return resObj
		},
	},
	"Go(*material.Theme)//bg!": {
		Doc:   "Set *material.Theme Bg value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//bg!: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//bg!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//bg!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//bg!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//bg!: arg 2: expected native")
			}
			self.Bg = newVal
			return arg0
		},
	},
	"Go(*material.Theme)//bg?": {
		Doc:   "Get *material.Theme Bg value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//bg?: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//bg?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//bg?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Bg, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.Theme)//contrast-bg!": {
		Doc:   "Set *material.Theme ContrastBg value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//contrast-bg!: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//contrast-bg!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//contrast-bg!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//contrast-bg!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//contrast-bg!: arg 2: expected native")
			}
			self.ContrastBg = newVal
			return arg0
		},
	},
	"Go(*material.Theme)//contrast-bg?": {
		Doc:   "Get *material.Theme ContrastBg value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//contrast-bg?: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//contrast-bg?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//contrast-bg?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ContrastBg, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.Theme)//contrast-fg!": {
		Doc:   "Set *material.Theme ContrastFg value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//contrast-fg!: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//contrast-fg!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//contrast-fg!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//contrast-fg!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//contrast-fg!: arg 2: expected native")
			}
			self.ContrastFg = newVal
			return arg0
		},
	},
	"Go(*material.Theme)//contrast-fg?": {
		Doc:   "Get *material.Theme ContrastFg value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//contrast-fg?: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//contrast-fg?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//contrast-fg?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.ContrastFg, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.Theme)//face!": {
		Doc:   "Set *material.Theme Face value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//face!: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//face!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//face!: arg 1: expected native")
			}
			var newVal font.Typeface
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal font.Typeface
				if natOk {
					natVal, natValOk = nat.Value.(font.Typeface)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u string
					if v, ok := arg1.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.Theme)//face!: arg 2: expected string")
					}
					newVal = font.Typeface(u)
				}
			}
			self.Face = newVal
			return arg0
		},
	},
	"Go(*material.Theme)//face?": {
		Doc:   "Get *material.Theme Face value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//face?: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//face?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//face?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(string(self.Face))
			return resObj
		},
	},
	"Go(*material.Theme)//fg!": {
		Doc:   "Set *material.Theme Fg value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//fg!: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//fg!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//fg!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//fg!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//fg!: arg 2: expected native")
			}
			self.Fg = newVal
			return arg0
		},
	},
	"Go(*material.Theme)//fg?": {
		Doc:   "Get *material.Theme Fg value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//fg?: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//fg?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//fg?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Fg, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*material.Theme)//finger-size!": {
		Doc:   "Set *material.Theme FingerSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//finger-size!: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//finger-size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//finger-size!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*material.Theme)//finger-size!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.FingerSize = newVal
			return arg0
		},
	},
	"Go(*material.Theme)//finger-size?": {
		Doc:   "Get *material.Theme FingerSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//finger-size?: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//finger-size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//finger-size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.FingerSize)))
			return resObj
		},
	},
	"Go(*material.Theme)//icon!": {
		Doc:   "Set *material.Theme Icon value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//icon!: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//icon!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//icon!: arg 1: expected native")
			}
			var newVal struct {
				CheckBoxChecked   *widget.Icon
				CheckBoxUnchecked *widget.Icon
				RadioChecked      *widget.Icon
				RadioUnchecked    *widget.Icon
			}
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(struct {
					CheckBoxChecked   *widget.Icon
					CheckBoxUnchecked *widget.Icon
					RadioChecked      *widget.Icon
					RadioUnchecked    *widget.Icon
				})
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//icon!: arg 2: expected native of type struct{CheckBoxChecked *widget.Icon; CheckBoxUnchecked *widget.Icon; RadioChecked *widget.Icon; RadioUnchecked *widget.Icon}")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//icon!: arg 2: expected native")
			}
			self.Icon = newVal
			return arg0
		},
	},
	"Go(*material.Theme)//icon?": {
		Doc:   "Get *material.Theme Icon value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//icon?: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//icon?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//icon?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Icon, "Go(struct{CheckBoxChecked *widget.Icon; CheckBoxUnchecked *widget.Icon; RadioChecked *widget.Icon; RadioUnchecked *widget.Icon})")
			return resObj
		},
	},
	"Go(*material.Theme)//palette!": {
		Doc:   "Set *material.Theme Palette value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//palette!: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//palette!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//palette!: arg 1: expected native")
			}
			var newVal *material.Palette
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*material.Palette)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//palette!: arg 2: expected native of type *material.Palette")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//palette!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//palette!: arg 2: expected native")
			}
			self.Palette = *newVal
			return arg0
		},
	},
	"Go(*material.Theme)//palette?": {
		Doc:   "Get *material.Theme Palette value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//palette?: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//palette?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//palette?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Palette, "Go(*material.Palette)")
			return resObj
		},
	},
	"Go(*material.Theme)//shaper!": {
		Doc:   "Set *material.Theme Shaper value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//shaper!: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//shaper!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//shaper!: arg 1: expected native")
			}
			var newVal *text.Shaper
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*text.Shaper)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//shaper!: arg 2: expected native of type *text.Shaper")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//shaper!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//shaper!: arg 2: expected native")
			}
			self.Shaper = newVal
			return arg0
		},
	},
	"Go(*material.Theme)//shaper?": {
		Doc:   "Get *material.Theme Shaper value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//shaper?: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//shaper?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//shaper?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Shaper, "Go(*text.Shaper)")
			return resObj
		},
	},
	"Go(*material.Theme)//text-size!": {
		Doc:   "Set *material.Theme TextSize value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//text-size!: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//text-size!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//text-size!: arg 1: expected native")
			}
			var newVal unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//text-size!: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//text-size!: arg 2: expected native")
			}
			self.TextSize = newVal
			return arg0
		},
	},
	"Go(*material.Theme)//text-size?": {
		Doc:   "Get *material.Theme TextSize value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//text-size?: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//text-size?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//text-size?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.TextSize, "Go(unit.Sp)")
			return resObj
		},
	},
	"Go(*material.Theme)//with-palette": {
		Doc:   "material.Theme.WithPalette",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//with-palette: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//with-palette: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//with-palette: arg 1: expected native")
			}
			var arg1Val *material.Palette
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*material.Palette)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//with-palette: arg 2: expected native of type *material.Palette")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*material.Theme)//with-palette: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*material.Theme)//with-palette: arg 2: expected native")
			}
			res0 := (*arg0Val).WithPalette(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.Theme)")
			return res0Obj
		},
	},
	"Go(*op.CallOp)//add": {
		Doc:   "op.CallOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.CallOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.CallOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.CallOp)//add: arg 1: expected native of type *op.CallOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.CallOp)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.CallOp)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.CallOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.CallOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.CallOp)//add: arg 2: expected native")
			}
			(*arg0Val).Add(arg1Val)
			return arg0
		},
	},
	"Go(*op.InvalidateCmd)//at!": {
		Doc:   "Set *op.InvalidateCmd At value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *op.InvalidateCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*op.InvalidateCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.InvalidateCmd)//at!: arg 1: expected native of type *op.InvalidateCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.InvalidateCmd)//at!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.InvalidateCmd)//at!: arg 1: expected native")
			}
			var newVal time.Time
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(time.Time)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.InvalidateCmd)//at!: arg 2: expected native of type time.Time")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.InvalidateCmd)//at!: arg 2: expected native")
			}
			self.At = newVal
			return arg0
		},
	},
	"Go(*op.InvalidateCmd)//at?": {
		Doc:   "Get *op.InvalidateCmd At value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *op.InvalidateCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*op.InvalidateCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.InvalidateCmd)//at?: arg 1: expected native of type *op.InvalidateCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.InvalidateCmd)//at?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.InvalidateCmd)//at?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.At, "Go(time.Time)")
			return resObj
		},
	},
	"Go(*op.InvalidateCmd)//implements-command": {
		Doc:   "op.InvalidateCmd.ImplementsCommand",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.InvalidateCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.InvalidateCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.InvalidateCmd)//implements-command: arg 1: expected native of type *op.InvalidateCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.InvalidateCmd)//implements-command: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.InvalidateCmd)//implements-command: arg 1: expected native")
			}
			(*arg0Val).ImplementsCommand()
			return arg0
		},
	},
	"Go(*op.MacroOp)//stop": {
		Doc:   "op.MacroOp.Stop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.MacroOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.MacroOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.MacroOp)//stop: arg 1: expected native of type *op.MacroOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.MacroOp)//stop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.MacroOp)//stop: arg 1: expected native")
			}
			res0 := (*arg0Val).Stop()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*op.CallOp)")
			return res0Obj
		},
	},
	"Go(*op.Ops)//reset": {
		Doc:   "(*op.Ops).Reset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.Ops
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.Ops)//reset: arg 1: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.Ops)//reset: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.Ops)//reset: arg 1: expected native")
			}
			arg0Val.Reset()
			return arg0
		},
	},
	"Go(*op.TransformOp)//add": {
		Doc:   "op.TransformOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.TransformOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.TransformOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.TransformOp)//add: arg 1: expected native of type *op.TransformOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.TransformOp)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.TransformOp)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.TransformOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.TransformOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.TransformOp)//add: arg 2: expected native")
			}
			(*arg0Val).Add(arg1Val)
			return arg0
		},
	},
	"Go(*op.TransformOp)//push": {
		Doc:   "op.TransformOp.Push",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.TransformOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.TransformOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.TransformOp)//push: arg 1: expected native of type *op.TransformOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.TransformOp)//push: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.TransformOp)//push: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.TransformOp)//push: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.TransformOp)//push: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.TransformOp)//push: arg 2: expected native")
			}
			res0 := (*arg0Val).Push(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*op.TransformStack)")
			return res0Obj
		},
	},
	"Go(*op.TransformStack)//pop": {
		Doc:   "op.TransformStack.Pop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.TransformStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.TransformStack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*op.TransformStack)//pop: arg 1: expected native of type *op.TransformStack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*op.TransformStack)//pop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*op.TransformStack)//pop: arg 1: expected native")
			}
			(*arg0Val).Pop()
			return arg0
		},
	},
	"Go(*opentype.Face)//face": {
		Doc:   "opentype.Face.Face",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *opentype.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*opentype.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*opentype.Face)//face: arg 1: expected native of type *opentype.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*opentype.Face)//face: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*opentype.Face)//face: arg 1: expected native")
			}
			res0 := (*arg0Val).Face()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(typesetting_font.Face)")
			return res0Obj
		},
	},
	"Go(*opentype.Face)//font": {
		Doc:   "opentype.Face.Font",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *opentype.Face
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*opentype.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*opentype.Face)//font: arg 1: expected native of type *opentype.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*opentype.Face)//font: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*opentype.Face)//font: arg 1: expected native")
			}
			res0 := (*arg0Val).Font()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*font.Font)")
			return res0Obj
		},
	},
	"Go(*paint.ColorOp)//add": {
		Doc:   "paint.ColorOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *paint.ColorOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*paint.ColorOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ColorOp)//add: arg 1: expected native of type *paint.ColorOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ColorOp)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.ColorOp)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ColorOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ColorOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.ColorOp)//add: arg 2: expected native")
			}
			(*arg0Val).Add(arg1Val)
			return arg0
		},
	},
	"Go(*paint.ColorOp)//color!": {
		Doc:   "Set *paint.ColorOp Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.ColorOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.ColorOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ColorOp)//color!: arg 1: expected native of type *paint.ColorOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ColorOp)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.ColorOp)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ColorOp)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.ColorOp)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*paint.ColorOp)//color?": {
		Doc:   "Get *paint.ColorOp Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.ColorOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.ColorOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ColorOp)//color?: arg 1: expected native of type *paint.ColorOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ColorOp)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.ColorOp)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*paint.ImageOp)//add": {
		Doc:   "paint.ImageOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *paint.ImageOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*paint.ImageOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ImageOp)//add: arg 1: expected native of type *paint.ImageOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ImageOp)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.ImageOp)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ImageOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ImageOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.ImageOp)//add: arg 2: expected native")
			}
			(*arg0Val).Add(arg1Val)
			return arg0
		},
	},
	"Go(*paint.ImageOp)//filter!": {
		Doc:   "Set *paint.ImageOp Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.ImageOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.ImageOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ImageOp)//filter!: arg 1: expected native of type *paint.ImageOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ImageOp)//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.ImageOp)//filter!: arg 1: expected native")
			}
			var newVal paint.ImageFilter
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal paint.ImageFilter
				if natOk {
					natVal, natValOk = nat.Value.(paint.ImageFilter)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*paint.ImageOp)//filter!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*paint.ImageOp)//filter!: arg 2: expected native")
					}
					newVal = paint.ImageFilter(u)
				}
			}
			self.Filter = newVal
			return arg0
		},
	},
	"Go(*paint.ImageOp)//filter?": {
		Doc:   "Get *paint.ImageOp Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.ImageOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.ImageOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ImageOp)//filter?: arg 1: expected native of type *paint.ImageOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ImageOp)//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.ImageOp)//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.Filter), "Go(byte)")
			return resObj
		},
	},
	"Go(*paint.ImageOp)//size": {
		Doc:   "paint.ImageOp.Size",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *paint.ImageOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*paint.ImageOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ImageOp)//size: arg 1: expected native of type *paint.ImageOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.ImageOp)//size: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.ImageOp)//size: arg 1: expected native")
			}
			res0 := (*arg0Val).Size()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(image.Point)")
			return res0Obj
		},
	},
	"Go(*paint.LinearGradientOp)//add": {
		Doc:   "paint.LinearGradientOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *paint.LinearGradientOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*paint.LinearGradientOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//add: arg 1: expected native of type *paint.LinearGradientOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//add: arg 2: expected native")
			}
			(*arg0Val).Add(arg1Val)
			return arg0
		},
	},
	"Go(*paint.LinearGradientOp)//color-1!": {
		Doc:   "Set *paint.LinearGradientOp Color1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.LinearGradientOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.LinearGradientOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//color-1!: arg 1: expected native of type *paint.LinearGradientOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//color-1!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//color-1!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//color-1!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//color-1!: arg 2: expected native")
			}
			self.Color1 = newVal
			return arg0
		},
	},
	"Go(*paint.LinearGradientOp)//color-1?": {
		Doc:   "Get *paint.LinearGradientOp Color1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.LinearGradientOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.LinearGradientOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//color-1?: arg 1: expected native of type *paint.LinearGradientOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//color-1?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//color-1?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color1, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*paint.LinearGradientOp)//color-2!": {
		Doc:   "Set *paint.LinearGradientOp Color2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.LinearGradientOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.LinearGradientOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//color-2!: arg 1: expected native of type *paint.LinearGradientOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//color-2!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//color-2!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//color-2!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//color-2!: arg 2: expected native")
			}
			self.Color2 = newVal
			return arg0
		},
	},
	"Go(*paint.LinearGradientOp)//color-2?": {
		Doc:   "Get *paint.LinearGradientOp Color2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.LinearGradientOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.LinearGradientOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//color-2?: arg 1: expected native of type *paint.LinearGradientOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//color-2?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//color-2?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color2, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*paint.LinearGradientOp)//stop-1!": {
		Doc:   "Set *paint.LinearGradientOp Stop1 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.LinearGradientOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.LinearGradientOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-1!: arg 1: expected native of type *paint.LinearGradientOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-1!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//stop-1!: arg 1: expected native")
			}
			var newVal *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-1!: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-1!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//stop-1!: arg 2: expected native")
			}
			self.Stop1 = *newVal
			return arg0
		},
	},
	"Go(*paint.LinearGradientOp)//stop-1?": {
		Doc:   "Get *paint.LinearGradientOp Stop1 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.LinearGradientOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.LinearGradientOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-1?: arg 1: expected native of type *paint.LinearGradientOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-1?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//stop-1?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Stop1, "Go(*f32.Point)")
			return resObj
		},
	},
	"Go(*paint.LinearGradientOp)//stop-2!": {
		Doc:   "Set *paint.LinearGradientOp Stop2 value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.LinearGradientOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.LinearGradientOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-2!: arg 1: expected native of type *paint.LinearGradientOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-2!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//stop-2!: arg 1: expected native")
			}
			var newVal *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-2!: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-2!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//stop-2!: arg 2: expected native")
			}
			self.Stop2 = *newVal
			return arg0
		},
	},
	"Go(*paint.LinearGradientOp)//stop-2?": {
		Doc:   "Get *paint.LinearGradientOp Stop2 value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *paint.LinearGradientOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*paint.LinearGradientOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-2?: arg 1: expected native of type *paint.LinearGradientOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.LinearGradientOp)//stop-2?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.LinearGradientOp)//stop-2?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Stop2, "Go(*f32.Point)")
			return resObj
		},
	},
	"Go(*paint.OpacityStack)//pop": {
		Doc:   "paint.OpacityStack.Pop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *paint.OpacityStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*paint.OpacityStack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.OpacityStack)//pop: arg 1: expected native of type *paint.OpacityStack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.OpacityStack)//pop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.OpacityStack)//pop: arg 1: expected native")
			}
			(*arg0Val).Pop()
			return arg0
		},
	},
	"Go(*paint.PaintOp)//add": {
		Doc:   "paint.PaintOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *paint.PaintOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*paint.PaintOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.PaintOp)//add: arg 1: expected native of type *paint.PaintOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.PaintOp)//add: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.PaintOp)//add: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.PaintOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*paint.PaintOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*paint.PaintOp)//add: arg 2: expected native")
			}
			(*arg0Val).Add(arg1Val)
			return arg0
		},
	},
	"Go(*pointer.Event)//buttons!": {
		Doc:   "Set *pointer.Event Buttons value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//buttons!: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//buttons!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//buttons!: arg 1: expected native")
			}
			var newVal pointer.Buttons
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal pointer.Buttons
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Buttons)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*pointer.Event)//buttons!: arg 2: expected integer")
					}
					newVal = pointer.Buttons(u)
				}
			}
			self.Buttons = newVal
			return arg0
		},
	},
	"Go(*pointer.Event)//buttons?": {
		Doc:   "Get *pointer.Event Buttons value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//buttons?: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//buttons?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//buttons?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Buttons)))
			return resObj
		},
	},
	"Go(*pointer.Event)//implements-event": {
		Doc:   "pointer.Event.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//implements-event: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*pointer.Event)//kind!": {
		Doc:   "Set *pointer.Event Kind value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//kind!: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//kind!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//kind!: arg 1: expected native")
			}
			var newVal pointer.Kind
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal pointer.Kind
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Kind)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint
					if v, ok := arg1.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*pointer.Event)//kind!: arg 2: expected integer")
					}
					newVal = pointer.Kind(u)
				}
			}
			self.Kind = newVal
			return arg0
		},
	},
	"Go(*pointer.Event)//kind?": {
		Doc:   "Get *pointer.Event Kind value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//kind?: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//kind?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//kind?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(self.Kind)))
			return resObj
		},
	},
	"Go(*pointer.Event)//modifiers!": {
		Doc:   "Set *pointer.Event Modifiers value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//modifiers!: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//modifiers!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//modifiers!: arg 1: expected native")
			}
			var newVal key.Modifiers
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.Modifiers
				if natOk {
					natVal, natValOk = nat.Value.(key.Modifiers)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*pointer.Event)//modifiers!: arg 2: expected integer")
					}
					newVal = key.Modifiers(u)
				}
			}
			self.Modifiers = newVal
			return arg0
		},
	},
	"Go(*pointer.Event)//modifiers?": {
		Doc:   "Get *pointer.Event Modifiers value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//modifiers?: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//modifiers?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//modifiers?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(self.Modifiers)))
			return resObj
		},
	},
	"Go(*pointer.Event)//pointer-id!": {
		Doc:   "Set *pointer.Event PointerID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//pointer-id!: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//pointer-id!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//pointer-id!: arg 1: expected native")
			}
			var newVal pointer.ID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal pointer.ID
				if natOk {
					natVal, natValOk = nat.Value.(pointer.ID)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint16
					if v, ok := arg1.(env.Integer); ok {
						u = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*pointer.Event)//pointer-id!: arg 2: expected integer")
					}
					newVal = pointer.ID(u)
				}
			}
			self.PointerID = newVal
			return arg0
		},
	},
	"Go(*pointer.Event)//pointer-id?": {
		Doc:   "Get *pointer.Event PointerID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//pointer-id?: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//pointer-id?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//pointer-id?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint16(self.PointerID)))
			return resObj
		},
	},
	"Go(*pointer.Event)//position!": {
		Doc:   "Set *pointer.Event Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//position!: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//position!: arg 1: expected native")
			}
			var newVal *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//position!: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//position!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//position!: arg 2: expected native")
			}
			self.Position = *newVal
			return arg0
		},
	},
	"Go(*pointer.Event)//position?": {
		Doc:   "Get *pointer.Event Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//position?: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Position, "Go(*f32.Point)")
			return resObj
		},
	},
	"Go(*pointer.Event)//priority!": {
		Doc:   "Set *pointer.Event Priority value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//priority!: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//priority!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//priority!: arg 1: expected native")
			}
			var newVal pointer.Priority
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal pointer.Priority
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Priority)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*pointer.Event)//priority!: arg 2: expected integer")
					}
					newVal = pointer.Priority(u)
				}
			}
			self.Priority = newVal
			return arg0
		},
	},
	"Go(*pointer.Event)//priority?": {
		Doc:   "Get *pointer.Event Priority value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//priority?: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//priority?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//priority?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Priority)))
			return resObj
		},
	},
	"Go(*pointer.Event)//scroll!": {
		Doc:   "Set *pointer.Event Scroll value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//scroll!: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//scroll!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//scroll!: arg 1: expected native")
			}
			var newVal *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//scroll!: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//scroll!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//scroll!: arg 2: expected native")
			}
			self.Scroll = *newVal
			return arg0
		},
	},
	"Go(*pointer.Event)//scroll?": {
		Doc:   "Get *pointer.Event Scroll value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//scroll?: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//scroll?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//scroll?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Scroll, "Go(*f32.Point)")
			return resObj
		},
	},
	"Go(*pointer.Event)//source!": {
		Doc:   "Set *pointer.Event Source value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//source!: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//source!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//source!: arg 1: expected native")
			}
			var newVal pointer.Source
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal pointer.Source
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Source)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*pointer.Event)//source!: arg 2: expected integer")
					}
					newVal = pointer.Source(u)
				}
			}
			self.Source = newVal
			return arg0
		},
	},
	"Go(*pointer.Event)//source?": {
		Doc:   "Get *pointer.Event Source value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//source?: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//source?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//source?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Source)))
			return resObj
		},
	},
	"Go(*pointer.Event)//time!": {
		Doc:   "Set *pointer.Event Time value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//time!: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//time!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//time!: arg 1: expected native")
			}
			var newVal time.Duration
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(time.Duration)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//time!: arg 2: expected native of type time.Duration")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//time!: arg 2: expected native")
			}
			self.Time = newVal
			return arg0
		},
	},
	"Go(*pointer.Event)//time?": {
		Doc:   "Get *pointer.Event Time value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Event
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//time?: arg 1: expected native of type *pointer.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Event)//time?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Event)//time?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Time, "Go(time.Duration)")
			return resObj
		},
	},
	"Go(*pointer.Filter)//implements-filter": {
		Doc:   "pointer.Filter.ImplementsFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *pointer.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*pointer.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//implements-filter: arg 1: expected native of type *pointer.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//implements-filter: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//implements-filter: arg 1: expected native")
			}
			(*arg0Val).ImplementsFilter()
			return arg0
		},
	},
	"Go(*pointer.Filter)//kinds!": {
		Doc:   "Set *pointer.Filter Kinds value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//kinds!: arg 1: expected native of type *pointer.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//kinds!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//kinds!: arg 1: expected native")
			}
			var newVal pointer.Kind
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal pointer.Kind
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Kind)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint
					if v, ok := arg1.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*pointer.Filter)//kinds!: arg 2: expected integer")
					}
					newVal = pointer.Kind(u)
				}
			}
			self.Kinds = newVal
			return arg0
		},
	},
	"Go(*pointer.Filter)//kinds?": {
		Doc:   "Get *pointer.Filter Kinds value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//kinds?: arg 1: expected native of type *pointer.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//kinds?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//kinds?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(self.Kinds)))
			return resObj
		},
	},
	"Go(*pointer.Filter)//scroll-x!": {
		Doc:   "Set *pointer.Filter ScrollX value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-x!: arg 1: expected native of type *pointer.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//scroll-x!: arg 1: expected native")
			}
			var newVal *pointer.ScrollRange
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*pointer.ScrollRange)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-x!: arg 2: expected native of type *pointer.ScrollRange")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-x!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//scroll-x!: arg 2: expected native")
			}
			self.ScrollX = *newVal
			return arg0
		},
	},
	"Go(*pointer.Filter)//scroll-x?": {
		Doc:   "Get *pointer.Filter ScrollX value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-x?: arg 1: expected native of type *pointer.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//scroll-x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.ScrollX, "Go(*pointer.ScrollRange)")
			return resObj
		},
	},
	"Go(*pointer.Filter)//scroll-y!": {
		Doc:   "Set *pointer.Filter ScrollY value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-y!: arg 1: expected native of type *pointer.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//scroll-y!: arg 1: expected native")
			}
			var newVal *pointer.ScrollRange
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*pointer.ScrollRange)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-y!: arg 2: expected native of type *pointer.ScrollRange")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-y!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//scroll-y!: arg 2: expected native")
			}
			self.ScrollY = *newVal
			return arg0
		},
	},
	"Go(*pointer.Filter)//scroll-y?": {
		Doc:   "Get *pointer.Filter ScrollY value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-y?: arg 1: expected native of type *pointer.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//scroll-y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//scroll-y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.ScrollY, "Go(*pointer.ScrollRange)")
			return resObj
		},
	},
	"Go(*pointer.Filter)//target!": {
		Doc:   "Set *pointer.Filter Target value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//target!: arg 1: expected native of type *pointer.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//target!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//target!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//target!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//target!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//target!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//target!: arg 2: expected native")
			}
			self.Target = newVal
			return arg0
		},
	},
	"Go(*pointer.Filter)//target?": {
		Doc:   "Get *pointer.Filter Target value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.Filter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//target?: arg 1: expected native of type *pointer.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.Filter)//target?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.Filter)//target?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Target, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*pointer.GrabCmd)//id!": {
		Doc:   "Set *pointer.GrabCmd ID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.GrabCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.GrabCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//id!: arg 1: expected native of type *pointer.GrabCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//id!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.GrabCmd)//id!: arg 1: expected native")
			}
			var newVal pointer.ID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal pointer.ID
				if natOk {
					natVal, natValOk = nat.Value.(pointer.ID)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint16
					if v, ok := arg1.(env.Integer); ok {
						u = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*pointer.GrabCmd)//id!: arg 2: expected integer")
					}
					newVal = pointer.ID(u)
				}
			}
			self.ID = newVal
			return arg0
		},
	},
	"Go(*pointer.GrabCmd)//id?": {
		Doc:   "Get *pointer.GrabCmd ID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.GrabCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.GrabCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//id?: arg 1: expected native of type *pointer.GrabCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//id?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.GrabCmd)//id?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint16(self.ID)))
			return resObj
		},
	},
	"Go(*pointer.GrabCmd)//implements-command": {
		Doc:   "pointer.GrabCmd.ImplementsCommand",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *pointer.GrabCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*pointer.GrabCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//implements-command: arg 1: expected native of type *pointer.GrabCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//implements-command: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.GrabCmd)//implements-command: arg 1: expected native")
			}
			(*arg0Val).ImplementsCommand()
			return arg0
		},
	},
	"Go(*pointer.GrabCmd)//tag!": {
		Doc:   "Set *pointer.GrabCmd Tag value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.GrabCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.GrabCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//tag!: arg 1: expected native of type *pointer.GrabCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//tag!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.GrabCmd)//tag!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//tag!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//tag!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//tag!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.GrabCmd)//tag!: arg 2: expected native")
			}
			self.Tag = newVal
			return arg0
		},
	},
	"Go(*pointer.GrabCmd)//tag?": {
		Doc:   "Get *pointer.GrabCmd Tag value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.GrabCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.GrabCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//tag?: arg 1: expected native of type *pointer.GrabCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.GrabCmd)//tag?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.GrabCmd)//tag?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Tag, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*pointer.PassOp)//push": {
		Doc:   "pointer.PassOp.Push",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *pointer.PassOp
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*pointer.PassOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.PassOp)//push: arg 1: expected native of type *pointer.PassOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.PassOp)//push: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.PassOp)//push: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.PassOp)//push: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.PassOp)//push: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.PassOp)//push: arg 2: expected native")
			}
			res0 := (*arg0Val).Push(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*pointer.PassStack)")
			return res0Obj
		},
	},
	"Go(*pointer.PassStack)//pop": {
		Doc:   "pointer.PassStack.Pop",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *pointer.PassStack
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*pointer.PassStack)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.PassStack)//pop: arg 1: expected native of type *pointer.PassStack")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.PassStack)//pop: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.PassStack)//pop: arg 1: expected native")
			}
			(*arg0Val).Pop()
			return arg0
		},
	},
	"Go(*pointer.ScrollRange)//max!": {
		Doc:   "Set *pointer.ScrollRange Max value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.ScrollRange
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.ScrollRange)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//max!: arg 1: expected native of type *pointer.ScrollRange")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//max!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.ScrollRange)//max!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.ScrollRange)//max!: arg 2: expected integer")
			}
			self.Max = newVal
			return arg0
		},
	},
	"Go(*pointer.ScrollRange)//max?": {
		Doc:   "Get *pointer.ScrollRange Max value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.ScrollRange
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.ScrollRange)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//max?: arg 1: expected native of type *pointer.ScrollRange")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//max?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.ScrollRange)//max?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Max))
			return resObj
		},
	},
	"Go(*pointer.ScrollRange)//min!": {
		Doc:   "Set *pointer.ScrollRange Min value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.ScrollRange
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.ScrollRange)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//min!: arg 1: expected native of type *pointer.ScrollRange")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//min!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.ScrollRange)//min!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.ScrollRange)//min!: arg 2: expected integer")
			}
			self.Min = newVal
			return arg0
		},
	},
	"Go(*pointer.ScrollRange)//min?": {
		Doc:   "Get *pointer.ScrollRange Min value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *pointer.ScrollRange
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*pointer.ScrollRange)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//min?: arg 1: expected native of type *pointer.ScrollRange")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//min?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.ScrollRange)//min?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Min))
			return resObj
		},
	},
	"Go(*pointer.ScrollRange)//union": {
		Doc:   "pointer.ScrollRange.Union",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *pointer.ScrollRange
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*pointer.ScrollRange)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//union: arg 1: expected native of type *pointer.ScrollRange")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//union: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.ScrollRange)//union: arg 1: expected native")
			}
			var arg1Val *pointer.ScrollRange
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*pointer.ScrollRange)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//union: arg 2: expected native of type *pointer.ScrollRange")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*pointer.ScrollRange)//union: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*pointer.ScrollRange)//union: arg 2: expected native")
			}
			res0 := (*arg0Val).Union(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*pointer.ScrollRange)")
			return res0Obj
		},
	},
	"Go(*system.Locale)//direction!": {
		Doc:   "Set *system.Locale Direction value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *system.Locale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*system.Locale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*system.Locale)//direction!: arg 1: expected native of type *system.Locale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*system.Locale)//direction!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*system.Locale)//direction!: arg 1: expected native")
			}
			var newVal system.TextDirection
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal system.TextDirection
				if natOk {
					natVal, natValOk = nat.Value.(system.TextDirection)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*system.Locale)//direction!: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*system.Locale)//direction!: arg 2: expected native")
					}
					newVal = system.TextDirection(u)
				}
			}
			self.Direction = newVal
			return arg0
		},
	},
	"Go(*system.Locale)//direction?": {
		Doc:   "Get *system.Locale Direction value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *system.Locale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*system.Locale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*system.Locale)//direction?: arg 1: expected native of type *system.Locale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*system.Locale)//direction?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*system.Locale)//direction?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(self.Direction), "Go(byte)")
			return resObj
		},
	},
	"Go(*system.Locale)//language!": {
		Doc:   "Set *system.Locale Language value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *system.Locale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*system.Locale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*system.Locale)//language!: arg 1: expected native of type *system.Locale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*system.Locale)//language!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*system.Locale)//language!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*system.Locale)//language!: arg 2: expected string")
			}
			self.Language = newVal
			return arg0
		},
	},
	"Go(*system.Locale)//language?": {
		Doc:   "Get *system.Locale Language value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *system.Locale
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*system.Locale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*system.Locale)//language?: arg 1: expected native of type *system.Locale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*system.Locale)//language?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*system.Locale)//language?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Language)
			return resObj
		},
	},
	"Go(*text.Glyph)//advance!": {
		Doc:   "Set *text.Glyph Advance value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//advance!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//advance!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//advance!: arg 1: expected native")
			}
			var newVal fixed.Int26_6
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(fixed.Int26_6)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//advance!: arg 2: expected native of type fixed.Int26_6")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//advance!: arg 2: expected native")
			}
			self.Advance = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//advance?": {
		Doc:   "Get *text.Glyph Advance value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//advance?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//advance?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//advance?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Advance, "Go(fixed.Int26_6)")
			return resObj
		},
	},
	"Go(*text.Glyph)//ascent!": {
		Doc:   "Set *text.Glyph Ascent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//ascent!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//ascent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//ascent!: arg 1: expected native")
			}
			var newVal fixed.Int26_6
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(fixed.Int26_6)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//ascent!: arg 2: expected native of type fixed.Int26_6")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//ascent!: arg 2: expected native")
			}
			self.Ascent = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//ascent?": {
		Doc:   "Get *text.Glyph Ascent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//ascent?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//ascent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//ascent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Ascent, "Go(fixed.Int26_6)")
			return resObj
		},
	},
	"Go(*text.Glyph)//bounds!": {
		Doc:   "Set *text.Glyph Bounds value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//bounds!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//bounds!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//bounds!: arg 1: expected native")
			}
			var newVal fixed.Rectangle26_6
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(fixed.Rectangle26_6)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//bounds!: arg 2: expected native of type fixed.Rectangle26_6")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//bounds!: arg 2: expected native")
			}
			self.Bounds = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//bounds?": {
		Doc:   "Get *text.Glyph Bounds value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//bounds?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//bounds?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//bounds?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Bounds, "Go(fixed.Rectangle26_6)")
			return resObj
		},
	},
	"Go(*text.Glyph)//descent!": {
		Doc:   "Set *text.Glyph Descent value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//descent!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//descent!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//descent!: arg 1: expected native")
			}
			var newVal fixed.Int26_6
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(fixed.Int26_6)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//descent!: arg 2: expected native of type fixed.Int26_6")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//descent!: arg 2: expected native")
			}
			self.Descent = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//descent?": {
		Doc:   "Get *text.Glyph Descent value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//descent?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//descent?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//descent?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Descent, "Go(fixed.Int26_6)")
			return resObj
		},
	},
	"Go(*text.Glyph)//flags!": {
		Doc:   "Set *text.Glyph Flags value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//flags!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//flags!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//flags!: arg 1: expected native")
			}
			var newVal text.Flags
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Flags
				if natOk {
					natVal, natValOk = nat.Value.(text.Flags)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint16
					if v, ok := arg1.(env.Integer); ok {
						u = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.Glyph)//flags!: arg 2: expected integer")
					}
					newVal = text.Flags(u)
				}
			}
			self.Flags = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//flags?": {
		Doc:   "Get *text.Glyph Flags value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//flags?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//flags?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//flags?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint16(self.Flags)))
			return resObj
		},
	},
	"Go(*text.Glyph)//id!": {
		Doc:   "Set *text.Glyph ID value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//id!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//id!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//id!: arg 1: expected native")
			}
			var newVal text.GlyphID
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.GlyphID
				if natOk {
					natVal, natValOk = nat.Value.(text.GlyphID)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint64
					if v, ok := arg1.(env.Integer); ok {
						u = uint64(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.Glyph)//id!: arg 2: expected integer")
					}
					newVal = text.GlyphID(u)
				}
			}
			self.ID = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//id?": {
		Doc:   "Get *text.Glyph ID value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//id?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//id?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//id?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint64(self.ID)))
			return resObj
		},
	},
	"Go(*text.Glyph)//offset!": {
		Doc:   "Set *text.Glyph Offset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//offset!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//offset!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//offset!: arg 1: expected native")
			}
			var newVal fixed.Point26_6
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(fixed.Point26_6)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//offset!: arg 2: expected native of type fixed.Point26_6")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//offset!: arg 2: expected native")
			}
			self.Offset = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//offset?": {
		Doc:   "Get *text.Glyph Offset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//offset?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//offset?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//offset?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Offset, "Go(fixed.Point26_6)")
			return resObj
		},
	},
	"Go(*text.Glyph)//runes!": {
		Doc:   "Set *text.Glyph Runes value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//runes!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//runes!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//runes!: arg 1: expected native")
			}
			var newVal uint16
			if v, ok := arg1.(env.Integer); ok {
				newVal = uint16(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//runes!: arg 2: expected integer")
			}
			self.Runes = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//runes?": {
		Doc:   "Get *text.Glyph Runes value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//runes?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//runes?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//runes?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Runes))
			return resObj
		},
	},
	"Go(*text.Glyph)//x!": {
		Doc:   "Set *text.Glyph X value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//x!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//x!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//x!: arg 1: expected native")
			}
			var newVal fixed.Int26_6
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(fixed.Int26_6)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//x!: arg 2: expected native of type fixed.Int26_6")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//x!: arg 2: expected native")
			}
			self.X = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//x?": {
		Doc:   "Get *text.Glyph X value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//x?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//x?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//x?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.X, "Go(fixed.Int26_6)")
			return resObj
		},
	},
	"Go(*text.Glyph)//y!": {
		Doc:   "Set *text.Glyph Y value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//y!: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//y!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//y!: arg 1: expected native")
			}
			var newVal int32
			if v, ok := arg1.(env.Integer); ok {
				newVal = int32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//y!: arg 2: expected integer")
			}
			self.Y = newVal
			return arg0
		},
	},
	"Go(*text.Glyph)//y?": {
		Doc:   "Get *text.Glyph Y value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Glyph
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//y?: arg 1: expected native of type *text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Glyph)//y?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Glyph)//y?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Y))
			return resObj
		},
	},
	"Go(*text.Parameters)//alignment!": {
		Doc:   "Set *text.Parameters Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//alignment!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//alignment!: arg 1: expected native")
			}
			var newVal text.Alignment
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(text.Alignment)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.Parameters)//alignment!: arg 2: expected integer")
					}
					newVal = text.Alignment(u)
				}
			}
			self.Alignment = newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//alignment?": {
		Doc:   "Get *text.Parameters Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//alignment?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Alignment)))
			return resObj
		},
	},
	"Go(*text.Parameters)//font!": {
		Doc:   "Set *text.Parameters Font value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//font!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//font!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//font!: arg 1: expected native")
			}
			var newVal *font.Font
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//font!: arg 2: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//font!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//font!: arg 2: expected native")
			}
			self.Font = *newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//font?": {
		Doc:   "Get *text.Parameters Font value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//font?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//font?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//font?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Font, "Go(*font.Font)")
			return resObj
		},
	},
	"Go(*text.Parameters)//line-height!": {
		Doc:   "Set *text.Parameters LineHeight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//line-height!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//line-height!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//line-height!: arg 1: expected native")
			}
			var newVal fixed.Int26_6
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(fixed.Int26_6)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//line-height!: arg 2: expected native of type fixed.Int26_6")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//line-height!: arg 2: expected native")
			}
			self.LineHeight = newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//line-height-scale!": {
		Doc:   "Set *text.Parameters LineHeightScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//line-height-scale!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//line-height-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//line-height-scale!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//line-height-scale!: arg 2: expected decimal")
			}
			self.LineHeightScale = newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//line-height-scale?": {
		Doc:   "Get *text.Parameters LineHeightScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//line-height-scale?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//line-height-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//line-height-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineHeightScale))
			return resObj
		},
	},
	"Go(*text.Parameters)//line-height?": {
		Doc:   "Get *text.Parameters LineHeight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//line-height?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//line-height?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//line-height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.LineHeight, "Go(fixed.Int26_6)")
			return resObj
		},
	},
	"Go(*text.Parameters)//locale!": {
		Doc:   "Set *text.Parameters Locale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//locale!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//locale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//locale!: arg 1: expected native")
			}
			var newVal *system.Locale
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*system.Locale)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//locale!: arg 2: expected native of type *system.Locale")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//locale!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//locale!: arg 2: expected native")
			}
			self.Locale = *newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//locale?": {
		Doc:   "Get *text.Parameters Locale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//locale?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//locale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//locale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Locale, "Go(*system.Locale)")
			return resObj
		},
	},
	"Go(*text.Parameters)//max-lines!": {
		Doc:   "Set *text.Parameters MaxLines value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//max-lines!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//max-lines!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//max-lines!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//max-lines!: arg 2: expected integer")
			}
			self.MaxLines = newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//max-lines?": {
		Doc:   "Get *text.Parameters MaxLines value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//max-lines?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//max-lines?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//max-lines?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.MaxLines))
			return resObj
		},
	},
	"Go(*text.Parameters)//max-width!": {
		Doc:   "Set *text.Parameters MaxWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//max-width!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//max-width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//max-width!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//max-width!: arg 2: expected integer")
			}
			self.MaxWidth = newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//max-width?": {
		Doc:   "Get *text.Parameters MaxWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//max-width?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//max-width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//max-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.MaxWidth))
			return resObj
		},
	},
	"Go(*text.Parameters)//min-width!": {
		Doc:   "Set *text.Parameters MinWidth value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//min-width!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//min-width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//min-width!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//min-width!: arg 2: expected integer")
			}
			self.MinWidth = newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//min-width?": {
		Doc:   "Get *text.Parameters MinWidth value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//min-width?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//min-width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//min-width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.MinWidth))
			return resObj
		},
	},
	"Go(*text.Parameters)//px-per-em!": {
		Doc:   "Set *text.Parameters PxPerEm value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//px-per-em!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//px-per-em!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//px-per-em!: arg 1: expected native")
			}
			var newVal fixed.Int26_6
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(fixed.Int26_6)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//px-per-em!: arg 2: expected native of type fixed.Int26_6")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//px-per-em!: arg 2: expected native")
			}
			self.PxPerEm = newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//px-per-em?": {
		Doc:   "Get *text.Parameters PxPerEm value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//px-per-em?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//px-per-em?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//px-per-em?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.PxPerEm, "Go(fixed.Int26_6)")
			return resObj
		},
	},
	"Go(*text.Parameters)//truncator!": {
		Doc:   "Set *text.Parameters Truncator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//truncator!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//truncator!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//truncator!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//truncator!: arg 2: expected string")
			}
			self.Truncator = newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//truncator?": {
		Doc:   "Get *text.Parameters Truncator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//truncator?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//truncator?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//truncator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Truncator)
			return resObj
		},
	},
	"Go(*text.Parameters)//wrap-policy!": {
		Doc:   "Set *text.Parameters WrapPolicy value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//wrap-policy!: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//wrap-policy!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//wrap-policy!: arg 1: expected native")
			}
			var newVal text.WrapPolicy
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.WrapPolicy
				if natOk {
					natVal, natValOk = nat.Value.(text.WrapPolicy)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*text.Parameters)//wrap-policy!: arg 2: expected integer")
					}
					newVal = text.WrapPolicy(u)
				}
			}
			self.WrapPolicy = newVal
			return arg0
		},
	},
	"Go(*text.Parameters)//wrap-policy?": {
		Doc:   "Get *text.Parameters WrapPolicy value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Parameters
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//wrap-policy?: arg 1: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Parameters)//wrap-policy?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Parameters)//wrap-policy?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.WrapPolicy)))
			return resObj
		},
	},
	"Go(*text.Range)//count!": {
		Doc:   "Set *text.Range Count value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Range
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Range)//count!: arg 1: expected native of type *text.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Range)//count!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Range)//count!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Range)//count!: arg 2: expected integer")
			}
			self.Count = newVal
			return arg0
		},
	},
	"Go(*text.Range)//count?": {
		Doc:   "Get *text.Range Count value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Range
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Range)//count?: arg 1: expected native of type *text.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Range)//count?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Range)//count?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Count))
			return resObj
		},
	},
	"Go(*text.Range)//offset!": {
		Doc:   "Set *text.Range Offset value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Range
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Range)//offset!: arg 1: expected native of type *text.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Range)//offset!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Range)//offset!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Range)//offset!: arg 2: expected integer")
			}
			self.Offset = newVal
			return arg0
		},
	},
	"Go(*text.Range)//offset?": {
		Doc:   "Get *text.Range Offset value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *text.Range
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*text.Range)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Range)//offset?: arg 1: expected native of type *text.Range")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Range)//offset?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Range)//offset?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Offset))
			return resObj
		},
	},
	"Go(*text.Shaper)//bitmaps": {
		Doc:   "(*text.Shaper).Bitmaps",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.Shaper
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.Shaper)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//bitmaps: arg 1: expected native of type *text.Shaper")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//bitmaps: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//bitmaps: arg 1: expected native")
			}
			var arg1Val []text.Glyph
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]text.Glyph, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(text.Glyph)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*text.Shaper)//bitmaps: arg 2: block item: expected native of type text.Glyph")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*text.Shaper)//bitmaps: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//bitmaps: arg 2: expected native of type []text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//bitmaps: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//bitmaps: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Bitmaps(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*op.CallOp)")
			return res0Obj
		},
	},
	"Go(*text.Shaper)//layout": {
		Doc:   "(*text.Shaper).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.Shaper
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.Shaper)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//layout: arg 1: expected native of type *text.Shaper")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//layout: arg 1: expected native")
			}
			var arg1Val *text.Parameters
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//layout: arg 2: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//layout: arg 2: expected native")
			}
			var arg2Val io.Reader
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(io.Reader)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//layout: arg 3: expected native of type io.Reader")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//layout: arg 3: expected native")
			}
			arg0Val.Layout(*arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*text.Shaper)//layout-string": {
		Doc:   "(*text.Shaper).LayoutString",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.Shaper
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.Shaper)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//layout-string: arg 1: expected native of type *text.Shaper")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//layout-string: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//layout-string: arg 1: expected native")
			}
			var arg1Val *text.Parameters
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*text.Parameters)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//layout-string: arg 2: expected native of type *text.Parameters")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//layout-string: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//layout-string: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//layout-string: arg 3: expected string")
			}
			arg0Val.LayoutString(*arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*text.Shaper)//next-glyph": {
		Doc:   "(*text.Shaper).NextGlyph",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.Shaper
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.Shaper)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//next-glyph: arg 1: expected native of type *text.Shaper")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//next-glyph: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//next-glyph: arg 1: expected native")
			}
			res0, res1 := arg0Val.NextGlyph()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*text.Glyph)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*text.Shaper)//shape": {
		Doc:   "(*text.Shaper).Shape",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *text.Shaper
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*text.Shaper)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//shape: arg 1: expected native of type *text.Shaper")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//shape: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//shape: arg 1: expected native")
			}
			var arg1Val []text.Glyph
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]text.Glyph, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(text.Glyph)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*text.Shaper)//shape: arg 2: block item: expected native of type text.Glyph")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*text.Shaper)//shape: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]text.Glyph)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//shape: arg 2: expected native of type []text.Glyph")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*text.Shaper)//shape: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*text.Shaper)//shape: arg 2: expected block, native or nil")
			}
			res0 := arg0Val.Shape(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.PathSpec)")
			return res0Obj
		},
	},
	"Go(*transfer.CancelEvent)//implements-event": {
		Doc:   "transfer.CancelEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *transfer.CancelEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*transfer.CancelEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.CancelEvent)//implements-event: arg 1: expected native of type *transfer.CancelEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.CancelEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.CancelEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*transfer.DataEvent)//implements-event": {
		Doc:   "transfer.DataEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *transfer.DataEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*transfer.DataEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//implements-event: arg 1: expected native of type *transfer.DataEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.DataEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*transfer.DataEvent)//open!": {
		Doc:   "Set *transfer.DataEvent Open value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.DataEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.DataEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//open!: arg 1: expected native of type *transfer.DataEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//open!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.DataEvent)//open!: arg 1: expected native")
			}
			var newVal func() io.ReadCloser
			switch fn := arg1.(type) {
			case env.Function:
				if fn.Argsn != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//open!: arg 2: function has invalid number of arguments (expected 0)")
				}
				newVal = func() io.ReadCloser {
					actualFn := fn
					_ = actualFn
					evaldo.CallFunctionArgsN(fn, ps, ps.Ctx)
					var res io.ReadCloser
					switch v := ps.Res.(type) {
					case env.Native:
						var ok bool
						res, ok = v.Value.(io.ReadCloser)
						if !ok {
							fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
								"Go(*transfer.DataEvent)//open!: arg 2: callback result: expected native of type io.ReadCloser",
								actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
								actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
							)
							return res
						}
					default:
						fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
							"Go(*transfer.DataEvent)//open!: arg 2: callback result: expected native",
							actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
							actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
						)
						return res
					}
					return res
				}
			case env.Integer:
				if fn.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//open!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.DataEvent)//open!: arg 2: expected function or nil")
			}
			self.Open = newVal
			return arg0
		},
	},
	"Go(*transfer.DataEvent)//open?": {
		Doc:   "Get *transfer.DataEvent Open value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.DataEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.DataEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//open?: arg 1: expected native of type *transfer.DataEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//open?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.DataEvent)//open?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				res0 := self.Open()
				var res0Obj env.Object
				res0Obj = *env.NewNative(ps.Idx, res0, "Go(io.ReadCloser)")
				return res0Obj
			}, 0, false, false, "Returned func")
			return resObj
		},
	},
	"Go(*transfer.DataEvent)//type!": {
		Doc:   "Set *transfer.DataEvent Type value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.DataEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.DataEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//type!: arg 1: expected native of type *transfer.DataEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//type!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.DataEvent)//type!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.DataEvent)//type!: arg 2: expected string")
			}
			self.Type = newVal
			return arg0
		},
	},
	"Go(*transfer.DataEvent)//type?": {
		Doc:   "Get *transfer.DataEvent Type value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.DataEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.DataEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//type?: arg 1: expected native of type *transfer.DataEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.DataEvent)//type?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.DataEvent)//type?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Type)
			return resObj
		},
	},
	"Go(*transfer.InitiateEvent)//implements-event": {
		Doc:   "transfer.InitiateEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *transfer.InitiateEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*transfer.InitiateEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.InitiateEvent)//implements-event: arg 1: expected native of type *transfer.InitiateEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.InitiateEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.InitiateEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*transfer.OfferCmd)//data!": {
		Doc:   "Set *transfer.OfferCmd Data value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.OfferCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.OfferCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//data!: arg 1: expected native of type *transfer.OfferCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//data!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.OfferCmd)//data!: arg 1: expected native")
			}
			var newVal io.ReadCloser
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(io.ReadCloser)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//data!: arg 2: expected native of type io.ReadCloser")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.OfferCmd)//data!: arg 2: expected native")
			}
			self.Data = newVal
			return arg0
		},
	},
	"Go(*transfer.OfferCmd)//data?": {
		Doc:   "Get *transfer.OfferCmd Data value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.OfferCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.OfferCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//data?: arg 1: expected native of type *transfer.OfferCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//data?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.OfferCmd)//data?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Data, "Go(io.ReadCloser)")
			return resObj
		},
	},
	"Go(*transfer.OfferCmd)//implements-command": {
		Doc:   "transfer.OfferCmd.ImplementsCommand",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *transfer.OfferCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*transfer.OfferCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//implements-command: arg 1: expected native of type *transfer.OfferCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//implements-command: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.OfferCmd)//implements-command: arg 1: expected native")
			}
			(*arg0Val).ImplementsCommand()
			return arg0
		},
	},
	"Go(*transfer.OfferCmd)//tag!": {
		Doc:   "Set *transfer.OfferCmd Tag value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.OfferCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.OfferCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//tag!: arg 1: expected native of type *transfer.OfferCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//tag!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.OfferCmd)//tag!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//tag!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//tag!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//tag!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.OfferCmd)//tag!: arg 2: expected native")
			}
			self.Tag = newVal
			return arg0
		},
	},
	"Go(*transfer.OfferCmd)//tag?": {
		Doc:   "Get *transfer.OfferCmd Tag value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.OfferCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.OfferCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//tag?: arg 1: expected native of type *transfer.OfferCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//tag?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.OfferCmd)//tag?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Tag, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*transfer.OfferCmd)//type!": {
		Doc:   "Set *transfer.OfferCmd Type value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.OfferCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.OfferCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//type!: arg 1: expected native of type *transfer.OfferCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//type!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.OfferCmd)//type!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.OfferCmd)//type!: arg 2: expected string")
			}
			self.Type = newVal
			return arg0
		},
	},
	"Go(*transfer.OfferCmd)//type?": {
		Doc:   "Get *transfer.OfferCmd Type value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.OfferCmd
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.OfferCmd)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//type?: arg 1: expected native of type *transfer.OfferCmd")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.OfferCmd)//type?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.OfferCmd)//type?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Type)
			return resObj
		},
	},
	"Go(*transfer.RequestEvent)//implements-event": {
		Doc:   "transfer.RequestEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *transfer.RequestEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*transfer.RequestEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.RequestEvent)//implements-event: arg 1: expected native of type *transfer.RequestEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.RequestEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.RequestEvent)//implements-event: arg 1: expected native")
			}
			(*arg0Val).ImplementsEvent()
			return arg0
		},
	},
	"Go(*transfer.RequestEvent)//type!": {
		Doc:   "Set *transfer.RequestEvent Type value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.RequestEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.RequestEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.RequestEvent)//type!: arg 1: expected native of type *transfer.RequestEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.RequestEvent)//type!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.RequestEvent)//type!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.RequestEvent)//type!: arg 2: expected string")
			}
			self.Type = newVal
			return arg0
		},
	},
	"Go(*transfer.RequestEvent)//type?": {
		Doc:   "Get *transfer.RequestEvent Type value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.RequestEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.RequestEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.RequestEvent)//type?: arg 1: expected native of type *transfer.RequestEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.RequestEvent)//type?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.RequestEvent)//type?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Type)
			return resObj
		},
	},
	"Go(*transfer.SourceFilter)//implements-filter": {
		Doc:   "transfer.SourceFilter.ImplementsFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *transfer.SourceFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*transfer.SourceFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//implements-filter: arg 1: expected native of type *transfer.SourceFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//implements-filter: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.SourceFilter)//implements-filter: arg 1: expected native")
			}
			(*arg0Val).ImplementsFilter()
			return arg0
		},
	},
	"Go(*transfer.SourceFilter)//target!": {
		Doc:   "Set *transfer.SourceFilter Target value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.SourceFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.SourceFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//target!: arg 1: expected native of type *transfer.SourceFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//target!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.SourceFilter)//target!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//target!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//target!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//target!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.SourceFilter)//target!: arg 2: expected native")
			}
			self.Target = newVal
			return arg0
		},
	},
	"Go(*transfer.SourceFilter)//target?": {
		Doc:   "Get *transfer.SourceFilter Target value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.SourceFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.SourceFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//target?: arg 1: expected native of type *transfer.SourceFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//target?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.SourceFilter)//target?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Target, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*transfer.SourceFilter)//type!": {
		Doc:   "Set *transfer.SourceFilter Type value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.SourceFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.SourceFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//type!: arg 1: expected native of type *transfer.SourceFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//type!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.SourceFilter)//type!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.SourceFilter)//type!: arg 2: expected string")
			}
			self.Type = newVal
			return arg0
		},
	},
	"Go(*transfer.SourceFilter)//type?": {
		Doc:   "Get *transfer.SourceFilter Type value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.SourceFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.SourceFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//type?: arg 1: expected native of type *transfer.SourceFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.SourceFilter)//type?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.SourceFilter)//type?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Type)
			return resObj
		},
	},
	"Go(*transfer.TargetFilter)//implements-filter": {
		Doc:   "transfer.TargetFilter.ImplementsFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *transfer.TargetFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*transfer.TargetFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//implements-filter: arg 1: expected native of type *transfer.TargetFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//implements-filter: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.TargetFilter)//implements-filter: arg 1: expected native")
			}
			(*arg0Val).ImplementsFilter()
			return arg0
		},
	},
	"Go(*transfer.TargetFilter)//target!": {
		Doc:   "Set *transfer.TargetFilter Target value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.TargetFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.TargetFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//target!: arg 1: expected native of type *transfer.TargetFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//target!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.TargetFilter)//target!: arg 1: expected native")
			}
			var newVal event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				newVal, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//target!: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//target!: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//target!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.TargetFilter)//target!: arg 2: expected native")
			}
			self.Target = newVal
			return arg0
		},
	},
	"Go(*transfer.TargetFilter)//target?": {
		Doc:   "Get *transfer.TargetFilter Target value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.TargetFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.TargetFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//target?: arg 1: expected native of type *transfer.TargetFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//target?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.TargetFilter)//target?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = ifaceToNative(ps.Idx, self.Target, "Go(event.Tag)")
			return resObj
		},
	},
	"Go(*transfer.TargetFilter)//type!": {
		Doc:   "Set *transfer.TargetFilter Type value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.TargetFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.TargetFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//type!: arg 1: expected native of type *transfer.TargetFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//type!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.TargetFilter)//type!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.TargetFilter)//type!: arg 2: expected string")
			}
			self.Type = newVal
			return arg0
		},
	},
	"Go(*transfer.TargetFilter)//type?": {
		Doc:   "Get *transfer.TargetFilter Type value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *transfer.TargetFilter
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*transfer.TargetFilter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//type?: arg 1: expected native of type *transfer.TargetFilter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*transfer.TargetFilter)//type?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*transfer.TargetFilter)//type?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Type)
			return resObj
		},
	},
	"Go(*unit.Metric)//dp": {
		Doc:   "unit.Metric.Dp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *unit.Metric
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//dp: arg 1: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//dp: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//dp: arg 1: expected native")
			}
			var arg1Val unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*unit.Metric)//dp: arg 2: expected decimal")
					}
					arg1Val = unit.Dp(u)
				}
			}
			res0 := (*arg0Val).Dp(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*unit.Metric)//dp-to-sp": {
		Doc:   "unit.Metric.DpToSp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *unit.Metric
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//dp-to-sp: arg 1: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//dp-to-sp: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//dp-to-sp: arg 1: expected native")
			}
			var arg1Val unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*unit.Metric)//dp-to-sp: arg 2: expected decimal")
					}
					arg1Val = unit.Dp(u)
				}
			}
			res0 := (*arg0Val).DpToSp(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(unit.Sp)")
			return res0Obj
		},
	},
	"Go(*unit.Metric)//px-per-dp!": {
		Doc:   "Set *unit.Metric PxPerDp value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *unit.Metric
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-per-dp!: arg 1: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-per-dp!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//px-per-dp!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//px-per-dp!: arg 2: expected decimal")
			}
			self.PxPerDp = newVal
			return arg0
		},
	},
	"Go(*unit.Metric)//px-per-dp?": {
		Doc:   "Get *unit.Metric PxPerDp value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *unit.Metric
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-per-dp?: arg 1: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-per-dp?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//px-per-dp?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.PxPerDp))
			return resObj
		},
	},
	"Go(*unit.Metric)//px-per-sp!": {
		Doc:   "Set *unit.Metric PxPerSp value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *unit.Metric
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-per-sp!: arg 1: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-per-sp!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//px-per-sp!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//px-per-sp!: arg 2: expected decimal")
			}
			self.PxPerSp = newVal
			return arg0
		},
	},
	"Go(*unit.Metric)//px-per-sp?": {
		Doc:   "Get *unit.Metric PxPerSp value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *unit.Metric
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-per-sp?: arg 1: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-per-sp?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//px-per-sp?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.PxPerSp))
			return resObj
		},
	},
	"Go(*unit.Metric)//px-to-dp": {
		Doc:   "unit.Metric.PxToDp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *unit.Metric
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-to-dp: arg 1: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-to-dp: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//px-to-dp: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//px-to-dp: arg 2: expected integer")
			}
			res0 := (*arg0Val).PxToDp(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(float32(res0)))
			return res0Obj
		},
	},
	"Go(*unit.Metric)//px-to-sp": {
		Doc:   "unit.Metric.PxToSp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *unit.Metric
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-to-sp: arg 1: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//px-to-sp: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//px-to-sp: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//px-to-sp: arg 2: expected integer")
			}
			res0 := (*arg0Val).PxToSp(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(unit.Sp)")
			return res0Obj
		},
	},
	"Go(*unit.Metric)//sp": {
		Doc:   "unit.Metric.Sp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *unit.Metric
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//sp: arg 1: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//sp: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//sp: arg 1: expected native")
			}
			var arg1Val unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//sp: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//sp: arg 2: expected native")
			}
			res0 := (*arg0Val).Sp(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*unit.Metric)//sp-to-dp": {
		Doc:   "unit.Metric.SpToDp",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *unit.Metric
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*unit.Metric)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//sp-to-dp: arg 1: expected native of type *unit.Metric")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//sp-to-dp: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//sp-to-dp: arg 1: expected native")
			}
			var arg1Val unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*unit.Metric)//sp-to-dp: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*unit.Metric)//sp-to-dp: arg 2: expected native")
			}
			res0 := (*arg0Val).SpToDp(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(float32(res0)))
			return res0Obj
		},
	},
	"Go(*widget.Bool)//history": {
		Doc:   "(*widget.Bool).History",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//history: arg 1: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//history: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Bool)//history: arg 1: expected native")
			}
			res0 := arg0Val.History()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(widget.Press)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"Go(*widget.Bool)//hovered": {
		Doc:   "(*widget.Bool).Hovered",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//hovered: arg 1: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//hovered: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Bool)//hovered: arg 1: expected native")
			}
			res0 := arg0Val.Hovered()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Bool)//layout": {
		Doc:   "(*widget.Bool).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//layout: arg 1: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Bool)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Bool)//layout: arg 2: expected native")
			}
			var arg2Val layout.Widget
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg2.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Bool)//layout: arg 3: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*widget.Bool)//layout: arg 3: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*widget.Bool)//layout: arg 3: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Bool)//layout: arg 3: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Bool)//layout: arg 3: expected function or nil")
					}
					arg2Val = layout.Widget(u)
				}
			}
			res0 := arg0Val.Layout(*arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*widget.Bool)//pressed": {
		Doc:   "(*widget.Bool).Pressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//pressed: arg 1: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Bool)//pressed: arg 1: expected native")
			}
			res0 := arg0Val.Pressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Bool)//update": {
		Doc:   "(*widget.Bool).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//update: arg 1: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Bool)//update: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//update: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Bool)//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Bool)//value!": {
		Doc:   "Set *widget.Bool Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//value!: arg 1: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//value!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Bool)//value!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Bool)//value!: arg 2: expected integer")
			}
			self.Value = newVal
			return arg0
		},
	},
	"Go(*widget.Bool)//value?": {
		Doc:   "Get *widget.Bool Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Bool
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//value?: arg 1: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Bool)//value?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Bool)//value?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Value))
			return resObj
		},
	},
	"Go(*widget.Border)//color!": {
		Doc:   "Set *widget.Border Color value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Border
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Border)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//color!: arg 1: expected native of type *widget.Border")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//color!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Border)//color!: arg 1: expected native")
			}
			var newVal color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//color!: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Border)//color!: arg 2: expected native")
			}
			self.Color = newVal
			return arg0
		},
	},
	"Go(*widget.Border)//color?": {
		Doc:   "Get *widget.Border Color value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Border
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Border)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//color?: arg 1: expected native of type *widget.Border")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//color?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Border)//color?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Color, "Go(color.NRGBA)")
			return resObj
		},
	},
	"Go(*widget.Border)//corner-radius!": {
		Doc:   "Set *widget.Border CornerRadius value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Border
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Border)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//corner-radius!: arg 1: expected native of type *widget.Border")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//corner-radius!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Border)//corner-radius!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Border)//corner-radius!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.CornerRadius = newVal
			return arg0
		},
	},
	"Go(*widget.Border)//corner-radius?": {
		Doc:   "Get *widget.Border CornerRadius value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Border
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Border)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//corner-radius?: arg 1: expected native of type *widget.Border")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//corner-radius?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Border)//corner-radius?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.CornerRadius)))
			return resObj
		},
	},
	"Go(*widget.Border)//layout": {
		Doc:   "widget.Border.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Border
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Border)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//layout: arg 1: expected native of type *widget.Border")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Border)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Border)//layout: arg 2: expected native")
			}
			var arg2Val layout.Widget
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg2.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Border)//layout: arg 3: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*widget.Border)//layout: arg 3: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*widget.Border)//layout: arg 3: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Border)//layout: arg 3: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Border)//layout: arg 3: expected function or nil")
					}
					arg2Val = layout.Widget(u)
				}
			}
			res0 := (*arg0Val).Layout(*arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*widget.Border)//width!": {
		Doc:   "Set *widget.Border Width value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Border
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Border)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//width!: arg 1: expected native of type *widget.Border")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//width!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Border)//width!: arg 1: expected native")
			}
			var newVal unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Border)//width!: arg 2: expected decimal")
					}
					newVal = unit.Dp(u)
				}
			}
			self.Width = newVal
			return arg0
		},
	},
	"Go(*widget.Border)//width?": {
		Doc:   "Get *widget.Border Width value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Border
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Border)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//width?: arg 1: expected native of type *widget.Border")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Border)//width?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Border)//width?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(float32(self.Width)))
			return resObj
		},
	},
	"Go(*widget.Click)//modifiers!": {
		Doc:   "Set *widget.Click Modifiers value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Click
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Click)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Click)//modifiers!: arg 1: expected native of type *widget.Click")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Click)//modifiers!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Click)//modifiers!: arg 1: expected native")
			}
			var newVal key.Modifiers
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.Modifiers
				if natOk {
					natVal, natValOk = nat.Value.(key.Modifiers)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Click)//modifiers!: arg 2: expected integer")
					}
					newVal = key.Modifiers(u)
				}
			}
			self.Modifiers = newVal
			return arg0
		},
	},
	"Go(*widget.Click)//modifiers?": {
		Doc:   "Get *widget.Click Modifiers value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Click
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Click)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Click)//modifiers?: arg 1: expected native of type *widget.Click")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Click)//modifiers?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Click)//modifiers?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(self.Modifiers)))
			return resObj
		},
	},
	"Go(*widget.Click)//num-clicks!": {
		Doc:   "Set *widget.Click NumClicks value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Click
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Click)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Click)//num-clicks!: arg 1: expected native of type *widget.Click")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Click)//num-clicks!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Click)//num-clicks!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Click)//num-clicks!: arg 2: expected integer")
			}
			self.NumClicks = newVal
			return arg0
		},
	},
	"Go(*widget.Click)//num-clicks?": {
		Doc:   "Get *widget.Click NumClicks value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Click
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Click)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Click)//num-clicks?: arg 1: expected native of type *widget.Click")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Click)//num-clicks?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Click)//num-clicks?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.NumClicks))
			return resObj
		},
	},
	"Go(*widget.Clickable)//click": {
		Doc:   "(*widget.Clickable).Click",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Clickable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//click: arg 1: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//click: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Clickable)//click: arg 1: expected native")
			}
			arg0Val.Click()
			return arg0
		},
	},
	"Go(*widget.Clickable)//clicked": {
		Doc:   "(*widget.Clickable).Clicked",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Clickable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//clicked: arg 1: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//clicked: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Clickable)//clicked: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//clicked: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//clicked: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Clickable)//clicked: arg 2: expected native")
			}
			res0 := arg0Val.Clicked(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Clickable)//history": {
		Doc:   "(*widget.Clickable).History",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Clickable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//history: arg 1: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//history: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Clickable)//history: arg 1: expected native")
			}
			res0 := arg0Val.History()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(widget.Press)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"Go(*widget.Clickable)//hovered": {
		Doc:   "(*widget.Clickable).Hovered",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Clickable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//hovered: arg 1: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//hovered: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Clickable)//hovered: arg 1: expected native")
			}
			res0 := arg0Val.Hovered()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Clickable)//layout": {
		Doc:   "(*widget.Clickable).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Clickable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//layout: arg 1: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Clickable)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Clickable)//layout: arg 2: expected native")
			}
			var arg2Val layout.Widget
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg2.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Clickable)//layout: arg 3: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*widget.Clickable)//layout: arg 3: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*widget.Clickable)//layout: arg 3: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Clickable)//layout: arg 3: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Clickable)//layout: arg 3: expected function or nil")
					}
					arg2Val = layout.Widget(u)
				}
			}
			res0 := arg0Val.Layout(*arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*widget.Clickable)//pressed": {
		Doc:   "(*widget.Clickable).Pressed",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Clickable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//pressed: arg 1: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//pressed: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Clickable)//pressed: arg 1: expected native")
			}
			res0 := arg0Val.Pressed()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Clickable)//update": {
		Doc:   "(*widget.Clickable).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Clickable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//update: arg 1: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Clickable)//update: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//update: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Clickable)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Clickable)//update: arg 2: expected native")
			}
			res0, res1 := arg0Val.Update(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*widget.Click)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*widget.Decorations)//clickable": {
		Doc:   "(*widget.Decorations).Clickable",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Decorations
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Decorations)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//clickable: arg 1: expected native of type *widget.Decorations")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//clickable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Decorations)//clickable: arg 1: expected native")
			}
			var arg1Val system.Action
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal system.Action
				if natOk {
					natVal, natValOk = nat.Value.(system.Action)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint
					if v, ok := arg1.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Decorations)//clickable: arg 2: expected integer")
					}
					arg1Val = system.Action(u)
				}
			}
			res0 := arg0Val.Clickable(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*widget.Clickable)")
			return res0Obj
		},
	},
	"Go(*widget.Decorations)//layout-move": {
		Doc:   "(*widget.Decorations).LayoutMove",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Decorations
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Decorations)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//layout-move: arg 1: expected native of type *widget.Decorations")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//layout-move: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Decorations)//layout-move: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//layout-move: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//layout-move: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Decorations)//layout-move: arg 2: expected native")
			}
			var arg2Val layout.Widget
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg2.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Decorations)//layout-move: arg 3: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*widget.Decorations)//layout-move: arg 3: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*widget.Decorations)//layout-move: arg 3: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Decorations)//layout-move: arg 3: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Decorations)//layout-move: arg 3: expected function or nil")
					}
					arg2Val = layout.Widget(u)
				}
			}
			res0 := arg0Val.LayoutMove(*arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*widget.Decorations)//maximized": {
		Doc:   "(*widget.Decorations).Maximized",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Decorations
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Decorations)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//maximized: arg 1: expected native of type *widget.Decorations")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//maximized: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Decorations)//maximized: arg 1: expected native")
			}
			res0 := arg0Val.Maximized()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Decorations)//perform": {
		Doc:   "(*widget.Decorations).Perform",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Decorations
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Decorations)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//perform: arg 1: expected native of type *widget.Decorations")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//perform: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Decorations)//perform: arg 1: expected native")
			}
			var arg1Val system.Action
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal system.Action
				if natOk {
					natVal, natValOk = nat.Value.(system.Action)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint
					if v, ok := arg1.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Decorations)//perform: arg 2: expected integer")
					}
					arg1Val = system.Action(u)
				}
			}
			arg0Val.Perform(arg1Val)
			return arg0
		},
	},
	"Go(*widget.Decorations)//update": {
		Doc:   "(*widget.Decorations).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Decorations
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Decorations)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//update: arg 1: expected native of type *widget.Decorations")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Decorations)//update: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//update: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Decorations)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Decorations)//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(uint(res0)))
			return res0Obj
		},
	},
	"Go(*widget.Draggable)//dragging": {
		Doc:   "(*widget.Draggable).Dragging",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Draggable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//dragging: arg 1: expected native of type *widget.Draggable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//dragging: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//dragging: arg 1: expected native")
			}
			res0 := arg0Val.Dragging()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Draggable)//layout": {
		Doc:   "(*widget.Draggable).Layout",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Draggable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//layout: arg 1: expected native of type *widget.Draggable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//layout: arg 2: expected native")
			}
			var arg2Val layout.Widget
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg2.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Draggable)//layout: arg 3: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*widget.Draggable)//layout: arg 3: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*widget.Draggable)//layout: arg 3: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Draggable)//layout: arg 3: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Draggable)//layout: arg 3: expected function or nil")
					}
					arg2Val = layout.Widget(u)
				}
			}
			var arg3Val layout.Widget
			{
				nat, natOk := arg3.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg3Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg3.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Draggable)//layout: arg 4: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*widget.Draggable)//layout: arg 4: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*widget.Draggable)//layout: arg 4: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Draggable)//layout: arg 4: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Draggable)//layout: arg 4: expected function or nil")
					}
					arg3Val = layout.Widget(u)
				}
			}
			res0 := arg0Val.Layout(*arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*widget.Draggable)//offer": {
		Doc:   "(*widget.Draggable).Offer",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Draggable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//offer: arg 1: expected native of type *widget.Draggable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//offer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//offer: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//offer: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//offer: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//offer: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//offer: arg 3: expected string")
			}
			var arg3Val io.ReadCloser
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(io.ReadCloser)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//offer: arg 4: expected native of type io.ReadCloser")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//offer: arg 4: expected native")
			}
			arg0Val.Offer(*arg1Val, arg2Val, arg3Val)
			return arg0
		},
	},
	"Go(*widget.Draggable)//pos": {
		Doc:   "(*widget.Draggable).Pos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Draggable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//pos: arg 1: expected native of type *widget.Draggable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//pos: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//pos: arg 1: expected native")
			}
			res0 := arg0Val.Pos()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"Go(*widget.Draggable)//type!": {
		Doc:   "Set *widget.Draggable Type value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Draggable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//type!: arg 1: expected native of type *widget.Draggable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//type!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//type!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//type!: arg 2: expected string")
			}
			self.Type = newVal
			return arg0
		},
	},
	"Go(*widget.Draggable)//type?": {
		Doc:   "Get *widget.Draggable Type value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Draggable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//type?: arg 1: expected native of type *widget.Draggable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//type?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//type?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Type)
			return resObj
		},
	},
	"Go(*widget.Draggable)//update": {
		Doc:   "(*widget.Draggable).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Draggable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Draggable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//update: arg 1: expected native of type *widget.Draggable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//update: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//update: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Draggable)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Draggable)//update: arg 2: expected native")
			}
			res0, res1 := arg0Val.Update(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*widget.Editor)//alignment!": {
		Doc:   "Set *widget.Editor Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//alignment!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//alignment!: arg 1: expected native")
			}
			var newVal text.Alignment
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(text.Alignment)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Editor)//alignment!: arg 2: expected integer")
					}
					newVal = text.Alignment(u)
				}
			}
			self.Alignment = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//alignment?": {
		Doc:   "Get *widget.Editor Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//alignment?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Alignment)))
			return resObj
		},
	},
	"Go(*widget.Editor)//caret-coords": {
		Doc:   "(*widget.Editor).CaretCoords",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//caret-coords: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//caret-coords: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//caret-coords: arg 1: expected native")
			}
			res0 := arg0Val.CaretCoords()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"Go(*widget.Editor)//caret-pos": {
		Doc:   "(*widget.Editor).CaretPos",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//caret-pos: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//caret-pos: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//caret-pos: arg 1: expected native")
			}
			res0, res1 := arg0Val.CaretPos()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*widget.Editor)//clear-selection": {
		Doc:   "(*widget.Editor).ClearSelection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//clear-selection: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//clear-selection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//clear-selection: arg 1: expected native")
			}
			arg0Val.ClearSelection()
			return arg0
		},
	},
	"Go(*widget.Editor)//delete": {
		Doc:   "(*widget.Editor).Delete",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//delete: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//delete: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//delete: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//delete: arg 2: expected integer")
			}
			res0 := arg0Val.Delete(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Editor)//filter!": {
		Doc:   "Set *widget.Editor Filter value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//filter!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//filter!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//filter!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//filter!: arg 2: expected string")
			}
			self.Filter = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//filter?": {
		Doc:   "Get *widget.Editor Filter value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//filter?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//filter?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//filter?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Filter)
			return resObj
		},
	},
	"Go(*widget.Editor)//input-hint!": {
		Doc:   "Set *widget.Editor InputHint value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//input-hint!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//input-hint!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//input-hint!: arg 1: expected native")
			}
			var newVal key.InputHint
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.InputHint
				if natOk {
					natVal, natValOk = nat.Value.(key.InputHint)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Editor)//input-hint!: arg 2: expected integer")
					}
					newVal = key.InputHint(u)
				}
			}
			self.InputHint = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//input-hint?": {
		Doc:   "Get *widget.Editor InputHint value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//input-hint?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//input-hint?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//input-hint?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.InputHint)))
			return resObj
		},
	},
	"Go(*widget.Editor)//insert": {
		Doc:   "(*widget.Editor).Insert",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//insert: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//insert: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//insert: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//insert: arg 2: expected string")
			}
			res0 := arg0Val.Insert(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Editor)//len": {
		Doc:   "(*widget.Editor).Len",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//len: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//len: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//len: arg 1: expected native")
			}
			res0 := arg0Val.Len()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Editor)//line-height!": {
		Doc:   "Set *widget.Editor LineHeight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//line-height!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//line-height!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//line-height!: arg 1: expected native")
			}
			var newVal unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//line-height!: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//line-height!: arg 2: expected native")
			}
			self.LineHeight = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//line-height-scale!": {
		Doc:   "Set *widget.Editor LineHeightScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//line-height-scale!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//line-height-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//line-height-scale!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//line-height-scale!: arg 2: expected decimal")
			}
			self.LineHeightScale = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//line-height-scale?": {
		Doc:   "Get *widget.Editor LineHeightScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//line-height-scale?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//line-height-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//line-height-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineHeightScale))
			return resObj
		},
	},
	"Go(*widget.Editor)//line-height?": {
		Doc:   "Get *widget.Editor LineHeight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//line-height?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//line-height?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//line-height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.LineHeight, "Go(unit.Sp)")
			return resObj
		},
	},
	"Go(*widget.Editor)//mask!": {
		Doc:   "Set *widget.Editor Mask value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//mask!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//mask!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//mask!: arg 1: expected native")
			}
			var newVal rune
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(rune)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//mask!: arg 2: expected native of type rune")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//mask!: arg 2: expected native")
			}
			self.Mask = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//mask?": {
		Doc:   "Get *widget.Editor Mask value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//mask?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//mask?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//mask?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Mask, "Go(rune)")
			return resObj
		},
	},
	"Go(*widget.Editor)//max-len!": {
		Doc:   "Set *widget.Editor MaxLen value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//max-len!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//max-len!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//max-len!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//max-len!: arg 2: expected integer")
			}
			self.MaxLen = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//max-len?": {
		Doc:   "Get *widget.Editor MaxLen value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//max-len?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//max-len?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//max-len?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.MaxLen))
			return resObj
		},
	},
	"Go(*widget.Editor)//move-caret": {
		Doc:   "(*widget.Editor).MoveCaret",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//move-caret: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//move-caret: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//move-caret: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//move-caret: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//move-caret: arg 3: expected integer")
			}
			arg0Val.MoveCaret(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*widget.Editor)//read": {
		Doc:   "(*widget.Editor).Read",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//read: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//read: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//read: arg 1: expected native")
			}
			var arg1Val []byte
			switch v := arg1.(type) {
			case env.Block:
				arg1Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg1Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Editor)//read: arg 2: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Editor)//read: arg 2: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//read: arg 2: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//read: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//read: arg 2: expected block, native or nil")
			}
			res0, resErr := arg0Val.Read(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*widget.Editor)//read-only!": {
		Doc:   "Set *widget.Editor ReadOnly value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//read-only!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//read-only!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//read-only!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//read-only!: arg 2: expected integer")
			}
			self.ReadOnly = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//read-only?": {
		Doc:   "Get *widget.Editor ReadOnly value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//read-only?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//read-only?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//read-only?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ReadOnly))
			return resObj
		},
	},
	"Go(*widget.Editor)//regions": {
		Doc:   "(*widget.Editor).Regions",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//regions: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//regions: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//regions: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//regions: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//regions: arg 3: expected integer")
			}
			var arg3Val []widget.Region
			switch v := arg3.(type) {
			case env.Block:
				arg3Val = make([]widget.Region, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg3Val[i], ok = v.Value.(widget.Region)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Editor)//regions: arg 4: block item: expected native of type widget.Region")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Editor)//regions: arg 4: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.([]widget.Region)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//regions: arg 4: expected native of type []widget.Region")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//regions: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//regions: arg 4: expected block, native or nil")
			}
			res0 := arg0Val.Regions(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(widget.Region)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"Go(*widget.Editor)//seek": {
		Doc:   "(*widget.Editor).Seek",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//seek: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//seek: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//seek: arg 1: expected native")
			}
			var arg1Val int64
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int64(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//seek: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//seek: arg 3: expected integer")
			}
			res0, resErr := arg0Val.Seek(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*widget.Editor)//selected-text": {
		Doc:   "(*widget.Editor).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//selected-text: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*widget.Editor)//selection": {
		Doc:   "(*widget.Editor).Selection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//selection: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//selection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//selection: arg 1: expected native")
			}
			res0, res1 := arg0Val.Selection()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*widget.Editor)//selection-len": {
		Doc:   "(*widget.Editor).SelectionLen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//selection-len: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//selection-len: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//selection-len: arg 1: expected native")
			}
			res0 := arg0Val.SelectionLen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Editor)//set-caret": {
		Doc:   "(*widget.Editor).SetCaret",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//set-caret: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//set-caret: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//set-caret: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//set-caret: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//set-caret: arg 3: expected integer")
			}
			arg0Val.SetCaret(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*widget.Editor)//set-text": {
		Doc:   "(*widget.Editor).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//set-text: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//set-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//set-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//set-text: arg 2: expected string")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"Go(*widget.Editor)//single-line!": {
		Doc:   "Set *widget.Editor SingleLine value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//single-line!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//single-line!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//single-line!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//single-line!: arg 2: expected integer")
			}
			self.SingleLine = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//single-line?": {
		Doc:   "Get *widget.Editor SingleLine value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//single-line?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//single-line?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//single-line?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.SingleLine))
			return resObj
		},
	},
	"Go(*widget.Editor)//submit!": {
		Doc:   "Set *widget.Editor Submit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//submit!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//submit!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//submit!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//submit!: arg 2: expected integer")
			}
			self.Submit = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//submit?": {
		Doc:   "Get *widget.Editor Submit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//submit?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//submit?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//submit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Submit))
			return resObj
		},
	},
	"Go(*widget.Editor)//text": {
		Doc:   "(*widget.Editor).Text",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//text: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//text: arg 1: expected native")
			}
			res0 := arg0Val.Text()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*widget.Editor)//update": {
		Doc:   "(*widget.Editor).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//update: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//update: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//update: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//update: arg 2: expected native")
			}
			res0, res1 := arg0Val.Update(*arg1Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(widget.EditorEvent)")
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*widget.Editor)//wrap-policy!": {
		Doc:   "Set *widget.Editor WrapPolicy value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//wrap-policy!: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//wrap-policy!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//wrap-policy!: arg 1: expected native")
			}
			var newVal text.WrapPolicy
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.WrapPolicy
				if natOk {
					natVal, natValOk = nat.Value.(text.WrapPolicy)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Editor)//wrap-policy!: arg 2: expected integer")
					}
					newVal = text.WrapPolicy(u)
				}
			}
			self.WrapPolicy = newVal
			return arg0
		},
	},
	"Go(*widget.Editor)//wrap-policy?": {
		Doc:   "Get *widget.Editor WrapPolicy value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//wrap-policy?: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//wrap-policy?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//wrap-policy?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.WrapPolicy)))
			return resObj
		},
	},
	"Go(*widget.Editor)//write-to": {
		Doc:   "(*widget.Editor).WriteTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Editor
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//write-to: arg 1: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//write-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//write-to: arg 1: expected native")
			}
			var arg1Val io.Writer
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(io.Writer)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Editor)//write-to: arg 2: expected native of type io.Writer")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Editor)//write-to: arg 2: expected native")
			}
			res0, resErr := arg0Val.WriteTo(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"Go(*widget.Enum)//focused": {
		Doc:   "(*widget.Enum).Focused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Enum
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Enum)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//focused: arg 1: expected native of type *widget.Enum")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//focused: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Enum)//focused: arg 1: expected native")
			}
			res0, res1 := arg0Val.Focused()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*widget.Enum)//hovered": {
		Doc:   "(*widget.Enum).Hovered",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Enum
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Enum)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//hovered: arg 1: expected native of type *widget.Enum")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//hovered: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Enum)//hovered: arg 1: expected native")
			}
			res0, res1 := arg0Val.Hovered()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var res1Obj env.Object
			res1Obj = *env.NewInteger(boolToInt64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*widget.Enum)//layout": {
		Doc:   "(*widget.Enum).Layout",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Enum
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Enum)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//layout: arg 1: expected native of type *widget.Enum")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Enum)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Enum)//layout: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Enum)//layout: arg 3: expected string")
			}
			var arg3Val layout.Widget
			{
				nat, natOk := arg3.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg3Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg3.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Enum)//layout: arg 4: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*widget.Enum)//layout: arg 4: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*widget.Enum)//layout: arg 4: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Enum)//layout: arg 4: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Enum)//layout: arg 4: expected function or nil")
					}
					arg3Val = layout.Widget(u)
				}
			}
			res0 := arg0Val.Layout(*arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*widget.Enum)//update": {
		Doc:   "(*widget.Enum).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Enum
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Enum)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//update: arg 1: expected native of type *widget.Enum")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Enum)//update: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//update: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Enum)//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Enum)//value!": {
		Doc:   "Set *widget.Enum Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Enum
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Enum)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//value!: arg 1: expected native of type *widget.Enum")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//value!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Enum)//value!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Enum)//value!: arg 2: expected string")
			}
			self.Value = newVal
			return arg0
		},
	},
	"Go(*widget.Enum)//value?": {
		Doc:   "Get *widget.Enum Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Enum
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Enum)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//value?: arg 1: expected native of type *widget.Enum")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Enum)//value?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Enum)//value?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Value)
			return resObj
		},
	},
	"Go(*widget.Float)//dragging": {
		Doc:   "(*widget.Float).Dragging",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//dragging: arg 1: expected native of type *widget.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//dragging: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Float)//dragging: arg 1: expected native")
			}
			res0 := arg0Val.Dragging()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Float)//layout": {
		Doc:   "(*widget.Float).Layout",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//layout: arg 1: expected native of type *widget.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Float)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Float)//layout: arg 2: expected native")
			}
			var arg2Val layout.Axis
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u uint8
					if v, ok := arg2.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Float)//layout: arg 3: expected integer")
					}
					arg2Val = layout.Axis(u)
				}
			}
			var arg3Val unit.Dp
			{
				nat, natOk := arg3.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg3Val = natVal
				} else {
					var u float32
					if v, ok := arg3.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Float)//layout: arg 4: expected decimal")
					}
					arg3Val = unit.Dp(u)
				}
			}
			res0 := arg0Val.Layout(*arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*widget.Float)//update": {
		Doc:   "(*widget.Float).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//update: arg 1: expected native of type *widget.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Float)//update: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//update: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Float)//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Float)//value!": {
		Doc:   "Set *widget.Float Value value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//value!: arg 1: expected native of type *widget.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//value!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Float)//value!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Float)//value!: arg 2: expected decimal")
			}
			self.Value = newVal
			return arg0
		},
	},
	"Go(*widget.Float)//value?": {
		Doc:   "Get *widget.Float Value value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Float
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//value?: arg 1: expected native of type *widget.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Float)//value?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Float)//value?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Value))
			return resObj
		},
	},
	"Go(*widget.Icon)//layout": {
		Doc:   "(*widget.Icon).Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Icon
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Icon)//layout: arg 1: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Icon)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Icon)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Icon)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Icon)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Icon)//layout: arg 2: expected native")
			}
			var arg2Val color.NRGBA
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Icon)//layout: arg 3: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Icon)//layout: arg 3: expected native")
			}
			res0 := arg0Val.Layout(*arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*widget.Image)//fit!": {
		Doc:   "Set *widget.Image Fit value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//fit!: arg 1: expected native of type *widget.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//fit!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//fit!: arg 1: expected native")
			}
			var newVal widget.Fit
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal widget.Fit
				if natOk {
					natVal, natValOk = nat.Value.(widget.Fit)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Image)//fit!: arg 2: expected integer")
					}
					newVal = widget.Fit(u)
				}
			}
			self.Fit = newVal
			return arg0
		},
	},
	"Go(*widget.Image)//fit?": {
		Doc:   "Get *widget.Image Fit value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//fit?: arg 1: expected native of type *widget.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//fit?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//fit?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Fit)))
			return resObj
		},
	},
	"Go(*widget.Image)//layout": {
		Doc:   "widget.Image.Layout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//layout: arg 1: expected native of type *widget.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//layout: arg 2: expected native")
			}
			res0 := (*arg0Val).Layout(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*widget.Image)//position!": {
		Doc:   "Set *widget.Image Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//position!: arg 1: expected native of type *widget.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//position!: arg 1: expected native")
			}
			var newVal layout.Direction
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Direction
				if natOk {
					natVal, natValOk = nat.Value.(layout.Direction)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Image)//position!: arg 2: expected integer")
					}
					newVal = layout.Direction(u)
				}
			}
			self.Position = newVal
			return arg0
		},
	},
	"Go(*widget.Image)//position?": {
		Doc:   "Get *widget.Image Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//position?: arg 1: expected native of type *widget.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Position)))
			return resObj
		},
	},
	"Go(*widget.Image)//scale!": {
		Doc:   "Set *widget.Image Scale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//scale!: arg 1: expected native of type *widget.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//scale!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//scale!: arg 2: expected decimal")
			}
			self.Scale = newVal
			return arg0
		},
	},
	"Go(*widget.Image)//scale?": {
		Doc:   "Get *widget.Image Scale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//scale?: arg 1: expected native of type *widget.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.Scale))
			return resObj
		},
	},
	"Go(*widget.Image)//src!": {
		Doc:   "Set *widget.Image Src value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//src!: arg 1: expected native of type *widget.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//src!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//src!: arg 1: expected native")
			}
			var newVal *paint.ImageOp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*paint.ImageOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//src!: arg 2: expected native of type *paint.ImageOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//src!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//src!: arg 2: expected native")
			}
			self.Src = *newVal
			return arg0
		},
	},
	"Go(*widget.Image)//src?": {
		Doc:   "Get *widget.Image Src value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//src?: arg 1: expected native of type *widget.Image")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Image)//src?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Image)//src?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Src, "Go(*paint.ImageOp)")
			return resObj
		},
	},
	"Go(*widget.Label)//alignment!": {
		Doc:   "Set *widget.Label Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//alignment!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//alignment!: arg 1: expected native")
			}
			var newVal text.Alignment
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(text.Alignment)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Label)//alignment!: arg 2: expected integer")
					}
					newVal = text.Alignment(u)
				}
			}
			self.Alignment = newVal
			return arg0
		},
	},
	"Go(*widget.Label)//alignment?": {
		Doc:   "Get *widget.Label Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//alignment?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Alignment)))
			return resObj
		},
	},
	"Go(*widget.Label)//line-height!": {
		Doc:   "Set *widget.Label LineHeight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//line-height!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//line-height!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//line-height!: arg 1: expected native")
			}
			var newVal unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//line-height!: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//line-height!: arg 2: expected native")
			}
			self.LineHeight = newVal
			return arg0
		},
	},
	"Go(*widget.Label)//line-height-scale!": {
		Doc:   "Set *widget.Label LineHeightScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//line-height-scale!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//line-height-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//line-height-scale!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//line-height-scale!: arg 2: expected decimal")
			}
			self.LineHeightScale = newVal
			return arg0
		},
	},
	"Go(*widget.Label)//line-height-scale?": {
		Doc:   "Get *widget.Label LineHeightScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//line-height-scale?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//line-height-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//line-height-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineHeightScale))
			return resObj
		},
	},
	"Go(*widget.Label)//line-height?": {
		Doc:   "Get *widget.Label LineHeight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//line-height?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//line-height?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//line-height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.LineHeight, "Go(unit.Sp)")
			return resObj
		},
	},
	"Go(*widget.Label)//max-lines!": {
		Doc:   "Set *widget.Label MaxLines value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//max-lines!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//max-lines!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//max-lines!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//max-lines!: arg 2: expected integer")
			}
			self.MaxLines = newVal
			return arg0
		},
	},
	"Go(*widget.Label)//max-lines?": {
		Doc:   "Get *widget.Label MaxLines value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//max-lines?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//max-lines?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//max-lines?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.MaxLines))
			return resObj
		},
	},
	"Go(*widget.Label)//truncator!": {
		Doc:   "Set *widget.Label Truncator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//truncator!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//truncator!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//truncator!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//truncator!: arg 2: expected string")
			}
			self.Truncator = newVal
			return arg0
		},
	},
	"Go(*widget.Label)//truncator?": {
		Doc:   "Get *widget.Label Truncator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//truncator?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//truncator?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//truncator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Truncator)
			return resObj
		},
	},
	"Go(*widget.Label)//wrap-policy!": {
		Doc:   "Set *widget.Label WrapPolicy value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//wrap-policy!: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//wrap-policy!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//wrap-policy!: arg 1: expected native")
			}
			var newVal text.WrapPolicy
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.WrapPolicy
				if natOk {
					natVal, natValOk = nat.Value.(text.WrapPolicy)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Label)//wrap-policy!: arg 2: expected integer")
					}
					newVal = text.WrapPolicy(u)
				}
			}
			self.WrapPolicy = newVal
			return arg0
		},
	},
	"Go(*widget.Label)//wrap-policy?": {
		Doc:   "Get *widget.Label WrapPolicy value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Label
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Label)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//wrap-policy?: arg 1: expected native of type *widget.Label")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Label)//wrap-policy?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Label)//wrap-policy?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.WrapPolicy)))
			return resObj
		},
	},
	"Go(*widget.List)//add-drag": {
		Doc:   "(*widget.List).AddDrag",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-drag: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-drag: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//add-drag: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-drag: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-drag: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//add-drag: arg 2: expected native")
			}
			arg0Val.AddDrag(arg1Val)
			return arg0
		},
	},
	"Go(*widget.List)//add-indicator": {
		Doc:   "(*widget.List).AddIndicator",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-indicator: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-indicator: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//add-indicator: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-indicator: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-indicator: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//add-indicator: arg 2: expected native")
			}
			arg0Val.AddIndicator(arg1Val)
			return arg0
		},
	},
	"Go(*widget.List)//add-track": {
		Doc:   "(*widget.List).AddTrack",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-track: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-track: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//add-track: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-track: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//add-track: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//add-track: arg 2: expected native")
			}
			arg0Val.AddTrack(arg1Val)
			return arg0
		},
	},
	"Go(*widget.List)//alignment!": {
		Doc:   "Set *widget.List Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//alignment!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//alignment!: arg 1: expected native")
			}
			var newVal layout.Alignment
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(layout.Alignment)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.List)//alignment!: arg 2: expected integer")
					}
					newVal = layout.Alignment(u)
				}
			}
			self.Alignment = newVal
			return arg0
		},
	},
	"Go(*widget.List)//alignment?": {
		Doc:   "Get *widget.List Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//alignment?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Alignment)))
			return resObj
		},
	},
	"Go(*widget.List)//axis!": {
		Doc:   "Set *widget.List Axis value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//axis!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//axis!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//axis!: arg 1: expected native")
			}
			var newVal layout.Axis
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.List)//axis!: arg 2: expected integer")
					}
					newVal = layout.Axis(u)
				}
			}
			self.Axis = newVal
			return arg0
		},
	},
	"Go(*widget.List)//axis?": {
		Doc:   "Get *widget.List Axis value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//axis?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//axis?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//axis?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Axis)))
			return resObj
		},
	},
	"Go(*widget.List)//indicator-hovered": {
		Doc:   "(*widget.List).IndicatorHovered",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//indicator-hovered: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//indicator-hovered: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//indicator-hovered: arg 1: expected native")
			}
			res0 := arg0Val.IndicatorHovered()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.List)//layout": {
		Doc:   "(*widget.List).Layout",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//layout: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//layout: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//layout: arg 2: expected native")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//layout: arg 3: expected integer")
			}
			var arg3Val layout.ListElement
			{
				nat, natOk := arg3.(env.Native)
				var natValOk bool
				var natVal layout.ListElement
				if natOk {
					natVal, natValOk = nat.Value.(layout.ListElement)
				}
				if natValOk {
					arg3Val = natVal
				} else {
					var u func(layout.Context, int) layout.Dimensions
					switch fn := arg3.(type) {
					case env.Function:
						if fn.Argsn != 2 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.List)//layout: arg 4: function has invalid number of arguments (expected 2)")
						}
						u = func(farg0 layout.Context, farg1 int) layout.Dimensions {
							var farg0Val, farg1Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							farg1Val = *env.NewInteger(int64(farg1))
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val, farg1Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(*widget.List)//layout: arg 4: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(*widget.List)//layout: arg 4: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.List)//layout: arg 4: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.List)//layout: arg 4: expected function or nil")
					}
					arg3Val = layout.ListElement(u)
				}
			}
			res0 := arg0Val.Layout(*arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(*widget.List)//list!": {
		Doc:   "Set *widget.List List value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//list!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//list!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//list!: arg 1: expected native")
			}
			var newVal *layout.List
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*layout.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//list!: arg 2: expected native of type *layout.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//list!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//list!: arg 2: expected native")
			}
			self.List = *newVal
			return arg0
		},
	},
	"Go(*widget.List)//list?": {
		Doc:   "Get *widget.List List value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//list?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//list?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//list?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.List, "Go(*layout.List)")
			return resObj
		},
	},
	"Go(*widget.List)//position!": {
		Doc:   "Set *widget.List Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//position!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//position!: arg 1: expected native")
			}
			var newVal *layout.Position
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*layout.Position)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//position!: arg 2: expected native of type *layout.Position")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//position!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//position!: arg 2: expected native")
			}
			self.Position = *newVal
			return arg0
		},
	},
	"Go(*widget.List)//position?": {
		Doc:   "Get *widget.List Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//position?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Position, "Go(*layout.Position)")
			return resObj
		},
	},
	"Go(*widget.List)//scroll-by": {
		Doc:   "(*widget.List).ScrollBy",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scroll-by: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scroll-by: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scroll-by: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scroll-by: arg 2: expected decimal")
			}
			arg0Val.ScrollBy(arg1Val)
			return arg0
		},
	},
	"Go(*widget.List)//scroll-distance": {
		Doc:   "(*widget.List).ScrollDistance",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scroll-distance: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scroll-distance: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scroll-distance: arg 1: expected native")
			}
			res0 := arg0Val.ScrollDistance()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*widget.List)//scroll-to": {
		Doc:   "(*widget.List).ScrollTo",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scroll-to: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scroll-to: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scroll-to: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scroll-to: arg 2: expected integer")
			}
			arg0Val.ScrollTo(arg1Val)
			return arg0
		},
	},
	"Go(*widget.List)//scroll-to-end!": {
		Doc:   "Set *widget.List ScrollToEnd value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scroll-to-end!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scroll-to-end!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scroll-to-end!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scroll-to-end!: arg 2: expected integer")
			}
			self.ScrollToEnd = newVal
			return arg0
		},
	},
	"Go(*widget.List)//scroll-to-end?": {
		Doc:   "Get *widget.List ScrollToEnd value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scroll-to-end?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scroll-to-end?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scroll-to-end?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.ScrollToEnd))
			return resObj
		},
	},
	"Go(*widget.List)//scrollbar!": {
		Doc:   "Set *widget.List Scrollbar value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scrollbar!: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scrollbar!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scrollbar!: arg 1: expected native")
			}
			var newVal *widget.Scrollbar
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scrollbar!: arg 2: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scrollbar!: arg 2: expected integer to be 0 or nil")
				}
				newVal = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scrollbar!: arg 2: expected native")
			}
			self.Scrollbar = *newVal
			return arg0
		},
	},
	"Go(*widget.List)//scrollbar?": {
		Doc:   "Get *widget.List Scrollbar value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scrollbar?: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//scrollbar?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//scrollbar?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, &self.Scrollbar, "Go(*widget.Scrollbar)")
			return resObj
		},
	},
	"Go(*widget.List)//track-hovered": {
		Doc:   "(*widget.List).TrackHovered",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//track-hovered: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//track-hovered: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//track-hovered: arg 1: expected native")
			}
			res0 := arg0Val.TrackHovered()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.List)//update": {
		Doc:   "(*widget.List).Update",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.List
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//update: arg 1: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//update: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//update: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.List)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//update: arg 2: expected native")
			}
			var arg2Val layout.Axis
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u uint8
					if v, ok := arg2.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.List)//update: arg 3: expected integer")
					}
					arg2Val = layout.Axis(u)
				}
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//update: arg 4: expected decimal")
			}
			var arg4Val float32
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.List)//update: arg 5: expected decimal")
			}
			arg0Val.Update(*arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*widget.Press)//cancelled!": {
		Doc:   "Set *widget.Press Cancelled value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Press
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Press)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//cancelled!: arg 1: expected native of type *widget.Press")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//cancelled!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//cancelled!: arg 1: expected native")
			}
			var newVal bool
			if v, ok := arg1.(env.Integer); ok {
				newVal = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//cancelled!: arg 2: expected integer")
			}
			self.Cancelled = newVal
			return arg0
		},
	},
	"Go(*widget.Press)//cancelled?": {
		Doc:   "Get *widget.Press Cancelled value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Press
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Press)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//cancelled?: arg 1: expected native of type *widget.Press")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//cancelled?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//cancelled?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(boolToInt64(self.Cancelled))
			return resObj
		},
	},
	"Go(*widget.Press)//end!": {
		Doc:   "Set *widget.Press End value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Press
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Press)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//end!: arg 1: expected native of type *widget.Press")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//end!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//end!: arg 1: expected native")
			}
			var newVal time.Time
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(time.Time)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//end!: arg 2: expected native of type time.Time")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//end!: arg 2: expected native")
			}
			self.End = newVal
			return arg0
		},
	},
	"Go(*widget.Press)//end?": {
		Doc:   "Get *widget.Press End value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Press
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Press)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//end?: arg 1: expected native of type *widget.Press")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//end?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//end?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.End, "Go(time.Time)")
			return resObj
		},
	},
	"Go(*widget.Press)//position!": {
		Doc:   "Set *widget.Press Position value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Press
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Press)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//position!: arg 1: expected native of type *widget.Press")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//position!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//position!: arg 1: expected native")
			}
			var newVal image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//position!: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//position!: arg 2: expected native")
			}
			self.Position = newVal
			return arg0
		},
	},
	"Go(*widget.Press)//position?": {
		Doc:   "Get *widget.Press Position value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Press
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Press)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//position?: arg 1: expected native of type *widget.Press")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//position?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//position?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Position, "Go(image.Point)")
			return resObj
		},
	},
	"Go(*widget.Press)//start!": {
		Doc:   "Set *widget.Press Start value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Press
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Press)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//start!: arg 1: expected native of type *widget.Press")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//start!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//start!: arg 1: expected native")
			}
			var newVal time.Time
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(time.Time)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//start!: arg 2: expected native of type time.Time")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//start!: arg 2: expected native")
			}
			self.Start = newVal
			return arg0
		},
	},
	"Go(*widget.Press)//start?": {
		Doc:   "Get *widget.Press Start value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Press
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Press)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//start?: arg 1: expected native of type *widget.Press")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Press)//start?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Press)//start?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Start, "Go(time.Time)")
			return resObj
		},
	},
	"Go(*widget.Region)//baseline!": {
		Doc:   "Set *widget.Region Baseline value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Region
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Region)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Region)//baseline!: arg 1: expected native of type *widget.Region")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Region)//baseline!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Region)//baseline!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Region)//baseline!: arg 2: expected integer")
			}
			self.Baseline = newVal
			return arg0
		},
	},
	"Go(*widget.Region)//baseline?": {
		Doc:   "Get *widget.Region Baseline value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Region
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Region)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Region)//baseline?: arg 1: expected native of type *widget.Region")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Region)//baseline?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Region)//baseline?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Baseline))
			return resObj
		},
	},
	"Go(*widget.Region)//bounds!": {
		Doc:   "Set *widget.Region Bounds value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Region
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Region)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Region)//bounds!: arg 1: expected native of type *widget.Region")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Region)//bounds!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Region)//bounds!: arg 1: expected native")
			}
			var newVal image.Rectangle
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Region)//bounds!: arg 2: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Region)//bounds!: arg 2: expected native")
			}
			self.Bounds = newVal
			return arg0
		},
	},
	"Go(*widget.Region)//bounds?": {
		Doc:   "Get *widget.Region Bounds value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Region
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Region)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Region)//bounds?: arg 1: expected native of type *widget.Region")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Region)//bounds?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Region)//bounds?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.Bounds, "Go(image.Rectangle)")
			return resObj
		},
	},
	"Go(*widget.Scrollbar)//add-drag": {
		Doc:   "(*widget.Scrollbar).AddDrag",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Scrollbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-drag: arg 1: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-drag: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//add-drag: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-drag: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-drag: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//add-drag: arg 2: expected native")
			}
			arg0Val.AddDrag(arg1Val)
			return arg0
		},
	},
	"Go(*widget.Scrollbar)//add-indicator": {
		Doc:   "(*widget.Scrollbar).AddIndicator",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Scrollbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-indicator: arg 1: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-indicator: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//add-indicator: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-indicator: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-indicator: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//add-indicator: arg 2: expected native")
			}
			arg0Val.AddIndicator(arg1Val)
			return arg0
		},
	},
	"Go(*widget.Scrollbar)//add-track": {
		Doc:   "(*widget.Scrollbar).AddTrack",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Scrollbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-track: arg 1: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-track: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//add-track: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-track: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//add-track: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//add-track: arg 2: expected native")
			}
			arg0Val.AddTrack(arg1Val)
			return arg0
		},
	},
	"Go(*widget.Scrollbar)//dragging": {
		Doc:   "(*widget.Scrollbar).Dragging",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Scrollbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//dragging: arg 1: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//dragging: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//dragging: arg 1: expected native")
			}
			res0 := arg0Val.Dragging()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Scrollbar)//indicator-hovered": {
		Doc:   "(*widget.Scrollbar).IndicatorHovered",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Scrollbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//indicator-hovered: arg 1: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//indicator-hovered: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//indicator-hovered: arg 1: expected native")
			}
			res0 := arg0Val.IndicatorHovered()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Scrollbar)//scroll-distance": {
		Doc:   "(*widget.Scrollbar).ScrollDistance",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Scrollbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//scroll-distance: arg 1: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//scroll-distance: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//scroll-distance: arg 1: expected native")
			}
			res0 := arg0Val.ScrollDistance()
			var res0Obj env.Object
			res0Obj = *env.NewDecimal(float64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Scrollbar)//track-hovered": {
		Doc:   "(*widget.Scrollbar).TrackHovered",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Scrollbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//track-hovered: arg 1: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//track-hovered: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//track-hovered: arg 1: expected native")
			}
			res0 := arg0Val.TrackHovered()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Scrollbar)//update": {
		Doc:   "(*widget.Scrollbar).Update",
		Argsn: 5,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Scrollbar
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//update: arg 1: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//update: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//update: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Scrollbar)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//update: arg 2: expected native")
			}
			var arg2Val layout.Axis
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u uint8
					if v, ok := arg2.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Scrollbar)//update: arg 3: expected integer")
					}
					arg2Val = layout.Axis(u)
				}
			}
			var arg3Val float32
			if v, ok := arg3.(env.Decimal); ok {
				arg3Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//update: arg 4: expected decimal")
			}
			var arg4Val float32
			if v, ok := arg4.(env.Decimal); ok {
				arg4Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Scrollbar)//update: arg 5: expected decimal")
			}
			arg0Val.Update(*arg1Val, arg2Val, arg3Val, arg4Val)
			return arg0
		},
	},
	"Go(*widget.Selectable)//alignment!": {
		Doc:   "Set *widget.Selectable Alignment value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//alignment!: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//alignment!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//alignment!: arg 1: expected native")
			}
			var newVal text.Alignment
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(text.Alignment)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Selectable)//alignment!: arg 2: expected integer")
					}
					newVal = text.Alignment(u)
				}
			}
			self.Alignment = newVal
			return arg0
		},
	},
	"Go(*widget.Selectable)//alignment?": {
		Doc:   "Get *widget.Selectable Alignment value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//alignment?: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//alignment?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//alignment?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.Alignment)))
			return resObj
		},
	},
	"Go(*widget.Selectable)//clear-selection": {
		Doc:   "(*widget.Selectable).ClearSelection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//clear-selection: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//clear-selection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//clear-selection: arg 1: expected native")
			}
			arg0Val.ClearSelection()
			return arg0
		},
	},
	"Go(*widget.Selectable)//focused": {
		Doc:   "(*widget.Selectable).Focused",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//focused: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//focused: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//focused: arg 1: expected native")
			}
			res0 := arg0Val.Focused()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Selectable)//line-height!": {
		Doc:   "Set *widget.Selectable LineHeight value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//line-height!: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//line-height!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//line-height!: arg 1: expected native")
			}
			var newVal unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				newVal, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//line-height!: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//line-height!: arg 2: expected native")
			}
			self.LineHeight = newVal
			return arg0
		},
	},
	"Go(*widget.Selectable)//line-height-scale!": {
		Doc:   "Set *widget.Selectable LineHeightScale value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//line-height-scale!: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//line-height-scale!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//line-height-scale!: arg 1: expected native")
			}
			var newVal float32
			if v, ok := arg1.(env.Decimal); ok {
				newVal = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//line-height-scale!: arg 2: expected decimal")
			}
			self.LineHeightScale = newVal
			return arg0
		},
	},
	"Go(*widget.Selectable)//line-height-scale?": {
		Doc:   "Get *widget.Selectable LineHeightScale value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//line-height-scale?: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//line-height-scale?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//line-height-scale?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewDecimal(float64(self.LineHeightScale))
			return resObj
		},
	},
	"Go(*widget.Selectable)//line-height?": {
		Doc:   "Get *widget.Selectable LineHeight value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//line-height?: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//line-height?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//line-height?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, self.LineHeight, "Go(unit.Sp)")
			return resObj
		},
	},
	"Go(*widget.Selectable)//max-lines!": {
		Doc:   "Set *widget.Selectable MaxLines value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//max-lines!: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//max-lines!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//max-lines!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//max-lines!: arg 2: expected integer")
			}
			self.MaxLines = newVal
			return arg0
		},
	},
	"Go(*widget.Selectable)//max-lines?": {
		Doc:   "Get *widget.Selectable MaxLines value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//max-lines?: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//max-lines?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//max-lines?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.MaxLines))
			return resObj
		},
	},
	"Go(*widget.Selectable)//regions": {
		Doc:   "(*widget.Selectable).Regions",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//regions: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//regions: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//regions: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//regions: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//regions: arg 3: expected integer")
			}
			var arg3Val []widget.Region
			switch v := arg3.(type) {
			case env.Block:
				arg3Val = make([]widget.Region, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg3Val[i], ok = v.Value.(widget.Region)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(*widget.Selectable)//regions: arg 4: block item: expected native of type widget.Region")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Selectable)//regions: arg 4: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.([]widget.Region)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//regions: arg 4: expected native of type []widget.Region")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//regions: arg 4: expected integer to be 0 or nil")
				}
				arg3Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//regions: arg 4: expected block, native or nil")
			}
			res0 := arg0Val.Regions(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(widget.Region)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"Go(*widget.Selectable)//selected-text": {
		Doc:   "(*widget.Selectable).SelectedText",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//selected-text: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//selected-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//selected-text: arg 1: expected native")
			}
			res0 := arg0Val.SelectedText()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*widget.Selectable)//selection": {
		Doc:   "(*widget.Selectable).Selection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//selection: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//selection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//selection: arg 1: expected native")
			}
			res0, res1 := arg0Val.Selection()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			var res1Obj env.Object
			res1Obj = *env.NewInteger(int64(res1))
			return *env.NewBlock(*env.NewTSeries([]env.Object{
				res0Obj,
				res1Obj,
			}))
		},
	},
	"Go(*widget.Selectable)//selection-len": {
		Doc:   "(*widget.Selectable).SelectionLen",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//selection-len: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//selection-len: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//selection-len: arg 1: expected native")
			}
			res0 := arg0Val.SelectionLen()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(int64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Selectable)//set-caret": {
		Doc:   "(*widget.Selectable).SetCaret",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//set-caret: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//set-caret: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//set-caret: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//set-caret: arg 2: expected integer")
			}
			var arg2Val int
			if v, ok := arg2.(env.Integer); ok {
				arg2Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//set-caret: arg 3: expected integer")
			}
			arg0Val.SetCaret(arg1Val, arg2Val)
			return arg0
		},
	},
	"Go(*widget.Selectable)//set-text": {
		Doc:   "(*widget.Selectable).SetText",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//set-text: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//set-text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//set-text: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//set-text: arg 2: expected string")
			}
			arg0Val.SetText(arg1Val)
			return arg0
		},
	},
	"Go(*widget.Selectable)//text": {
		Doc:   "(*widget.Selectable).Text",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//text: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//text: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//text: arg 1: expected native")
			}
			res0 := arg0Val.Text()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(*widget.Selectable)//truncated": {
		Doc:   "(*widget.Selectable).Truncated",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//truncated: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//truncated: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//truncated: arg 1: expected native")
			}
			res0 := arg0Val.Truncated()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Selectable)//truncator!": {
		Doc:   "Set *widget.Selectable Truncator value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//truncator!: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//truncator!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//truncator!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//truncator!: arg 2: expected string")
			}
			self.Truncator = newVal
			return arg0
		},
	},
	"Go(*widget.Selectable)//truncator?": {
		Doc:   "Get *widget.Selectable Truncator value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//truncator?: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//truncator?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//truncator?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Truncator)
			return resObj
		},
	},
	"Go(*widget.Selectable)//update": {
		Doc:   "(*widget.Selectable).Update",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//update: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//update: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//update: arg 1: expected native")
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//update: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//update: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//update: arg 2: expected native")
			}
			res0 := arg0Val.Update(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(*widget.Selectable)//wrap-policy!": {
		Doc:   "Set *widget.Selectable WrapPolicy value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//wrap-policy!: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//wrap-policy!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//wrap-policy!: arg 1: expected native")
			}
			var newVal text.WrapPolicy
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal text.WrapPolicy
				if natOk {
					natVal, natValOk = nat.Value.(text.WrapPolicy)
				}
				if natValOk {
					newVal = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(*widget.Selectable)//wrap-policy!: arg 2: expected integer")
					}
					newVal = text.WrapPolicy(u)
				}
			}
			self.WrapPolicy = newVal
			return arg0
		},
	},
	"Go(*widget.Selectable)//wrap-policy?": {
		Doc:   "Get *widget.Selectable WrapPolicy value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.Selectable
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.Selectable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//wrap-policy?: arg 1: expected native of type *widget.Selectable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.Selectable)//wrap-policy?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.Selectable)//wrap-policy?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(self.WrapPolicy)))
			return resObj
		},
	},
	"Go(*widget.SubmitEvent)//text!": {
		Doc:   "Set *widget.SubmitEvent Text value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.SubmitEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SubmitEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.SubmitEvent)//text!: arg 1: expected native of type *widget.SubmitEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.SubmitEvent)//text!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.SubmitEvent)//text!: arg 1: expected native")
			}
			var newVal string
			if v, ok := arg1.(env.String); ok {
				newVal = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.SubmitEvent)//text!: arg 2: expected string")
			}
			self.Text = newVal
			return arg0
		},
	},
	"Go(*widget.SubmitEvent)//text?": {
		Doc:   "Get *widget.SubmitEvent Text value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.SubmitEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.SubmitEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.SubmitEvent)//text?: arg 1: expected native of type *widget.SubmitEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.SubmitEvent)//text?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.SubmitEvent)//text?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewString(self.Text)
			return resObj
		},
	},
	"Go(*widget.TextInfo)//truncated!": {
		Doc:   "Set *widget.TextInfo Truncated value",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.TextInfo
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextInfo)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.TextInfo)//truncated!: arg 1: expected native of type *widget.TextInfo")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.TextInfo)//truncated!: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.TextInfo)//truncated!: arg 1: expected native")
			}
			var newVal int
			if v, ok := arg1.(env.Integer); ok {
				newVal = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(*widget.TextInfo)//truncated!: arg 2: expected integer")
			}
			self.Truncated = newVal
			return arg0
		},
	},
	"Go(*widget.TextInfo)//truncated?": {
		Doc:   "Get *widget.TextInfo Truncated value",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var self *widget.TextInfo
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				self, ok = v.Value.(*widget.TextInfo)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.TextInfo)//truncated?: arg 1: expected native of type *widget.TextInfo")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(*widget.TextInfo)//truncated?: arg 1: expected integer to be 0 or nil")
				}
				self = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(*widget.TextInfo)//truncated?: arg 1: expected native")
			}
			var resObj env.Object
			resObj = *env.NewInteger(int64(self.Truncated))
			return resObj
		},
	},
	"Go(app.Orientation)//option": {
		Doc:   "app.Orientation.Option",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val app.Orientation
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal app.Orientation
				if natOk {
					natVal, natValOk = nat.Value.(app.Orientation)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(app.Orientation)//option: arg 1: expected integer")
					}
					arg0Val = app.Orientation(u)
				}
			}
			res0 := arg0Val.Option()
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *unit.Metric
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*unit.Metric)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("Go(app.Orientation)//option: arg 1: expected native of type *unit.Metric")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("Go(app.Orientation)//option: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("Go(app.Orientation)//option: arg 1: expected native")
				}
				var arg1Val *app.Config
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*app.Config)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("Go(app.Orientation)//option: arg 2: expected native of type *app.Config")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("Go(app.Orientation)//option: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("Go(app.Orientation)//option: arg 2: expected native")
				}
				(func(unit.Metric, *app.Config))(res0)(*arg0Val, arg1Val)
				return nil
			}, 2, false, false, "Returned func")
			return res0Obj
		},
	},
	"Go(app.Orientation)//string": {
		Doc:   "app.Orientation.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val app.Orientation
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal app.Orientation
				if natOk {
					natVal, natValOk = nat.Value.(app.Orientation)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(app.Orientation)//string: arg 1: expected integer")
					}
					arg0Val = app.Orientation(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(app.ViewEvent)//implements-event": {
		Doc:   "app.ViewEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val app.ViewEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(app.ViewEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(app.ViewEvent)//implements-event: arg 1: expected native of type app.ViewEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(app.ViewEvent)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(app.ViewEvent)//implements-event: arg 1: expected native")
			}
			arg0Val.ImplementsEvent()
			return arg0
		},
	},
	"Go(app.ViewEvent)//valid": {
		Doc:   "app.ViewEvent.Valid",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val app.ViewEvent
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(app.ViewEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(app.ViewEvent)//valid: arg 1: expected native of type app.ViewEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(app.ViewEvent)//valid: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(app.ViewEvent)//valid: arg 1: expected native")
			}
			res0 := arg0Val.Valid()
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(app.WindowMode)//option": {
		Doc:   "app.WindowMode.Option",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val app.WindowMode
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal app.WindowMode
				if natOk {
					natVal, natValOk = nat.Value.(app.WindowMode)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(app.WindowMode)//option: arg 1: expected integer")
					}
					arg0Val = app.WindowMode(u)
				}
			}
			res0 := arg0Val.Option()
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *unit.Metric
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*unit.Metric)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("Go(app.WindowMode)//option: arg 1: expected native of type *unit.Metric")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("Go(app.WindowMode)//option: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("Go(app.WindowMode)//option: arg 1: expected native")
				}
				var arg1Val *app.Config
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*app.Config)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("Go(app.WindowMode)//option: arg 2: expected native of type *app.Config")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("Go(app.WindowMode)//option: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("Go(app.WindowMode)//option: arg 2: expected native")
				}
				(func(unit.Metric, *app.Config))(res0)(*arg0Val, arg1Val)
				return nil
			}, 2, false, false, "Returned func")
			return res0Obj
		},
	},
	"Go(app.WindowMode)//string": {
		Doc:   "app.WindowMode.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val app.WindowMode
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal app.WindowMode
				if natOk {
					natVal, natValOk = nat.Value.(app.WindowMode)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(app.WindowMode)//string: arg 1: expected integer")
					}
					arg0Val = app.WindowMode(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(clip.Ellipse)//op": {
		Doc:   "clip.Ellipse.Op",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val clip.Ellipse
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal clip.Ellipse
				if natOk {
					natVal, natValOk = nat.Value.(clip.Ellipse)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u image.Rectangle
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(image.Rectangle)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(clip.Ellipse)//op: arg 1: expected native of type image.Rectangle")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(clip.Ellipse)//op: arg 1: expected native")
					}
					arg0Val = clip.Ellipse(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(clip.Ellipse)//op: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(clip.Ellipse)//op: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(clip.Ellipse)//op: arg 2: expected native")
			}
			res0 := arg0Val.Op(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.Op)")
			return res0Obj
		},
	},
	"Go(clip.Ellipse)//path": {
		Doc:   "clip.Ellipse.Path",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val clip.Ellipse
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal clip.Ellipse
				if natOk {
					natVal, natValOk = nat.Value.(clip.Ellipse)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u image.Rectangle
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(image.Rectangle)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(clip.Ellipse)//path: arg 1: expected native of type image.Rectangle")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(clip.Ellipse)//path: arg 1: expected native")
					}
					arg0Val = clip.Ellipse(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(clip.Ellipse)//path: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(clip.Ellipse)//path: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(clip.Ellipse)//path: arg 2: expected native")
			}
			res0 := arg0Val.Path(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.PathSpec)")
			return res0Obj
		},
	},
	"Go(clip.Ellipse)//push": {
		Doc:   "clip.Ellipse.Push",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val clip.Ellipse
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal clip.Ellipse
				if natOk {
					natVal, natValOk = nat.Value.(clip.Ellipse)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u image.Rectangle
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(image.Rectangle)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(clip.Ellipse)//push: arg 1: expected native of type image.Rectangle")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(clip.Ellipse)//push: arg 1: expected native")
					}
					arg0Val = clip.Ellipse(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(clip.Ellipse)//push: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(clip.Ellipse)//push: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(clip.Ellipse)//push: arg 2: expected native")
			}
			res0 := arg0Val.Push(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.Stack)")
			return res0Obj
		},
	},
	"Go(clip.Rect)//op": {
		Doc:   "clip.Rect.Op",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val clip.Rect
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal clip.Rect
				if natOk {
					natVal, natValOk = nat.Value.(clip.Rect)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u image.Rectangle
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(image.Rectangle)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(clip.Rect)//op: arg 1: expected native of type image.Rectangle")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(clip.Rect)//op: arg 1: expected native")
					}
					arg0Val = clip.Rect(u)
				}
			}
			res0 := arg0Val.Op()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.Op)")
			return res0Obj
		},
	},
	"Go(clip.Rect)//path": {
		Doc:   "clip.Rect.Path",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val clip.Rect
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal clip.Rect
				if natOk {
					natVal, natValOk = nat.Value.(clip.Rect)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u image.Rectangle
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(image.Rectangle)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(clip.Rect)//path: arg 1: expected native of type image.Rectangle")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(clip.Rect)//path: arg 1: expected native")
					}
					arg0Val = clip.Rect(u)
				}
			}
			res0 := arg0Val.Path()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.PathSpec)")
			return res0Obj
		},
	},
	"Go(clip.Rect)//push": {
		Doc:   "clip.Rect.Push",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val clip.Rect
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal clip.Rect
				if natOk {
					natVal, natValOk = nat.Value.(clip.Rect)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u image.Rectangle
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(image.Rectangle)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(clip.Rect)//push: arg 1: expected native of type image.Rectangle")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(clip.Rect)//push: arg 1: expected native")
					}
					arg0Val = clip.Rect(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(clip.Rect)//push: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(clip.Rect)//push: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(clip.Rect)//push: arg 2: expected native")
			}
			res0 := arg0Val.Push(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.Stack)")
			return res0Obj
		},
	},
	"Go(event.Event)//implements-event": {
		Doc:   "event.Event.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val event.Event
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_event_Event(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(event.Event)//implements-event: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(event.Event)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(event.Event)//implements-event: arg 1: expected native of type event.Event")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(event.Event)//implements-event: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(event.Event)//implements-event: arg 1: expected native")
			}
			arg0Val.ImplementsEvent()
			return arg0
		},
	},
	"Go(event.Filter)//implements-filter": {
		Doc:   "event.Filter.ImplementsFilter",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val event.Filter
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_event_Filter(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(event.Filter)//implements-filter: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(event.Filter)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(event.Filter)//implements-filter: arg 1: expected native of type event.Filter")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(event.Filter)//implements-filter: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(event.Filter)//implements-filter: arg 1: expected native")
			}
			arg0Val.ImplementsFilter()
			return arg0
		},
	},
	"Go(font.Face)//face": {
		Doc:   "font.Face.Face",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Face
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_font_Face(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(font.Face)//face: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(font.Face)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(font.Face)//face: arg 1: expected native of type font.Face")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(font.Face)//face: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(font.Face)//face: arg 1: expected native")
			}
			res0 := arg0Val.Face()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(typesetting_font.Face)")
			return res0Obj
		},
	},
	"Go(font.Style)//string": {
		Doc:   "font.Style.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Style
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal font.Style
				if natOk {
					natVal, natValOk = nat.Value.(font.Style)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(font.Style)//string: arg 1: expected integer")
					}
					arg0Val = font.Style(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(font.Weight)//string": {
		Doc:   "font.Weight.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val font.Weight
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal font.Weight
				if natOk {
					natVal, natValOk = nat.Value.(font.Weight)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(font.Weight)//string: arg 1: expected integer")
					}
					arg0Val = font.Weight(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(gesture.Axis)//string": {
		Doc:   "gesture.Axis.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val gesture.Axis
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal gesture.Axis
				if natOk {
					natVal, natValOk = nat.Value.(gesture.Axis)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(gesture.Axis)//string: arg 1: expected integer")
					}
					arg0Val = gesture.Axis(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(gesture.ClickKind)//string": {
		Doc:   "gesture.ClickKind.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val gesture.ClickKind
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal gesture.ClickKind
				if natOk {
					natVal, natValOk = nat.Value.(gesture.ClickKind)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(gesture.ClickKind)//string: arg 1: expected integer")
					}
					arg0Val = gesture.ClickKind(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(gesture.ScrollState)//string": {
		Doc:   "gesture.ScrollState.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val gesture.ScrollState
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal gesture.ScrollState
				if natOk {
					natVal, natValOk = nat.Value.(gesture.ScrollState)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(gesture.ScrollState)//string: arg 1: expected integer")
					}
					arg0Val = gesture.ScrollState(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(gpu.GPU)//clear": {
		Doc:   "gpu.GPU.Clear",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val gpu.GPU
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_gpu_GPU(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//clear: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(gpu.GPU)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//clear: arg 1: expected native of type gpu.GPU")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//clear: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(gpu.GPU)//clear: arg 1: expected native")
			}
			var arg1Val color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//clear: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(gpu.GPU)//clear: arg 2: expected native")
			}
			arg0Val.Clear(arg1Val)
			return arg0
		},
	},
	"Go(gpu.GPU)//frame": {
		Doc:   "gpu.GPU.Frame",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val gpu.GPU
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_gpu_GPU(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//frame: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(gpu.GPU)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//frame: arg 1: expected native of type gpu.GPU")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//frame: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(gpu.GPU)//frame: arg 1: expected native")
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//frame: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//frame: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(gpu.GPU)//frame: arg 2: expected native")
			}
			var arg2Val gpu.RenderTarget
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(gpu.RenderTarget)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//frame: arg 3: expected native of type gpu.RenderTarget")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(gpu.GPU)//frame: arg 3: expected native")
			}
			var arg3Val image.Point
			switch v := arg3.(type) {
			case env.Native:
				var ok bool
				arg3Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//frame: arg 4: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(gpu.GPU)//frame: arg 4: expected native")
			}
			resErr := arg0Val.Frame(arg1Val, arg2Val, arg3Val)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return arg0
		},
	},
	"Go(gpu.GPU)//release": {
		Doc:   "gpu.GPU.Release",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val gpu.GPU
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_gpu_GPU(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//release: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(gpu.GPU)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//release: arg 1: expected native of type gpu.GPU")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(gpu.GPU)//release: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(gpu.GPU)//release: arg 1: expected native")
			}
			arg0Val.Release()
			return arg0
		},
	},
	"Go(input.Command)//implements-command": {
		Doc:   "input.Command.ImplementsCommand",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val input.Command
			switch v := arg0.(type) {
			case env.RyeCtx:
				var err error
				arg0Val, err = ctxTo_input_Command(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("Go(input.Command)//implements-command: arg 1: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(input.Command)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(input.Command)//implements-command: arg 1: expected native of type input.Command")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(input.Command)//implements-command: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(input.Command)//implements-command: arg 1: expected native")
			}
			arg0Val.ImplementsCommand()
			return arg0
		},
	},
	"Go(input.SemanticGestures)//string": {
		Doc:   "input.SemanticGestures.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val input.SemanticGestures
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal input.SemanticGestures
				if natOk {
					natVal, natValOk = nat.Value.(input.SemanticGestures)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(input.SemanticGestures)//string: arg 1: expected integer")
					}
					arg0Val = input.SemanticGestures(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(input.TextInputState)//string": {
		Doc:   "input.TextInputState.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val input.TextInputState
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal input.TextInputState
				if natOk {
					natVal, natValOk = nat.Value.(input.TextInputState)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(input.TextInputState)//string: arg 1: expected integer")
					}
					arg0Val = input.TextInputState(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(key.Modifiers)//contain": {
		Doc:   "key.Modifiers.Contain",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val key.Modifiers
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal key.Modifiers
				if natOk {
					natVal, natValOk = nat.Value.(key.Modifiers)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint32
					if v, ok := arg0.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(key.Modifiers)//contain: arg 1: expected integer")
					}
					arg0Val = key.Modifiers(u)
				}
			}
			var arg1Val key.Modifiers
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal key.Modifiers
				if natOk {
					natVal, natValOk = nat.Value.(key.Modifiers)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint32
					if v, ok := arg1.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(key.Modifiers)//contain: arg 2: expected integer")
					}
					arg1Val = key.Modifiers(u)
				}
			}
			res0 := arg0Val.Contain(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(key.Modifiers)//string": {
		Doc:   "key.Modifiers.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val key.Modifiers
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal key.Modifiers
				if natOk {
					natVal, natValOk = nat.Value.(key.Modifiers)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint32
					if v, ok := arg0.(env.Integer); ok {
						u = uint32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(key.Modifiers)//string: arg 1: expected integer")
					}
					arg0Val = key.Modifiers(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(key.SelectionEvent)//implements-event": {
		Doc:   "key.SelectionEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val key.SelectionEvent
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal key.SelectionEvent
				if natOk {
					natVal, natValOk = nat.Value.(key.SelectionEvent)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u key.Range
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(key.Range)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(key.SelectionEvent)//implements-event: arg 1: expected native of type key.Range")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(key.SelectionEvent)//implements-event: arg 1: expected native")
					}
					arg0Val = key.SelectionEvent(u)
				}
			}
			arg0Val.ImplementsEvent()
			return arg0
		},
	},
	"Go(key.SnippetEvent)//implements-event": {
		Doc:   "key.SnippetEvent.ImplementsEvent",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val key.SnippetEvent
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal key.SnippetEvent
				if natOk {
					natVal, natValOk = nat.Value.(key.SnippetEvent)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u key.Range
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(key.Range)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(key.SnippetEvent)//implements-event: arg 1: expected native of type key.Range")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(key.SnippetEvent)//implements-event: arg 1: expected native")
					}
					arg0Val = key.SnippetEvent(u)
				}
			}
			arg0Val.ImplementsEvent()
			return arg0
		},
	},
	"Go(key.State)//string": {
		Doc:   "key.State.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val key.State
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal key.State
				if natOk {
					natVal, natValOk = nat.Value.(key.State)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(key.State)//string: arg 1: expected integer")
					}
					arg0Val = key.State(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(layout.Alignment)//string": {
		Doc:   "layout.Alignment.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Alignment
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(layout.Alignment)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(layout.Alignment)//string: arg 1: expected integer")
					}
					arg0Val = layout.Alignment(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(layout.Axis)//convert": {
		Doc:   "layout.Axis.Convert",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Axis
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(layout.Axis)//convert: arg 1: expected integer")
					}
					arg0Val = layout.Axis(u)
				}
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(layout.Axis)//convert: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(layout.Axis)//convert: arg 2: expected native")
			}
			res0 := arg0Val.Convert(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(image.Point)")
			return res0Obj
		},
	},
	"Go(layout.Axis)//f-convert": {
		Doc:   "layout.Axis.FConvert",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Axis
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(layout.Axis)//f-convert: arg 1: expected integer")
					}
					arg0Val = layout.Axis(u)
				}
			}
			var arg1Val *f32.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*f32.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(layout.Axis)//f-convert: arg 2: expected native of type *f32.Point")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(layout.Axis)//f-convert: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(layout.Axis)//f-convert: arg 2: expected native")
			}
			res0 := arg0Val.FConvert(*arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"Go(layout.Axis)//string": {
		Doc:   "layout.Axis.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Axis
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Axis
				if natOk {
					natVal, natValOk = nat.Value.(layout.Axis)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(layout.Axis)//string: arg 1: expected integer")
					}
					arg0Val = layout.Axis(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(layout.Direction)//layout": {
		Doc:   "layout.Direction.Layout",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Direction
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Direction
				if natOk {
					natVal, natValOk = nat.Value.(layout.Direction)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(layout.Direction)//layout: arg 1: expected integer")
					}
					arg0Val = layout.Direction(u)
				}
			}
			var arg1Val *layout.Context
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(layout.Direction)//layout: arg 2: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(layout.Direction)//layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(layout.Direction)//layout: arg 2: expected native")
			}
			var arg2Val layout.Widget
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg2.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("Go(layout.Direction)//layout: arg 3: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"Go(layout.Direction)//layout: arg 3: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"Go(layout.Direction)//layout: arg 3: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("Go(layout.Direction)//layout: arg 3: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("Go(layout.Direction)//layout: arg 3: expected function or nil")
					}
					arg2Val = layout.Widget(u)
				}
			}
			res0 := arg0Val.Layout(*arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"Go(layout.Direction)//position": {
		Doc:   "layout.Direction.Position",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Direction
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Direction
				if natOk {
					natVal, natValOk = nat.Value.(layout.Direction)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(layout.Direction)//position: arg 1: expected integer")
					}
					arg0Val = layout.Direction(u)
				}
			}
			var arg1Val image.Point
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(layout.Direction)//position: arg 2: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(layout.Direction)//position: arg 2: expected native")
			}
			var arg2Val image.Point
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(layout.Direction)//position: arg 3: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(layout.Direction)//position: arg 3: expected native")
			}
			res0 := arg0Val.Position(arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(image.Point)")
			return res0Obj
		},
	},
	"Go(layout.Direction)//string": {
		Doc:   "layout.Direction.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Direction
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Direction
				if natOk {
					natVal, natValOk = nat.Value.(layout.Direction)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(layout.Direction)//string: arg 1: expected integer")
					}
					arg0Val = layout.Direction(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(layout.Spacing)//string": {
		Doc:   "layout.Spacing.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Spacing
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Spacing
				if natOk {
					natVal, natValOk = nat.Value.(layout.Spacing)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(layout.Spacing)//string: arg 1: expected integer")
					}
					arg0Val = layout.Spacing(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(pointer.Buttons)//contain": {
		Doc:   "pointer.Buttons.Contain",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val pointer.Buttons
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal pointer.Buttons
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Buttons)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(pointer.Buttons)//contain: arg 1: expected integer")
					}
					arg0Val = pointer.Buttons(u)
				}
			}
			var arg1Val pointer.Buttons
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal pointer.Buttons
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Buttons)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u uint8
					if v, ok := arg1.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(pointer.Buttons)//contain: arg 2: expected integer")
					}
					arg1Val = pointer.Buttons(u)
				}
			}
			res0 := arg0Val.Contain(arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewInteger(boolToInt64(res0))
			return res0Obj
		},
	},
	"Go(pointer.Buttons)//string": {
		Doc:   "pointer.Buttons.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val pointer.Buttons
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal pointer.Buttons
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Buttons)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(pointer.Buttons)//string: arg 1: expected integer")
					}
					arg0Val = pointer.Buttons(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(pointer.Cursor)//add": {
		Doc:   "pointer.Cursor.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val pointer.Cursor
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal pointer.Cursor
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Cursor)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u byte
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(pointer.Cursor)//add: arg 1: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(pointer.Cursor)//add: arg 1: expected native")
					}
					arg0Val = pointer.Cursor(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(pointer.Cursor)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(pointer.Cursor)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(pointer.Cursor)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(pointer.Cursor)//string": {
		Doc:   "pointer.Cursor.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val pointer.Cursor
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal pointer.Cursor
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Cursor)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u byte
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(pointer.Cursor)//string: arg 1: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(pointer.Cursor)//string: arg 1: expected native")
					}
					arg0Val = pointer.Cursor(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(pointer.Kind)//string": {
		Doc:   "pointer.Kind.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val pointer.Kind
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal pointer.Kind
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Kind)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint
					if v, ok := arg0.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(pointer.Kind)//string: arg 1: expected integer")
					}
					arg0Val = pointer.Kind(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(pointer.Priority)//string": {
		Doc:   "pointer.Priority.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val pointer.Priority
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal pointer.Priority
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Priority)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(pointer.Priority)//string: arg 1: expected integer")
					}
					arg0Val = pointer.Priority(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(pointer.Source)//string": {
		Doc:   "pointer.Source.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val pointer.Source
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal pointer.Source
				if natOk {
					natVal, natValOk = nat.Value.(pointer.Source)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(pointer.Source)//string: arg 1: expected integer")
					}
					arg0Val = pointer.Source(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(semantic.ClassOp)//add": {
		Doc:   "semantic.ClassOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val semantic.ClassOp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal semantic.ClassOp
				if natOk {
					natVal, natValOk = nat.Value.(semantic.ClassOp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(semantic.ClassOp)//add: arg 1: expected integer")
					}
					arg0Val = semantic.ClassOp(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(semantic.ClassOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(semantic.ClassOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(semantic.ClassOp)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(semantic.ClassOp)//string": {
		Doc:   "semantic.ClassOp.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val semantic.ClassOp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal semantic.ClassOp
				if natOk {
					natVal, natValOk = nat.Value.(semantic.ClassOp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u int
					if v, ok := arg0.(env.Integer); ok {
						u = int(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(semantic.ClassOp)//string: arg 1: expected integer")
					}
					arg0Val = semantic.ClassOp(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(semantic.DescriptionOp)//add": {
		Doc:   "semantic.DescriptionOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val semantic.DescriptionOp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal semantic.DescriptionOp
				if natOk {
					natVal, natValOk = nat.Value.(semantic.DescriptionOp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u string
					if v, ok := arg0.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(semantic.DescriptionOp)//add: arg 1: expected string")
					}
					arg0Val = semantic.DescriptionOp(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(semantic.DescriptionOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(semantic.DescriptionOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(semantic.DescriptionOp)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(semantic.EnabledOp)//add": {
		Doc:   "semantic.EnabledOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val semantic.EnabledOp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal semantic.EnabledOp
				if natOk {
					natVal, natValOk = nat.Value.(semantic.EnabledOp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u bool
					if v, ok := arg0.(env.Integer); ok {
						u = v.Value != 0
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(semantic.EnabledOp)//add: arg 1: expected integer")
					}
					arg0Val = semantic.EnabledOp(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(semantic.EnabledOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(semantic.EnabledOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(semantic.EnabledOp)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(semantic.LabelOp)//add": {
		Doc:   "semantic.LabelOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val semantic.LabelOp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal semantic.LabelOp
				if natOk {
					natVal, natValOk = nat.Value.(semantic.LabelOp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u string
					if v, ok := arg0.(env.String); ok {
						u = string(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(semantic.LabelOp)//add: arg 1: expected string")
					}
					arg0Val = semantic.LabelOp(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(semantic.LabelOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(semantic.LabelOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(semantic.LabelOp)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(semantic.SelectedOp)//add": {
		Doc:   "semantic.SelectedOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val semantic.SelectedOp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal semantic.SelectedOp
				if natOk {
					natVal, natValOk = nat.Value.(semantic.SelectedOp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u bool
					if v, ok := arg0.(env.Integer); ok {
						u = v.Value != 0
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(semantic.SelectedOp)//add: arg 1: expected integer")
					}
					arg0Val = semantic.SelectedOp(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(semantic.SelectedOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(semantic.SelectedOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(semantic.SelectedOp)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(system.Action)//string": {
		Doc:   "system.Action.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val system.Action
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal system.Action
				if natOk {
					natVal, natValOk = nat.Value.(system.Action)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint
					if v, ok := arg0.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(system.Action)//string: arg 1: expected integer")
					}
					arg0Val = system.Action(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(system.ActionInputOp)//add": {
		Doc:   "system.ActionInputOp.Add",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val system.ActionInputOp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal system.ActionInputOp
				if natOk {
					natVal, natValOk = nat.Value.(system.ActionInputOp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint
					if v, ok := arg0.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(system.ActionInputOp)//add: arg 1: expected integer")
					}
					arg0Val = system.ActionInputOp(u)
				}
			}
			var arg1Val *op.Ops
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(system.ActionInputOp)//add: arg 2: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("Go(system.ActionInputOp)//add: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("Go(system.ActionInputOp)//add: arg 2: expected native")
			}
			arg0Val.Add(arg1Val)
			return arg0
		},
	},
	"Go(system.TextDirection)//axis": {
		Doc:   "system.TextDirection.Axis",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val system.TextDirection
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal system.TextDirection
				if natOk {
					natVal, natValOk = nat.Value.(system.TextDirection)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u byte
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(system.TextDirection)//axis: arg 1: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(system.TextDirection)//axis: arg 1: expected native")
					}
					arg0Val = system.TextDirection(u)
				}
			}
			res0 := arg0Val.Axis()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, byte(res0), "Go(byte)")
			return res0Obj
		},
	},
	"Go(system.TextDirection)//progression": {
		Doc:   "system.TextDirection.Progression",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val system.TextDirection
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal system.TextDirection
				if natOk {
					natVal, natValOk = nat.Value.(system.TextDirection)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u byte
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(system.TextDirection)//progression: arg 1: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(system.TextDirection)//progression: arg 1: expected native")
					}
					arg0Val = system.TextDirection(u)
				}
			}
			res0 := arg0Val.Progression()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, byte(res0), "Go(byte)")
			return res0Obj
		},
	},
	"Go(system.TextDirection)//string": {
		Doc:   "system.TextDirection.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val system.TextDirection
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal system.TextDirection
				if natOk {
					natVal, natValOk = nat.Value.(system.TextDirection)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u byte
					switch v := arg0.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(system.TextDirection)//string: arg 1: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(system.TextDirection)//string: arg 1: expected native")
					}
					arg0Val = system.TextDirection(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(text.Alignment)//align": {
		Doc:   "text.Alignment.Align",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text.Alignment
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal text.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(text.Alignment)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(text.Alignment)//align: arg 1: expected integer")
					}
					arg0Val = text.Alignment(u)
				}
			}
			var arg1Val system.TextDirection
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal system.TextDirection
				if natOk {
					natVal, natValOk = nat.Value.(system.TextDirection)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u byte
					switch v := arg1.(type) {
					case env.Native:
						var ok bool
						u, ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("Go(text.Alignment)//align: arg 2: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("Go(text.Alignment)//align: arg 2: expected native")
					}
					arg1Val = system.TextDirection(u)
				}
			}
			var arg2Val fixed.Int26_6
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(fixed.Int26_6)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("Go(text.Alignment)//align: arg 3: expected native of type fixed.Int26_6")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("Go(text.Alignment)//align: arg 3: expected native")
			}
			var arg3Val int
			if v, ok := arg3.(env.Integer); ok {
				arg3Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("Go(text.Alignment)//align: arg 4: expected integer")
			}
			res0 := arg0Val.Align(arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(fixed.Int26_6)")
			return res0Obj
		},
	},
	"Go(text.Alignment)//string": {
		Doc:   "text.Alignment.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text.Alignment
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal text.Alignment
				if natOk {
					natVal, natValOk = nat.Value.(text.Alignment)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint8
					if v, ok := arg0.(env.Integer); ok {
						u = uint8(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(text.Alignment)//string: arg 1: expected integer")
					}
					arg0Val = text.Alignment(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"Go(text.Flags)//string": {
		Doc:   "text.Flags.String",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val text.Flags
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal text.Flags
				if natOk {
					natVal, natValOk = nat.Value.(text.Flags)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u uint16
					if v, ok := arg0.(env.Integer); ok {
						u = uint16(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("Go(text.Flags)//string: arg 1: expected integer")
					}
					arg0Val = text.Flags(u)
				}
			}
			res0 := arg0Val.String()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			return res0Obj
		},
	},
	"app-any-orientation": {
		Doc:   "Get app.AnyOrientation value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(app.AnyOrientation)))
			return resObj
		},
	},
	"app-custom-renderer": {
		Doc:   "app.CustomRenderer",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("app-custom-renderer: arg 1: expected integer")
			}
			res0 := app.CustomRenderer(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *unit.Metric
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*unit.Metric)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-custom-renderer: arg 1: expected native of type *unit.Metric")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-custom-renderer: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-custom-renderer: arg 1: expected native")
				}
				var arg1Val *app.Config
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*app.Config)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-custom-renderer: arg 2: expected native of type *app.Config")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-custom-renderer: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-custom-renderer: arg 2: expected native")
				}
				(func(unit.Metric, *app.Config))(res0)(*arg0Val, arg1Val)
				return nil
			}, 2, false, false, "Returned func")
			return res0Obj
		},
	},
	"app-data-dir": {
		Doc:   "app.DataDir",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0, resErr := app.DataDir()
			var res0Obj env.Object
			res0Obj = *env.NewString(res0)
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"app-decorated": {
		Doc:   "app.Decorated",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val bool
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = v.Value != 0
			} else {
				ps.FailureFlag = true
				return env.NewError("app-decorated: arg 1: expected integer")
			}
			res0 := app.Decorated(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *unit.Metric
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*unit.Metric)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-decorated: arg 1: expected native of type *unit.Metric")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-decorated: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-decorated: arg 1: expected native")
				}
				var arg1Val *app.Config
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*app.Config)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-decorated: arg 2: expected native of type *app.Config")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-decorated: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-decorated: arg 2: expected native")
				}
				(func(unit.Metric, *app.Config))(res0)(*arg0Val, arg1Val)
				return nil
			}, 2, false, false, "Returned func")
			return res0Obj
		},
	},
	"app-fullscreen": {
		Doc:   "Get app.Fullscreen value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(app.Fullscreen)))
			return resObj
		},
	},
	"app-landscape-orientation": {
		Doc:   "Get app.LandscapeOrientation value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(app.LandscapeOrientation)))
			return resObj
		},
	},
	"app-main": {
		Doc:   "app.Main",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			app.Main()
			return nil
		},
	},
	"app-max-size": {
		Doc:   "app.MaxSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val unit.Dp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u float32
					if v, ok := arg0.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("app-max-size: arg 1: expected decimal")
					}
					arg0Val = unit.Dp(u)
				}
			}
			var arg1Val unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("app-max-size: arg 2: expected decimal")
					}
					arg1Val = unit.Dp(u)
				}
			}
			res0 := app.MaxSize(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *unit.Metric
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*unit.Metric)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-max-size: arg 1: expected native of type *unit.Metric")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-max-size: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-max-size: arg 1: expected native")
				}
				var arg1Val *app.Config
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*app.Config)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-max-size: arg 2: expected native of type *app.Config")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-max-size: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-max-size: arg 2: expected native")
				}
				(func(unit.Metric, *app.Config))(res0)(*arg0Val, arg1Val)
				return nil
			}, 2, false, false, "Returned func")
			return res0Obj
		},
	},
	"app-maximized": {
		Doc:   "Get app.Maximized value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(app.Maximized)))
			return resObj
		},
	},
	"app-min-size": {
		Doc:   "app.MinSize",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val unit.Dp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u float32
					if v, ok := arg0.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("app-min-size: arg 1: expected decimal")
					}
					arg0Val = unit.Dp(u)
				}
			}
			var arg1Val unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("app-min-size: arg 2: expected decimal")
					}
					arg1Val = unit.Dp(u)
				}
			}
			res0 := app.MinSize(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *unit.Metric
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*unit.Metric)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-min-size: arg 1: expected native of type *unit.Metric")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-min-size: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-min-size: arg 1: expected native")
				}
				var arg1Val *app.Config
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*app.Config)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-min-size: arg 2: expected native of type *app.Config")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-min-size: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-min-size: arg 2: expected native")
				}
				(func(unit.Metric, *app.Config))(res0)(*arg0Val, arg1Val)
				return nil
			}, 2, false, false, "Returned func")
			return res0Obj
		},
	},
	"app-minimized": {
		Doc:   "Get app.Minimized value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(app.Minimized)))
			return resObj
		},
	},
	"app-navigation-color": {
		Doc:   "app.NavigationColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-navigation-color: arg 1: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-navigation-color: arg 1: expected native")
			}
			res0 := app.NavigationColor(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *unit.Metric
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*unit.Metric)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-navigation-color: arg 1: expected native of type *unit.Metric")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-navigation-color: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-navigation-color: arg 1: expected native")
				}
				var arg1Val *app.Config
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*app.Config)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-navigation-color: arg 2: expected native of type *app.Config")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-navigation-color: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-navigation-color: arg 2: expected native")
				}
				(func(unit.Metric, *app.Config))(res0)(*arg0Val, arg1Val)
				return nil
			}, 2, false, false, "Returned func")
			return res0Obj
		},
	},
	"app-config": {
		Doc:   "Create a new app.Config struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &app.Config{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*app.Config)")
			return resObj
		},
	},
	"app-config-event": {
		Doc:   "Create a new app.ConfigEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &app.ConfigEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*app.ConfigEvent)")
			return resObj
		},
	},
	"app-context": {
		Doc:   "app.NewContext",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.Ops
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-context: arg 1: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("app-context: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("app-context: arg 1: expected native")
			}
			var arg1Val *app.FrameEvent
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*app.FrameEvent)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-context: arg 2: expected native of type *app.FrameEvent")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("app-context: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("app-context: arg 2: expected native")
			}
			res0 := app.NewContext(arg0Val, *arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Context)")
			return res0Obj
		},
	},
	"app-destroy-event": {
		Doc:   "Create a new app.DestroyEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &app.DestroyEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*app.DestroyEvent)")
			return resObj
		},
	},
	"app-frame-event": {
		Doc:   "Create a new app.FrameEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &app.FrameEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*app.FrameEvent)")
			return resObj
		},
	},
	"app-insets": {
		Doc:   "Create a new app.Insets struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &app.Insets{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*app.Insets)")
			return resObj
		},
	},
	"app-window": {
		Doc:   "Create a new app.Window struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &app.Window{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*app.Window)")
			return resObj
		},
	},
	"app-portrait-orientation": {
		Doc:   "Get app.PortraitOrientation value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(app.PortraitOrientation)))
			return resObj
		},
	},
	"app-size": {
		Doc:   "app.Size",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val unit.Dp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u float32
					if v, ok := arg0.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("app-size: arg 1: expected decimal")
					}
					arg0Val = unit.Dp(u)
				}
			}
			var arg1Val unit.Dp
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u float32
					if v, ok := arg1.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("app-size: arg 2: expected decimal")
					}
					arg1Val = unit.Dp(u)
				}
			}
			res0 := app.Size(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *unit.Metric
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*unit.Metric)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-size: arg 1: expected native of type *unit.Metric")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-size: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-size: arg 1: expected native")
				}
				var arg1Val *app.Config
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*app.Config)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-size: arg 2: expected native of type *app.Config")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-size: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-size: arg 2: expected native")
				}
				(func(unit.Metric, *app.Config))(res0)(*arg0Val, arg1Val)
				return nil
			}, 2, false, false, "Returned func")
			return res0Obj
		},
	},
	"app-status-color": {
		Doc:   "app.StatusColor",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val color.NRGBA
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("app-status-color: arg 1: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("app-status-color: arg 1: expected native")
			}
			res0 := app.StatusColor(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *unit.Metric
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*unit.Metric)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-status-color: arg 1: expected native of type *unit.Metric")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-status-color: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-status-color: arg 1: expected native")
				}
				var arg1Val *app.Config
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*app.Config)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-status-color: arg 2: expected native of type *app.Config")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-status-color: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-status-color: arg 2: expected native")
				}
				(func(unit.Metric, *app.Config))(res0)(*arg0Val, arg1Val)
				return nil
			}, 2, false, false, "Returned func")
			return res0Obj
		},
	},
	"app-title": {
		Doc:   "app.Title",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val string
			if v, ok := arg0.(env.String); ok {
				arg0Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("app-title: arg 1: expected string")
			}
			res0 := app.Title(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *unit.Metric
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*unit.Metric)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-title: arg 1: expected native of type *unit.Metric")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-title: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-title: arg 1: expected native")
				}
				var arg1Val *app.Config
				switch v := arg1.(type) {
				case env.Native:
					var ok bool
					arg1Val, ok = v.Value.(*app.Config)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("app-title: arg 2: expected native of type *app.Config")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("app-title: arg 2: expected integer to be 0 or nil")
					}
					arg1Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("app-title: arg 2: expected native")
				}
				(func(unit.Metric, *app.Config))(res0)(*arg0Val, arg1Val)
				return nil
			}, 2, false, false, "Returned func")
			return res0Obj
		},
	},
	"app-windowed": {
		Doc:   "Get app.Windowed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(app.Windowed)))
			return resObj
		},
	},
	"clip-op": {
		Doc:   "Create a new clip.Op struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &clip.Op{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*clip.Op)")
			return resObj
		},
	},
	"clip-outline": {
		Doc:   "Create a new clip.Outline struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &clip.Outline{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*clip.Outline)")
			return resObj
		},
	},
	"clip-path": {
		Doc:   "Create a new clip.Path struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &clip.Path{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*clip.Path)")
			return resObj
		},
	},
	"clip-path-spec": {
		Doc:   "Create a new clip.PathSpec struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &clip.PathSpec{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*clip.PathSpec)")
			return resObj
		},
	},
	"clip-r-rect": {
		Doc:   "Create a new clip.RRect struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &clip.RRect{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*clip.RRect)")
			return resObj
		},
	},
	"clip-stack": {
		Doc:   "Create a new clip.Stack struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &clip.Stack{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*clip.Stack)")
			return resObj
		},
	},
	"clip-stroke": {
		Doc:   "Create a new clip.Stroke struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &clip.Stroke{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*clip.Stroke)")
			return resObj
		},
	},
	"clip-uniform-r-rect": {
		Doc:   "clip.UniformRRect",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Rectangle
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Rectangle)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("clip-uniform-r-rect: arg 1: expected native of type image.Rectangle")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("clip-uniform-r-rect: arg 1: expected native")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("clip-uniform-r-rect: arg 2: expected integer")
			}
			res0 := clip.UniformRRect(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*clip.RRect)")
			return res0Obj
		},
	},
	"clipboard-read-cmd": {
		Doc:   "Create a new clipboard.ReadCmd struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &clipboard.ReadCmd{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*clipboard.ReadCmd)")
			return resObj
		},
	},
	"clipboard-write-cmd": {
		Doc:   "Create a new clipboard.WriteCmd struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &clipboard.WriteCmd{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*clipboard.WriteCmd)")
			return resObj
		},
	},
	"event-op": {
		Doc:   "event.Op",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.Ops
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("event-op: arg 1: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("event-op: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("event-op: arg 1: expected native")
			}
			var arg1Val event.Tag
			switch v := arg1.(type) {
			case env.RyeCtx:
				var err error
				arg1Val, err = ctxTo_event_Tag(ps, v)
				if err != nil {
					ps.FailureFlag = true
					return env.NewError("event-op: arg 2: " + err.Error() + "")
				}
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(event.Tag)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("event-op: arg 2: expected native of type event.Tag")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("event-op: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("event-op: arg 2: expected native")
			}
			event.Op(arg0Val, arg1Val)
			return nil
		},
	},
	"f-32-affine-2-d": {
		Doc:   "Create a new f32.Affine2D struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &f32.Affine2D{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*f32.Affine2D)")
			return resObj
		},
	},
	"f-32-point": {
		Doc:   "Create a new f32.Point struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &f32.Point{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*f32.Point)")
			return resObj
		},
	},
	"f-32-pt": {
		Doc:   "f32.Pt",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("f-32-pt: arg 1: expected decimal")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("f-32-pt: arg 2: expected decimal")
			}
			res0 := f32.Pt(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"font-black": {
		Doc:   "Get font.Black value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.Black)))
			return resObj
		},
	},
	"font-bold": {
		Doc:   "Get font.Bold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.Bold)))
			return resObj
		},
	},
	"font-extra-bold": {
		Doc:   "Get font.ExtraBold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.ExtraBold)))
			return resObj
		},
	},
	"font-extra-light": {
		Doc:   "Get font.ExtraLight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.ExtraLight)))
			return resObj
		},
	},
	"font-italic": {
		Doc:   "Get font.Italic value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.Italic)))
			return resObj
		},
	},
	"font-light": {
		Doc:   "Get font.Light value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.Light)))
			return resObj
		},
	},
	"font-medium": {
		Doc:   "Get font.Medium value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.Medium)))
			return resObj
		},
	},
	"font-font": {
		Doc:   "Create a new font.Font struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &font.Font{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*font.Font)")
			return resObj
		},
	},
	"font-font-face": {
		Doc:   "Create a new font.FontFace struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &font.FontFace{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*font.FontFace)")
			return resObj
		},
	},
	"font-normal": {
		Doc:   "Get font.Normal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.Normal)))
			return resObj
		},
	},
	"font-regular": {
		Doc:   "Get font.Regular value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.Regular)))
			return resObj
		},
	},
	"font-semi-bold": {
		Doc:   "Get font.SemiBold value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.SemiBold)))
			return resObj
		},
	},
	"font-thin": {
		Doc:   "Get font.Thin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(font.Thin)))
			return resObj
		},
	},
	"gesture-both": {
		Doc:   "Get gesture.Both value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(gesture.Both)))
			return resObj
		},
	},
	"gesture-horizontal": {
		Doc:   "Get gesture.Horizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(gesture.Horizontal)))
			return resObj
		},
	},
	"gesture-kind-cancel": {
		Doc:   "Get gesture.KindCancel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(gesture.KindCancel)))
			return resObj
		},
	},
	"gesture-kind-click": {
		Doc:   "Get gesture.KindClick value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(gesture.KindClick)))
			return resObj
		},
	},
	"gesture-kind-press": {
		Doc:   "Get gesture.KindPress value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(gesture.KindPress)))
			return resObj
		},
	},
	"gesture-click": {
		Doc:   "Create a new gesture.Click struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &gesture.Click{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*gesture.Click)")
			return resObj
		},
	},
	"gesture-click-event": {
		Doc:   "Create a new gesture.ClickEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &gesture.ClickEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*gesture.ClickEvent)")
			return resObj
		},
	},
	"gesture-drag": {
		Doc:   "Create a new gesture.Drag struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &gesture.Drag{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*gesture.Drag)")
			return resObj
		},
	},
	"gesture-hover": {
		Doc:   "Create a new gesture.Hover struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &gesture.Hover{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*gesture.Hover)")
			return resObj
		},
	},
	"gesture-scroll": {
		Doc:   "Create a new gesture.Scroll struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &gesture.Scroll{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*gesture.Scroll)")
			return resObj
		},
	},
	"gesture-state-dragging": {
		Doc:   "Get gesture.StateDragging value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(gesture.StateDragging)))
			return resObj
		},
	},
	"gesture-state-flinging": {
		Doc:   "Get gesture.StateFlinging value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(gesture.StateFlinging)))
			return resObj
		},
	},
	"gesture-state-idle": {
		Doc:   "Get gesture.StateIdle value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(gesture.StateIdle)))
			return resObj
		},
	},
	"gesture-vertical": {
		Doc:   "Get gesture.Vertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(gesture.Vertical)))
			return resObj
		},
	},
	"gofont-collection": {
		Doc:   "gofont.Collection",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := gofont.Collection()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(font.FontFace)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"gofont-regular": {
		Doc:   "gofont.Regular",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := gofont.Regular()
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(font.FontFace)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			return res0Obj
		},
	},
	"gpu-gpu": {
		Doc:   "gpu.New",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val gpu.API
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(gpu.API)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("gpu-gpu: arg 1: expected native of type gpu.API")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("gpu-gpu: arg 1: expected native")
			}
			res0, resErr := gpu.New(arg0Val)
			var res0Obj env.Object
			res0Obj = ifaceToNative(ps.Idx, res0, "Go(gpu.GPU)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"gpu-fbo": {
		Doc:   "Create a new gpu.FBO struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &gpu.FBO{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*gpu.FBO)")
			return resObj
		},
	},
	"headless-window": {
		Doc:   "headless.NewWindow",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val int
			if v, ok := arg0.(env.Integer); ok {
				arg0Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("headless-window: arg 1: expected integer")
			}
			var arg1Val int
			if v, ok := arg1.(env.Integer); ok {
				arg1Val = int(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("headless-window: arg 2: expected integer")
			}
			res0, resErr := headless.NewWindow(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*headless.Window)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"input-click-gesture": {
		Doc:   "Get input.ClickGesture value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(input.ClickGesture)))
			return resObj
		},
	},
	"input-editor-state": {
		Doc:   "Create a new input.EditorState struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &input.EditorState{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*input.EditorState)")
			return resObj
		},
	},
	"input-router": {
		Doc:   "Create a new input.Router struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &input.Router{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*input.Router)")
			return resObj
		},
	},
	"input-semantic-desc": {
		Doc:   "Create a new input.SemanticDesc struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &input.SemanticDesc{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*input.SemanticDesc)")
			return resObj
		},
	},
	"input-semantic-node": {
		Doc:   "Create a new input.SemanticNode struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &input.SemanticNode{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*input.SemanticNode)")
			return resObj
		},
	},
	"input-source": {
		Doc:   "Create a new input.Source struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &input.Source{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*input.Source)")
			return resObj
		},
	},
	"input-system-event": {
		Doc:   "Create a new input.SystemEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &input.SystemEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*input.SystemEvent)")
			return resObj
		},
	},
	"input-scroll-gesture": {
		Doc:   "Get input.ScrollGesture value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(input.ScrollGesture)))
			return resObj
		},
	},
	"input-text-input-close": {
		Doc:   "Get input.TextInputClose value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(input.TextInputClose)))
			return resObj
		},
	},
	"input-text-input-keep": {
		Doc:   "Get input.TextInputKeep value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(input.TextInputKeep)))
			return resObj
		},
	},
	"input-text-input-open": {
		Doc:   "Get input.TextInputOpen value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(input.TextInputOpen)))
			return resObj
		},
	},
	"key-focus-backward": {
		Doc:   "Get key.FocusBackward value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(key.FocusBackward)))
			return resObj
		},
	},
	"key-focus-down": {
		Doc:   "Get key.FocusDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(key.FocusDown)))
			return resObj
		},
	},
	"key-focus-forward": {
		Doc:   "Get key.FocusForward value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(key.FocusForward)))
			return resObj
		},
	},
	"key-focus-left": {
		Doc:   "Get key.FocusLeft value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(key.FocusLeft)))
			return resObj
		},
	},
	"key-focus-right": {
		Doc:   "Get key.FocusRight value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(key.FocusRight)))
			return resObj
		},
	},
	"key-focus-up": {
		Doc:   "Get key.FocusUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(key.FocusUp)))
			return resObj
		},
	},
	"key-hint-any": {
		Doc:   "Get key.HintAny value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(key.HintAny)))
			return resObj
		},
	},
	"key-hint-email": {
		Doc:   "Get key.HintEmail value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(key.HintEmail)))
			return resObj
		},
	},
	"key-hint-numeric": {
		Doc:   "Get key.HintNumeric value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(key.HintNumeric)))
			return resObj
		},
	},
	"key-hint-password": {
		Doc:   "Get key.HintPassword value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(key.HintPassword)))
			return resObj
		},
	},
	"key-hint-telephone": {
		Doc:   "Get key.HintTelephone value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(key.HintTelephone)))
			return resObj
		},
	},
	"key-hint-text": {
		Doc:   "Get key.HintText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(key.HintText)))
			return resObj
		},
	},
	"key-hint-url": {
		Doc:   "Get key.HintURL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(key.HintURL)))
			return resObj
		},
	},
	"key-mod-alt": {
		Doc:   "Get key.ModAlt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(key.ModAlt)))
			return resObj
		},
	},
	"key-mod-command": {
		Doc:   "Get key.ModCommand value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(key.ModCommand)))
			return resObj
		},
	},
	"key-mod-ctrl": {
		Doc:   "Get key.ModCtrl value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(key.ModCtrl)))
			return resObj
		},
	},
	"key-mod-shift": {
		Doc:   "Get key.ModShift value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(key.ModShift)))
			return resObj
		},
	},
	"key-mod-super": {
		Doc:   "Get key.ModSuper value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint32(key.ModSuper)))
			return resObj
		},
	},
	"key-name-alt": {
		Doc:   "Get key.NameAlt value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameAlt))
			return resObj
		},
	},
	"key-name-back": {
		Doc:   "Get key.NameBack value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameBack))
			return resObj
		},
	},
	"key-name-command": {
		Doc:   "Get key.NameCommand value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameCommand))
			return resObj
		},
	},
	"key-name-ctrl": {
		Doc:   "Get key.NameCtrl value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameCtrl))
			return resObj
		},
	},
	"key-name-delete-backward": {
		Doc:   "Get key.NameDeleteBackward value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameDeleteBackward))
			return resObj
		},
	},
	"key-name-delete-forward": {
		Doc:   "Get key.NameDeleteForward value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameDeleteForward))
			return resObj
		},
	},
	"key-name-down-arrow": {
		Doc:   "Get key.NameDownArrow value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameDownArrow))
			return resObj
		},
	},
	"key-name-end": {
		Doc:   "Get key.NameEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameEnd))
			return resObj
		},
	},
	"key-name-enter": {
		Doc:   "Get key.NameEnter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameEnter))
			return resObj
		},
	},
	"key-name-escape": {
		Doc:   "Get key.NameEscape value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameEscape))
			return resObj
		},
	},
	"key-name-f-1": {
		Doc:   "Get key.NameF1 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF1))
			return resObj
		},
	},
	"key-name-f-10": {
		Doc:   "Get key.NameF10 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF10))
			return resObj
		},
	},
	"key-name-f-11": {
		Doc:   "Get key.NameF11 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF11))
			return resObj
		},
	},
	"key-name-f-12": {
		Doc:   "Get key.NameF12 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF12))
			return resObj
		},
	},
	"key-name-f-2": {
		Doc:   "Get key.NameF2 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF2))
			return resObj
		},
	},
	"key-name-f-3": {
		Doc:   "Get key.NameF3 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF3))
			return resObj
		},
	},
	"key-name-f-4": {
		Doc:   "Get key.NameF4 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF4))
			return resObj
		},
	},
	"key-name-f-5": {
		Doc:   "Get key.NameF5 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF5))
			return resObj
		},
	},
	"key-name-f-6": {
		Doc:   "Get key.NameF6 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF6))
			return resObj
		},
	},
	"key-name-f-7": {
		Doc:   "Get key.NameF7 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF7))
			return resObj
		},
	},
	"key-name-f-8": {
		Doc:   "Get key.NameF8 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF8))
			return resObj
		},
	},
	"key-name-f-9": {
		Doc:   "Get key.NameF9 value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameF9))
			return resObj
		},
	},
	"key-name-home": {
		Doc:   "Get key.NameHome value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameHome))
			return resObj
		},
	},
	"key-name-left-arrow": {
		Doc:   "Get key.NameLeftArrow value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameLeftArrow))
			return resObj
		},
	},
	"key-name-page-down": {
		Doc:   "Get key.NamePageDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NamePageDown))
			return resObj
		},
	},
	"key-name-page-up": {
		Doc:   "Get key.NamePageUp value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NamePageUp))
			return resObj
		},
	},
	"key-name-return": {
		Doc:   "Get key.NameReturn value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameReturn))
			return resObj
		},
	},
	"key-name-right-arrow": {
		Doc:   "Get key.NameRightArrow value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameRightArrow))
			return resObj
		},
	},
	"key-name-shift": {
		Doc:   "Get key.NameShift value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameShift))
			return resObj
		},
	},
	"key-name-space": {
		Doc:   "Get key.NameSpace value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameSpace))
			return resObj
		},
	},
	"key-name-super": {
		Doc:   "Get key.NameSuper value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameSuper))
			return resObj
		},
	},
	"key-name-tab": {
		Doc:   "Get key.NameTab value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameTab))
			return resObj
		},
	},
	"key-name-up-arrow": {
		Doc:   "Get key.NameUpArrow value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewString(string(key.NameUpArrow))
			return resObj
		},
	},
	"key-caret": {
		Doc:   "Create a new key.Caret struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.Caret{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.Caret)")
			return resObj
		},
	},
	"key-edit-event": {
		Doc:   "Create a new key.EditEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.EditEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.EditEvent)")
			return resObj
		},
	},
	"key-event": {
		Doc:   "Create a new key.Event struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.Event{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.Event)")
			return resObj
		},
	},
	"key-filter": {
		Doc:   "Create a new key.Filter struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.Filter{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.Filter)")
			return resObj
		},
	},
	"key-focus-cmd": {
		Doc:   "Create a new key.FocusCmd struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.FocusCmd{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.FocusCmd)")
			return resObj
		},
	},
	"key-focus-event": {
		Doc:   "Create a new key.FocusEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.FocusEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.FocusEvent)")
			return resObj
		},
	},
	"key-focus-filter": {
		Doc:   "Create a new key.FocusFilter struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.FocusFilter{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.FocusFilter)")
			return resObj
		},
	},
	"key-input-hint-op": {
		Doc:   "Create a new key.InputHintOp struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.InputHintOp{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.InputHintOp)")
			return resObj
		},
	},
	"key-range": {
		Doc:   "Create a new key.Range struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.Range{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.Range)")
			return resObj
		},
	},
	"key-selection-cmd": {
		Doc:   "Create a new key.SelectionCmd struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.SelectionCmd{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.SelectionCmd)")
			return resObj
		},
	},
	"key-snippet": {
		Doc:   "Create a new key.Snippet struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.Snippet{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.Snippet)")
			return resObj
		},
	},
	"key-snippet-cmd": {
		Doc:   "Create a new key.SnippetCmd struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.SnippetCmd{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.SnippetCmd)")
			return resObj
		},
	},
	"key-soft-keyboard-cmd": {
		Doc:   "Create a new key.SoftKeyboardCmd struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &key.SoftKeyboardCmd{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*key.SoftKeyboardCmd)")
			return resObj
		},
	},
	"key-press": {
		Doc:   "Get key.Press value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(key.Press)))
			return resObj
		},
	},
	"key-release": {
		Doc:   "Get key.Release value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(key.Release)))
			return resObj
		},
	},
	"layout-baseline": {
		Doc:   "Get layout.Baseline value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.Baseline)))
			return resObj
		},
	},
	"layout-center": {
		Doc:   "Get layout.Center value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.Center)))
			return resObj
		},
	},
	"layout-e": {
		Doc:   "Get layout.E value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.E)))
			return resObj
		},
	},
	"layout-end": {
		Doc:   "Get layout.End value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.End)))
			return resObj
		},
	},
	"layout-exact": {
		Doc:   "layout.Exact",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-exact: arg 1: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("layout-exact: arg 1: expected native")
			}
			res0 := layout.Exact(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Constraints)")
			return res0Obj
		},
	},
	"layout-expanded": {
		Doc:   "layout.Expanded",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Widget
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg0.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("layout-expanded: arg 1: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"layout-expanded: arg 1: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"layout-expanded: arg 1: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("layout-expanded: arg 1: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("layout-expanded: arg 1: expected function or nil")
					}
					arg0Val = layout.Widget(u)
				}
			}
			res0 := layout.Expanded(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.StackChild)")
			return res0Obj
		},
	},
	"layout-f-pt": {
		Doc:   "layout.FPt",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("layout-f-pt: arg 1: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("layout-f-pt: arg 1: expected native")
			}
			res0 := layout.FPt(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*f32.Point)")
			return res0Obj
		},
	},
	"layout-flexed": {
		Doc:   "layout.Flexed",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val float32
			if v, ok := arg0.(env.Decimal); ok {
				arg0Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("layout-flexed: arg 1: expected decimal")
			}
			var arg1Val layout.Widget
			{
				nat, natOk := arg1.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg1Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg1.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("layout-flexed: arg 2: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"layout-flexed: arg 2: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"layout-flexed: arg 2: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("layout-flexed: arg 2: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("layout-flexed: arg 2: expected function or nil")
					}
					arg1Val = layout.Widget(u)
				}
			}
			res0 := layout.Flexed(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.FlexChild)")
			return res0Obj
		},
	},
	"layout-horizontal": {
		Doc:   "Get layout.Horizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.Horizontal)))
			return resObj
		},
	},
	"layout-middle": {
		Doc:   "Get layout.Middle value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.Middle)))
			return resObj
		},
	},
	"layout-n": {
		Doc:   "Get layout.N value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.N)))
			return resObj
		},
	},
	"layout-ne": {
		Doc:   "Get layout.NE value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.NE)))
			return resObj
		},
	},
	"layout-background": {
		Doc:   "Create a new layout.Background struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.Background{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.Background)")
			return resObj
		},
	},
	"layout-constraints": {
		Doc:   "Create a new layout.Constraints struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.Constraints{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.Constraints)")
			return resObj
		},
	},
	"layout-context": {
		Doc:   "Create a new layout.Context struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.Context{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.Context)")
			return resObj
		},
	},
	"layout-dimensions": {
		Doc:   "Create a new layout.Dimensions struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.Dimensions{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.Dimensions)")
			return resObj
		},
	},
	"layout-flex": {
		Doc:   "Create a new layout.Flex struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.Flex{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.Flex)")
			return resObj
		},
	},
	"layout-flex-child": {
		Doc:   "Create a new layout.FlexChild struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.FlexChild{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.FlexChild)")
			return resObj
		},
	},
	"layout-inset": {
		Doc:   "Create a new layout.Inset struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.Inset{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.Inset)")
			return resObj
		},
	},
	"layout-list": {
		Doc:   "Create a new layout.List struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.List{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.List)")
			return resObj
		},
	},
	"layout-position": {
		Doc:   "Create a new layout.Position struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.Position{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.Position)")
			return resObj
		},
	},
	"layout-spacer": {
		Doc:   "Create a new layout.Spacer struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.Spacer{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.Spacer)")
			return resObj
		},
	},
	"layout-stack": {
		Doc:   "Create a new layout.Stack struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.Stack{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.Stack)")
			return resObj
		},
	},
	"layout-stack-child": {
		Doc:   "Create a new layout.StackChild struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &layout.StackChild{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*layout.StackChild)")
			return resObj
		},
	},
	"layout-nw": {
		Doc:   "Get layout.NW value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.NW)))
			return resObj
		},
	},
	"layout-rigid": {
		Doc:   "layout.Rigid",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Widget
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg0.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("layout-rigid: arg 1: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"layout-rigid: arg 1: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"layout-rigid: arg 1: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("layout-rigid: arg 1: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("layout-rigid: arg 1: expected function or nil")
					}
					arg0Val = layout.Widget(u)
				}
			}
			res0 := layout.Rigid(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.FlexChild)")
			return res0Obj
		},
	},
	"layout-s": {
		Doc:   "Get layout.S value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.S)))
			return resObj
		},
	},
	"layout-se": {
		Doc:   "Get layout.SE value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.SE)))
			return resObj
		},
	},
	"layout-space-around": {
		Doc:   "Get layout.SpaceAround value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.SpaceAround)))
			return resObj
		},
	},
	"layout-space-between": {
		Doc:   "Get layout.SpaceBetween value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.SpaceBetween)))
			return resObj
		},
	},
	"layout-space-end": {
		Doc:   "Get layout.SpaceEnd value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.SpaceEnd)))
			return resObj
		},
	},
	"layout-space-evenly": {
		Doc:   "Get layout.SpaceEvenly value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.SpaceEvenly)))
			return resObj
		},
	},
	"layout-space-sides": {
		Doc:   "Get layout.SpaceSides value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.SpaceSides)))
			return resObj
		},
	},
	"layout-space-start": {
		Doc:   "Get layout.SpaceStart value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.SpaceStart)))
			return resObj
		},
	},
	"layout-stacked": {
		Doc:   "layout.Stacked",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val layout.Widget
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg0.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("layout-stacked: arg 1: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"layout-stacked: arg 1: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"layout-stacked: arg 1: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("layout-stacked: arg 1: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("layout-stacked: arg 1: expected function or nil")
					}
					arg0Val = layout.Widget(u)
				}
			}
			res0 := layout.Stacked(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.StackChild)")
			return res0Obj
		},
	},
	"layout-start": {
		Doc:   "Get layout.Start value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.Start)))
			return resObj
		},
	},
	"layout-sw": {
		Doc:   "Get layout.SW value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.SW)))
			return resObj
		},
	},
	"layout-uniform-inset": {
		Doc:   "layout.UniformInset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val unit.Dp
			{
				nat, natOk := arg0.(env.Native)
				var natValOk bool
				var natVal unit.Dp
				if natOk {
					natVal, natValOk = nat.Value.(unit.Dp)
				}
				if natValOk {
					arg0Val = natVal
				} else {
					var u float32
					if v, ok := arg0.(env.Decimal); ok {
						u = float32(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("layout-uniform-inset: arg 1: expected decimal")
					}
					arg0Val = unit.Dp(u)
				}
			}
			res0 := layout.UniformInset(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Inset)")
			return res0Obj
		},
	},
	"layout-vertical": {
		Doc:   "Get layout.Vertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.Vertical)))
			return resObj
		},
	},
	"layout-w": {
		Doc:   "Get layout.W value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(layout.W)))
			return resObj
		},
	},
	"material-body-1": {
		Doc:   "material.Body1",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-body-1: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-body-1: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-body-1: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-body-1: arg 2: expected string")
			}
			res0 := material.Body1(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-body-2": {
		Doc:   "material.Body2",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-body-2: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-body-2: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-body-2: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-body-2: arg 2: expected string")
			}
			res0 := material.Body2(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-button": {
		Doc:   "material.Button",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-button: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-button: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-button: arg 1: expected native")
			}
			var arg1Val *widget.Clickable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-button: arg 2: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-button: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-button: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-button: arg 3: expected string")
			}
			res0 := material.Button(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.ButtonStyle)")
			return res0Obj
		},
	},
	"material-button-layout": {
		Doc:   "material.ButtonLayout",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-button-layout: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-button-layout: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-button-layout: arg 1: expected native")
			}
			var arg1Val *widget.Clickable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-button-layout: arg 2: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-button-layout: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-button-layout: arg 2: expected native")
			}
			res0 := material.ButtonLayout(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.ButtonLayoutStyle)")
			return res0Obj
		},
	},
	"material-caption": {
		Doc:   "material.Caption",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-caption: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-caption: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-caption: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-caption: arg 2: expected string")
			}
			res0 := material.Caption(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-check-box": {
		Doc:   "material.CheckBox",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-check-box: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-check-box: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-check-box: arg 1: expected native")
			}
			var arg1Val *widget.Bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-check-box: arg 2: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-check-box: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-check-box: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-check-box: arg 3: expected string")
			}
			res0 := material.CheckBox(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.CheckBoxStyle)")
			return res0Obj
		},
	},
	"material-clickable": {
		Doc:   "material.Clickable",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *layout.Context
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*layout.Context)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-clickable: arg 1: expected native of type *layout.Context")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-clickable: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-clickable: arg 1: expected native")
			}
			var arg1Val *widget.Clickable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-clickable: arg 2: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-clickable: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-clickable: arg 2: expected native")
			}
			var arg2Val layout.Widget
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal layout.Widget
				if natOk {
					natVal, natValOk = nat.Value.(layout.Widget)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u func(layout.Context) layout.Dimensions
					switch fn := arg2.(type) {
					case env.Function:
						if fn.Argsn != 1 {
							ps.FailureFlag = true
							return env.NewError("material-clickable: arg 3: function has invalid number of arguments (expected 1)")
						}
						u = func(farg0 layout.Context) layout.Dimensions {
							var farg0Val env.Object
							farg0Val = *env.NewNative(ps.Idx, &farg0, "Go(*layout.Context)")
							actualFn := fn
							_ = actualFn
							evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
							var res layout.Dimensions
							switch v := ps.Res.(type) {
							case env.Native:
								var ok bool
								res, ok = v.Value.(layout.Dimensions)
								if !ok {
									fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
										"material-clickable: arg 3: callback result: expected native of type layout.Dimensions",
										actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
										actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
									)
									return res
								}
							default:
								fmt.Printf("\033[31mError: \033[1m%v\033[m\n\033[31mFrom function \033[1m%v { %v }\033[m\n",
									"material-clickable: arg 3: callback result: expected native",
									actualFn.Spec.Series.PositionAndSurroundingElements(*ps.Idx),
									actualFn.Body.Series.PositionAndSurroundingElements(*ps.Idx),
								)
								return res
							}
							return res
						}
					case env.Integer:
						if fn.Value != 0 {
							ps.FailureFlag = true
							return env.NewError("material-clickable: arg 3: expected integer to be 0 or nil")
						}
						u = nil
					default:
						ps.FailureFlag = true
						return env.NewError("material-clickable: arg 3: expected function or nil")
					}
					arg2Val = layout.Widget(u)
				}
			}
			res0 := material.Clickable(*arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*layout.Dimensions)")
			return res0Obj
		},
	},
	"material-decorations": {
		Doc:   "material.Decorations",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-decorations: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-decorations: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-decorations: arg 1: expected native")
			}
			var arg1Val *widget.Decorations
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Decorations)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-decorations: arg 2: expected native of type *widget.Decorations")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-decorations: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-decorations: arg 2: expected native")
			}
			var arg2Val system.Action
			{
				nat, natOk := arg2.(env.Native)
				var natValOk bool
				var natVal system.Action
				if natOk {
					natVal, natValOk = nat.Value.(system.Action)
				}
				if natValOk {
					arg2Val = natVal
				} else {
					var u uint
					if v, ok := arg2.(env.Integer); ok {
						u = uint(v.Value)
					} else {
						ps.FailureFlag = true
						return env.NewError("material-decorations: arg 3: expected integer")
					}
					arg2Val = system.Action(u)
				}
			}
			var arg3Val string
			if v, ok := arg3.(env.String); ok {
				arg3Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-decorations: arg 4: expected string")
			}
			res0 := material.Decorations(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.DecorationsStyle)")
			return res0Obj
		},
	},
	"material-editor": {
		Doc:   "material.Editor",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-editor: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-editor: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-editor: arg 1: expected native")
			}
			var arg1Val *widget.Editor
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Editor)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-editor: arg 2: expected native of type *widget.Editor")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-editor: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-editor: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-editor: arg 3: expected string")
			}
			res0 := material.Editor(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.EditorStyle)")
			return res0Obj
		},
	},
	"material-h-1": {
		Doc:   "material.H1",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-h-1: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-h-1: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-h-1: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-h-1: arg 2: expected string")
			}
			res0 := material.H1(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-h-2": {
		Doc:   "material.H2",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-h-2: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-h-2: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-h-2: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-h-2: arg 2: expected string")
			}
			res0 := material.H2(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-h-3": {
		Doc:   "material.H3",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-h-3: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-h-3: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-h-3: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-h-3: arg 2: expected string")
			}
			res0 := material.H3(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-h-4": {
		Doc:   "material.H4",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-h-4: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-h-4: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-h-4: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-h-4: arg 2: expected string")
			}
			res0 := material.H4(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-h-5": {
		Doc:   "material.H5",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-h-5: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-h-5: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-h-5: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-h-5: arg 2: expected string")
			}
			res0 := material.H5(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-h-6": {
		Doc:   "material.H6",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-h-6: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-h-6: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-h-6: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-h-6: arg 2: expected string")
			}
			res0 := material.H6(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-icon-button": {
		Doc:   "material.IconButton",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-icon-button: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-icon-button: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-icon-button: arg 1: expected native")
			}
			var arg1Val *widget.Clickable
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Clickable)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-icon-button: arg 2: expected native of type *widget.Clickable")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-icon-button: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-icon-button: arg 2: expected native")
			}
			var arg2Val *widget.Icon
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*widget.Icon)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-icon-button: arg 3: expected native of type *widget.Icon")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-icon-button: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-icon-button: arg 3: expected native")
			}
			var arg3Val string
			if v, ok := arg3.(env.String); ok {
				arg3Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-icon-button: arg 4: expected string")
			}
			res0 := material.IconButton(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.IconButtonStyle)")
			return res0Obj
		},
	},
	"material-label": {
		Doc:   "material.Label",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-label: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-label: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-label: arg 1: expected native")
			}
			var arg1Val unit.Sp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(unit.Sp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-label: arg 2: expected native of type unit.Sp")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("material-label: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-label: arg 3: expected string")
			}
			res0 := material.Label(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-list": {
		Doc:   "material.List",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-list: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-list: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-list: arg 1: expected native")
			}
			var arg1Val *widget.List
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.List)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-list: arg 2: expected native of type *widget.List")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-list: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-list: arg 2: expected native")
			}
			res0 := material.List(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.ListStyle)")
			return res0Obj
		},
	},
	"material-loader": {
		Doc:   "material.Loader",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-loader: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-loader: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-loader: arg 1: expected native")
			}
			res0 := material.Loader(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LoaderStyle)")
			return res0Obj
		},
	},
	"material-button-layout-style": {
		Doc:   "Create a new material.ButtonLayoutStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.ButtonLayoutStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.ButtonLayoutStyle)")
			return resObj
		},
	},
	"material-button-style": {
		Doc:   "Create a new material.ButtonStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.ButtonStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.ButtonStyle)")
			return resObj
		},
	},
	"material-check-box-style": {
		Doc:   "Create a new material.CheckBoxStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.CheckBoxStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.CheckBoxStyle)")
			return resObj
		},
	},
	"material-decorations-style": {
		Doc:   "Create a new material.DecorationsStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.DecorationsStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.DecorationsStyle)")
			return resObj
		},
	},
	"material-editor-style": {
		Doc:   "Create a new material.EditorStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.EditorStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.EditorStyle)")
			return resObj
		},
	},
	"material-icon-button-style": {
		Doc:   "Create a new material.IconButtonStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.IconButtonStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.IconButtonStyle)")
			return resObj
		},
	},
	"material-label-style": {
		Doc:   "Create a new material.LabelStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.LabelStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.LabelStyle)")
			return resObj
		},
	},
	"material-list-style": {
		Doc:   "Create a new material.ListStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.ListStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.ListStyle)")
			return resObj
		},
	},
	"material-loader-style": {
		Doc:   "Create a new material.LoaderStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.LoaderStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.LoaderStyle)")
			return resObj
		},
	},
	"material-palette": {
		Doc:   "Create a new material.Palette struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.Palette{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.Palette)")
			return resObj
		},
	},
	"material-progress-bar-style": {
		Doc:   "Create a new material.ProgressBarStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.ProgressBarStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.ProgressBarStyle)")
			return resObj
		},
	},
	"material-progress-circle-style": {
		Doc:   "Create a new material.ProgressCircleStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.ProgressCircleStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.ProgressCircleStyle)")
			return resObj
		},
	},
	"material-radio-button-style": {
		Doc:   "Create a new material.RadioButtonStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.RadioButtonStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.RadioButtonStyle)")
			return resObj
		},
	},
	"material-scroll-indicator-style": {
		Doc:   "Create a new material.ScrollIndicatorStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.ScrollIndicatorStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.ScrollIndicatorStyle)")
			return resObj
		},
	},
	"material-scroll-track-style": {
		Doc:   "Create a new material.ScrollTrackStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.ScrollTrackStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.ScrollTrackStyle)")
			return resObj
		},
	},
	"material-scrollbar-style": {
		Doc:   "Create a new material.ScrollbarStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.ScrollbarStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.ScrollbarStyle)")
			return resObj
		},
	},
	"material-slider-style": {
		Doc:   "Create a new material.SliderStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.SliderStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.SliderStyle)")
			return resObj
		},
	},
	"material-switch-style": {
		Doc:   "Create a new material.SwitchStyle struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &material.SwitchStyle{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*material.SwitchStyle)")
			return resObj
		},
	},
	"material-theme": {
		Doc:   "material.NewTheme",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := material.NewTheme()
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*material.Theme)")
			return res0Obj
		},
	},
	"material-occupy": {
		Doc:   "Get material.Occupy value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(material.Occupy)))
			return resObj
		},
	},
	"material-overlay": {
		Doc:   "Get material.Overlay value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(material.Overlay)))
			return resObj
		},
	},
	"material-overline": {
		Doc:   "material.Overline",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-overline: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-overline: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-overline: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-overline: arg 2: expected string")
			}
			res0 := material.Overline(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-progress-bar": {
		Doc:   "material.ProgressBar",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-progress-bar: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-progress-bar: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-progress-bar: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-progress-bar: arg 2: expected decimal")
			}
			res0 := material.ProgressBar(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.ProgressBarStyle)")
			return res0Obj
		},
	},
	"material-progress-circle": {
		Doc:   "material.ProgressCircle",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-progress-circle: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-progress-circle: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-progress-circle: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-progress-circle: arg 2: expected decimal")
			}
			res0 := material.ProgressCircle(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.ProgressCircleStyle)")
			return res0Obj
		},
	},
	"material-radio-button": {
		Doc:   "material.RadioButton",
		Argsn: 4,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-radio-button: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-radio-button: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-radio-button: arg 1: expected native")
			}
			var arg1Val *widget.Enum
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Enum)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-radio-button: arg 2: expected native of type *widget.Enum")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-radio-button: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-radio-button: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-radio-button: arg 3: expected string")
			}
			var arg3Val string
			if v, ok := arg3.(env.String); ok {
				arg3Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-radio-button: arg 4: expected string")
			}
			res0 := material.RadioButton(arg0Val, arg1Val, arg2Val, arg3Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.RadioButtonStyle)")
			return res0Obj
		},
	},
	"material-scrollbar": {
		Doc:   "material.Scrollbar",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-scrollbar: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-scrollbar: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-scrollbar: arg 1: expected native")
			}
			var arg1Val *widget.Scrollbar
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Scrollbar)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-scrollbar: arg 2: expected native of type *widget.Scrollbar")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-scrollbar: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-scrollbar: arg 2: expected native")
			}
			res0 := material.Scrollbar(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.ScrollbarStyle)")
			return res0Obj
		},
	},
	"material-slider": {
		Doc:   "material.Slider",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-slider: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-slider: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-slider: arg 1: expected native")
			}
			var arg1Val *widget.Float
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Float)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-slider: arg 2: expected native of type *widget.Float")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-slider: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-slider: arg 2: expected native")
			}
			res0 := material.Slider(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.SliderStyle)")
			return res0Obj
		},
	},
	"material-subtitle-1": {
		Doc:   "material.Subtitle1",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-subtitle-1: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-subtitle-1: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-subtitle-1: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-subtitle-1: arg 2: expected string")
			}
			res0 := material.Subtitle1(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-subtitle-2": {
		Doc:   "material.Subtitle2",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-subtitle-2: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-subtitle-2: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-subtitle-2: arg 1: expected native")
			}
			var arg1Val string
			if v, ok := arg1.(env.String); ok {
				arg1Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-subtitle-2: arg 2: expected string")
			}
			res0 := material.Subtitle2(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.LabelStyle)")
			return res0Obj
		},
	},
	"material-switch": {
		Doc:   "material.Switch",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *material.Theme
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*material.Theme)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-switch: arg 1: expected native of type *material.Theme")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-switch: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-switch: arg 1: expected native")
			}
			var arg1Val *widget.Bool
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*widget.Bool)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("material-switch: arg 2: expected native of type *widget.Bool")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("material-switch: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("material-switch: arg 2: expected native")
			}
			var arg2Val string
			if v, ok := arg2.(env.String); ok {
				arg2Val = string(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("material-switch: arg 3: expected string")
			}
			res0 := material.Switch(arg0Val, arg1Val, arg2Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*material.SwitchStyle)")
			return res0Obj
		},
	},
	"op-affine": {
		Doc:   "op.Affine",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *f32.Affine2D
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*f32.Affine2D)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("op-affine: arg 1: expected native of type *f32.Affine2D")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("op-affine: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("op-affine: arg 1: expected native")
			}
			res0 := op.Affine(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*op.TransformOp)")
			return res0Obj
		},
	},
	"op-defer": {
		Doc:   "op.Defer",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.Ops
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("op-defer: arg 1: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("op-defer: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("op-defer: arg 1: expected native")
			}
			var arg1Val *op.CallOp
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(*op.CallOp)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("op-defer: arg 2: expected native of type *op.CallOp")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("op-defer: arg 2: expected integer to be 0 or nil")
				}
				arg1Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("op-defer: arg 2: expected native")
			}
			op.Defer(arg0Val, *arg1Val)
			return nil
		},
	},
	"op-call-op": {
		Doc:   "Create a new op.CallOp struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &op.CallOp{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*op.CallOp)")
			return resObj
		},
	},
	"op-invalidate-cmd": {
		Doc:   "Create a new op.InvalidateCmd struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &op.InvalidateCmd{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*op.InvalidateCmd)")
			return resObj
		},
	},
	"op-macro-op": {
		Doc:   "Create a new op.MacroOp struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &op.MacroOp{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*op.MacroOp)")
			return resObj
		},
	},
	"op-ops": {
		Doc:   "Create a new op.Ops struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &op.Ops{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*op.Ops)")
			return resObj
		},
	},
	"op-transform-op": {
		Doc:   "Create a new op.TransformOp struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &op.TransformOp{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*op.TransformOp)")
			return resObj
		},
	},
	"op-transform-stack": {
		Doc:   "Create a new op.TransformStack struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &op.TransformStack{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*op.TransformStack)")
			return resObj
		},
	},
	"op-offset": {
		Doc:   "op.Offset",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Point
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Point)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("op-offset: arg 1: expected native of type image.Point")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("op-offset: arg 1: expected native")
			}
			res0 := op.Offset(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*op.TransformOp)")
			return res0Obj
		},
	},
	"op-record": {
		Doc:   "op.Record",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.Ops
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("op-record: arg 1: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("op-record: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("op-record: arg 1: expected native")
			}
			res0 := op.Record(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*op.MacroOp)")
			return res0Obj
		},
	},
	"opentype-description-to-font": {
		Doc:   "opentype.DescriptionToFont",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val metadata.Description
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(metadata.Description)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("opentype-description-to-font: arg 1: expected native of type metadata.Description")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("opentype-description-to-font: arg 1: expected native")
			}
			res0 := opentype.DescriptionToFont(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*font.Font)")
			return res0Obj
		},
	},
	"opentype-font-to-description": {
		Doc:   "opentype.FontToDescription",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *font.Font
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*font.Font)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("opentype-font-to-description: arg 1: expected native of type *font.Font")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("opentype-font-to-description: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("opentype-font-to-description: arg 1: expected native")
			}
			res0 := opentype.FontToDescription(*arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(metadata.Description)")
			return res0Obj
		},
	},
	"opentype-face": {
		Doc:   "Create a new opentype.Face struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &opentype.Face{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*opentype.Face)")
			return resObj
		},
	},
	"opentype-parse": {
		Doc:   "opentype.Parse",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("opentype-parse: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("opentype-parse: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("opentype-parse: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("opentype-parse: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("opentype-parse: arg 1: expected block, native or nil")
			}
			res0, resErr := opentype.Parse(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*opentype.Face)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"opentype-parse-collection": {
		Doc:   "opentype.ParseCollection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("opentype-parse-collection: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("opentype-parse-collection: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("opentype-parse-collection: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("opentype-parse-collection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("opentype-parse-collection: arg 1: expected block, native or nil")
			}
			res0, resErr := opentype.ParseCollection(arg0Val)
			var res0Obj env.Object
			{
				items := make([]env.Object, len(res0))
				for i, it := range res0 {
					items[i] = *env.NewNative(ps.Idx, it, "Go(font.FontFace)")
				}
				res0Obj = *env.NewBlock(*env.NewTSeries(items))
			}
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"paint-fill": {
		Doc:   "paint.Fill",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.Ops
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("paint-fill: arg 1: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("paint-fill: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("paint-fill: arg 1: expected native")
			}
			var arg1Val color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("paint-fill: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("paint-fill: arg 2: expected native")
			}
			paint.Fill(arg0Val, arg1Val)
			return nil
		},
	},
	"paint-fill-shape": {
		Doc:   "paint.FillShape",
		Argsn: 3,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.Ops
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("paint-fill-shape: arg 1: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("paint-fill-shape: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("paint-fill-shape: arg 1: expected native")
			}
			var arg1Val color.NRGBA
			switch v := arg1.(type) {
			case env.Native:
				var ok bool
				arg1Val, ok = v.Value.(color.NRGBA)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("paint-fill-shape: arg 2: expected native of type color.NRGBA")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("paint-fill-shape: arg 2: expected native")
			}
			var arg2Val *clip.Op
			switch v := arg2.(type) {
			case env.Native:
				var ok bool
				arg2Val, ok = v.Value.(*clip.Op)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("paint-fill-shape: arg 3: expected native of type *clip.Op")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("paint-fill-shape: arg 3: expected integer to be 0 or nil")
				}
				arg2Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("paint-fill-shape: arg 3: expected native")
			}
			paint.FillShape(arg0Val, arg1Val, *arg2Val)
			return nil
		},
	},
	"paint-filter-linear": {
		Doc:   "Get paint.FilterLinear value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(paint.FilterLinear), "Go(byte)")
			return resObj
		},
	},
	"paint-filter-nearest": {
		Doc:   "Get paint.FilterNearest value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(paint.FilterNearest), "Go(byte)")
			return resObj
		},
	},
	"paint-color-op": {
		Doc:   "Create a new paint.ColorOp struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &paint.ColorOp{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*paint.ColorOp)")
			return resObj
		},
	},
	"paint-image-op": {
		Doc:   "paint.NewImageOp",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val image.Image
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(image.Image)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("paint-image-op: arg 1: expected native of type image.Image")
				}
			default:
				ps.FailureFlag = true
				return env.NewError("paint-image-op: arg 1: expected native")
			}
			res0 := paint.NewImageOp(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*paint.ImageOp)")
			return res0Obj
		},
	},
	"paint-linear-gradient-op": {
		Doc:   "Create a new paint.LinearGradientOp struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &paint.LinearGradientOp{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*paint.LinearGradientOp)")
			return resObj
		},
	},
	"paint-opacity-stack": {
		Doc:   "Create a new paint.OpacityStack struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &paint.OpacityStack{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*paint.OpacityStack)")
			return resObj
		},
	},
	"paint-paint-op": {
		Doc:   "Create a new paint.PaintOp struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &paint.PaintOp{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*paint.PaintOp)")
			return resObj
		},
	},
	"paint-push-opacity": {
		Doc:   "paint.PushOpacity",
		Argsn: 2,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val *op.Ops
			switch v := arg0.(type) {
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.(*op.Ops)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("paint-push-opacity: arg 1: expected native of type *op.Ops")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("paint-push-opacity: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("paint-push-opacity: arg 1: expected native")
			}
			var arg1Val float32
			if v, ok := arg1.(env.Decimal); ok {
				arg1Val = float32(v.Value)
			} else {
				ps.FailureFlag = true
				return env.NewError("paint-push-opacity: arg 2: expected decimal")
			}
			res0 := paint.PushOpacity(arg0Val, arg1Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, &res0, "Go(*paint.OpacityStack)")
			return res0Obj
		},
	},
	"pointer-button-primary": {
		Doc:   "Get pointer.ButtonPrimary value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(pointer.ButtonPrimary)))
			return resObj
		},
	},
	"pointer-button-secondary": {
		Doc:   "Get pointer.ButtonSecondary value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(pointer.ButtonSecondary)))
			return resObj
		},
	},
	"pointer-button-tertiary": {
		Doc:   "Get pointer.ButtonTertiary value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(pointer.ButtonTertiary)))
			return resObj
		},
	},
	"pointer-cancel": {
		Doc:   "Get pointer.Cancel value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(pointer.Cancel)))
			return resObj
		},
	},
	"pointer-cursor-all-scroll": {
		Doc:   "Get pointer.CursorAllScroll value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorAllScroll), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-col-resize": {
		Doc:   "Get pointer.CursorColResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorColResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-crosshair": {
		Doc:   "Get pointer.CursorCrosshair value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorCrosshair), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-default": {
		Doc:   "Get pointer.CursorDefault value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorDefault), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-east-resize": {
		Doc:   "Get pointer.CursorEastResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorEastResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-east-west-resize": {
		Doc:   "Get pointer.CursorEastWestResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorEastWestResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-grab": {
		Doc:   "Get pointer.CursorGrab value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorGrab), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-grabbing": {
		Doc:   "Get pointer.CursorGrabbing value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorGrabbing), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-none": {
		Doc:   "Get pointer.CursorNone value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorNone), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-north-east-resize": {
		Doc:   "Get pointer.CursorNorthEastResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorNorthEastResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-north-east-south-west-resize": {
		Doc:   "Get pointer.CursorNorthEastSouthWestResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorNorthEastSouthWestResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-north-resize": {
		Doc:   "Get pointer.CursorNorthResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorNorthResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-north-south-resize": {
		Doc:   "Get pointer.CursorNorthSouthResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorNorthSouthResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-north-west-resize": {
		Doc:   "Get pointer.CursorNorthWestResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorNorthWestResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-north-west-south-east-resize": {
		Doc:   "Get pointer.CursorNorthWestSouthEastResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorNorthWestSouthEastResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-not-allowed": {
		Doc:   "Get pointer.CursorNotAllowed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorNotAllowed), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-pointer": {
		Doc:   "Get pointer.CursorPointer value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorPointer), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-progress": {
		Doc:   "Get pointer.CursorProgress value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorProgress), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-row-resize": {
		Doc:   "Get pointer.CursorRowResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorRowResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-south-east-resize": {
		Doc:   "Get pointer.CursorSouthEastResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorSouthEastResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-south-resize": {
		Doc:   "Get pointer.CursorSouthResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorSouthResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-south-west-resize": {
		Doc:   "Get pointer.CursorSouthWestResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorSouthWestResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-text": {
		Doc:   "Get pointer.CursorText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorText), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-vertical-text": {
		Doc:   "Get pointer.CursorVerticalText value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorVerticalText), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-wait": {
		Doc:   "Get pointer.CursorWait value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorWait), "Go(byte)")
			return resObj
		},
	},
	"pointer-cursor-west-resize": {
		Doc:   "Get pointer.CursorWestResize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(pointer.CursorWestResize), "Go(byte)")
			return resObj
		},
	},
	"pointer-drag": {
		Doc:   "Get pointer.Drag value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(pointer.Drag)))
			return resObj
		},
	},
	"pointer-enter": {
		Doc:   "Get pointer.Enter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(pointer.Enter)))
			return resObj
		},
	},
	"pointer-foremost": {
		Doc:   "Get pointer.Foremost value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(pointer.Foremost)))
			return resObj
		},
	},
	"pointer-grabbed": {
		Doc:   "Get pointer.Grabbed value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(pointer.Grabbed)))
			return resObj
		},
	},
	"pointer-leave": {
		Doc:   "Get pointer.Leave value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(pointer.Leave)))
			return resObj
		},
	},
	"pointer-mouse": {
		Doc:   "Get pointer.Mouse value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(pointer.Mouse)))
			return resObj
		},
	},
	"pointer-move": {
		Doc:   "Get pointer.Move value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(pointer.Move)))
			return resObj
		},
	},
	"pointer-event": {
		Doc:   "Create a new pointer.Event struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &pointer.Event{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*pointer.Event)")
			return resObj
		},
	},
	"pointer-filter": {
		Doc:   "Create a new pointer.Filter struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &pointer.Filter{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*pointer.Filter)")
			return resObj
		},
	},
	"pointer-grab-cmd": {
		Doc:   "Create a new pointer.GrabCmd struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &pointer.GrabCmd{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*pointer.GrabCmd)")
			return resObj
		},
	},
	"pointer-pass-op": {
		Doc:   "Create a new pointer.PassOp struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &pointer.PassOp{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*pointer.PassOp)")
			return resObj
		},
	},
	"pointer-pass-stack": {
		Doc:   "Create a new pointer.PassStack struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &pointer.PassStack{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*pointer.PassStack)")
			return resObj
		},
	},
	"pointer-scroll-range": {
		Doc:   "Create a new pointer.ScrollRange struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &pointer.ScrollRange{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*pointer.ScrollRange)")
			return resObj
		},
	},
	"pointer-press": {
		Doc:   "Get pointer.Press value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(pointer.Press)))
			return resObj
		},
	},
	"pointer-release": {
		Doc:   "Get pointer.Release value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(pointer.Release)))
			return resObj
		},
	},
	"pointer-scroll": {
		Doc:   "Get pointer.Scroll value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(pointer.Scroll)))
			return resObj
		},
	},
	"pointer-shared": {
		Doc:   "Get pointer.Shared value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(pointer.Shared)))
			return resObj
		},
	},
	"pointer-touch": {
		Doc:   "Get pointer.Touch value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(pointer.Touch)))
			return resObj
		},
	},
	"semantic-button": {
		Doc:   "Get semantic.Button value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(semantic.Button)))
			return resObj
		},
	},
	"semantic-check-box": {
		Doc:   "Get semantic.CheckBox value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(semantic.CheckBox)))
			return resObj
		},
	},
	"semantic-editor": {
		Doc:   "Get semantic.Editor value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(semantic.Editor)))
			return resObj
		},
	},
	"semantic-radio-button": {
		Doc:   "Get semantic.RadioButton value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(semantic.RadioButton)))
			return resObj
		},
	},
	"semantic-switch": {
		Doc:   "Get semantic.Switch value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(semantic.Switch)))
			return resObj
		},
	},
	"semantic-unknown": {
		Doc:   "Get semantic.Unknown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(int(semantic.Unknown)))
			return resObj
		},
	},
	"system-action-center": {
		Doc:   "Get system.ActionCenter value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(system.ActionCenter)))
			return resObj
		},
	},
	"system-action-close": {
		Doc:   "Get system.ActionClose value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(system.ActionClose)))
			return resObj
		},
	},
	"system-action-fullscreen": {
		Doc:   "Get system.ActionFullscreen value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(system.ActionFullscreen)))
			return resObj
		},
	},
	"system-action-maximize": {
		Doc:   "Get system.ActionMaximize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(system.ActionMaximize)))
			return resObj
		},
	},
	"system-action-minimize": {
		Doc:   "Get system.ActionMinimize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(system.ActionMinimize)))
			return resObj
		},
	},
	"system-action-move": {
		Doc:   "Get system.ActionMove value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(system.ActionMove)))
			return resObj
		},
	},
	"system-action-raise": {
		Doc:   "Get system.ActionRaise value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(system.ActionRaise)))
			return resObj
		},
	},
	"system-action-unmaximize": {
		Doc:   "Get system.ActionUnmaximize value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint(system.ActionUnmaximize)))
			return resObj
		},
	},
	"system-from-origin": {
		Doc:   "Get system.FromOrigin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(system.FromOrigin), "Go(byte)")
			return resObj
		},
	},
	"system-horizontal": {
		Doc:   "Get system.Horizontal value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(system.Horizontal), "Go(byte)")
			return resObj
		},
	},
	"system-ltr": {
		Doc:   "Get system.LTR value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(system.LTR), "Go(byte)")
			return resObj
		},
	},
	"system-locale": {
		Doc:   "Create a new system.Locale struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &system.Locale{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*system.Locale)")
			return resObj
		},
	},
	"system-rtl": {
		Doc:   "Get system.RTL value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(system.RTL), "Go(byte)")
			return resObj
		},
	},
	"system-toward-origin": {
		Doc:   "Get system.TowardOrigin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(system.TowardOrigin), "Go(byte)")
			return resObj
		},
	},
	"system-vertical": {
		Doc:   "Get system.Vertical value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, byte(system.Vertical), "Go(byte)")
			return resObj
		},
	},
	"text-end": {
		Doc:   "Get text.End value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text.End)))
			return resObj
		},
	},
	"text-flag-cluster-break": {
		Doc:   "Get text.FlagClusterBreak value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint16(text.FlagClusterBreak)))
			return resObj
		},
	},
	"text-flag-line-break": {
		Doc:   "Get text.FlagLineBreak value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint16(text.FlagLineBreak)))
			return resObj
		},
	},
	"text-flag-paragraph-break": {
		Doc:   "Get text.FlagParagraphBreak value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint16(text.FlagParagraphBreak)))
			return resObj
		},
	},
	"text-flag-paragraph-start": {
		Doc:   "Get text.FlagParagraphStart value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint16(text.FlagParagraphStart)))
			return resObj
		},
	},
	"text-flag-run-break": {
		Doc:   "Get text.FlagRunBreak value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint16(text.FlagRunBreak)))
			return resObj
		},
	},
	"text-flag-toward-origin": {
		Doc:   "Get text.FlagTowardOrigin value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint16(text.FlagTowardOrigin)))
			return resObj
		},
	},
	"text-flag-truncator": {
		Doc:   "Get text.FlagTruncator value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint16(text.FlagTruncator)))
			return resObj
		},
	},
	"text-middle": {
		Doc:   "Get text.Middle value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text.Middle)))
			return resObj
		},
	},
	"text-glyph": {
		Doc:   "Create a new text.Glyph struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.Glyph{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*text.Glyph)")
			return resObj
		},
	},
	"text-parameters": {
		Doc:   "Create a new text.Parameters struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.Parameters{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*text.Parameters)")
			return resObj
		},
	},
	"text-range": {
		Doc:   "Create a new text.Range struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &text.Range{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*text.Range)")
			return resObj
		},
	},
	"text-shaper": {
		Doc:   "text.NewShaper",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []text.ShaperOption
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text.ShaperOption, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal text.ShaperOption
						if natOk {
							natVal, natValOk = nat.Value.(text.ShaperOption)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u func(*text.Shaper)
							switch fn := it.(type) {
							case env.Function:
								if fn.Argsn != 1 {
									ps.FailureFlag = true
									return env.NewError("text-shaper: arg 1: block item: function has invalid number of arguments (expected 1)")
								}
								u = func(farg0 *text.Shaper) {
									var farg0Val env.Object
									farg0Val = *env.NewNative(ps.Idx, farg0, "Go(*text.Shaper)")
									actualFn := fn
									_ = actualFn
									evaldo.CallFunctionArgsN(fn, ps, ps.Ctx, farg0Val)
								}
							case env.Integer:
								if fn.Value != 0 {
									ps.FailureFlag = true
									return env.NewError("text-shaper: arg 1: block item: expected integer to be 0 or nil")
								}
								u = nil
							default:
								ps.FailureFlag = true
								return env.NewError("text-shaper: arg 1: block item: expected function or nil")
							}
							arg0Val[i] = text.ShaperOption(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]text.ShaperOption)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-shaper: arg 1: expected native of type []text.ShaperOption")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-shaper: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-shaper: arg 1: expected block, native or nil")
			}
			res0 := text.NewShaper(arg0Val...)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*text.Shaper)")
			return res0Obj
		},
	},
	"text-no-system-fonts": {
		Doc:   "text.NoSystemFonts",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res0 := text.NoSystemFonts()
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *text.Shaper
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*text.Shaper)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("text-no-system-fonts: arg 1: expected native of type *text.Shaper")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("text-no-system-fonts: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("text-no-system-fonts: arg 1: expected native")
				}
				(func(*text.Shaper))(res0)(arg0Val)
				return nil
			}, 1, false, false, "Returned func")
			return res0Obj
		},
	},
	"text-start": {
		Doc:   "Get text.Start value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text.Start)))
			return resObj
		},
	},
	"text-with-collection": {
		Doc:   "text.WithCollection",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []text.FontFace
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]text.FontFace, len(v.Series.S))
				for i, it := range v.Series.S {
					{
						nat, natOk := it.(env.Native)
						var natValOk bool
						var natVal text.FontFace
						if natOk {
							natVal, natValOk = nat.Value.(text.FontFace)
						}
						if natValOk {
							arg0Val[i] = natVal
						} else {
							var u font.FontFace
							switch v := it.(type) {
							case env.Native:
								var ok bool
								u, ok = v.Value.(font.FontFace)
								if !ok {
									ps.FailureFlag = true
									return env.NewError("text-with-collection: arg 1: block item: expected native of type font.FontFace")
								}
							default:
								ps.FailureFlag = true
								return env.NewError("text-with-collection: arg 1: block item: expected native")
							}
							arg0Val[i] = text.FontFace(u)
						}
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]text.FontFace)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("text-with-collection: arg 1: expected native of type []text.FontFace")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("text-with-collection: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("text-with-collection: arg 1: expected block, native or nil")
			}
			res0 := text.WithCollection(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewBuiltin(func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
				var arg0Val *text.Shaper
				switch v := arg0.(type) {
				case env.Native:
					var ok bool
					arg0Val, ok = v.Value.(*text.Shaper)
					if !ok {
						ps.FailureFlag = true
						return env.NewError("text-with-collection: arg 1: expected native of type *text.Shaper")
					}
				case env.Integer:
					if v.Value != 0 {
						ps.FailureFlag = true
						return env.NewError("text-with-collection: arg 1: expected integer to be 0 or nil")
					}
					arg0Val = nil
				default:
					ps.FailureFlag = true
					return env.NewError("text-with-collection: arg 1: expected native")
				}
				(func(*text.Shaper))(res0)(arg0Val)
				return nil
			}, 1, false, false, "Returned func")
			return res0Obj
		},
	},
	"text-wrap-graphemes": {
		Doc:   "Get text.WrapGraphemes value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text.WrapGraphemes)))
			return resObj
		},
	},
	"text-wrap-heuristically": {
		Doc:   "Get text.WrapHeuristically value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text.WrapHeuristically)))
			return resObj
		},
	},
	"text-wrap-words": {
		Doc:   "Get text.WrapWords value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(text.WrapWords)))
			return resObj
		},
	},
	"transfer-cancel-event": {
		Doc:   "Create a new transfer.CancelEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &transfer.CancelEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*transfer.CancelEvent)")
			return resObj
		},
	},
	"transfer-data-event": {
		Doc:   "Create a new transfer.DataEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &transfer.DataEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*transfer.DataEvent)")
			return resObj
		},
	},
	"transfer-initiate-event": {
		Doc:   "Create a new transfer.InitiateEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &transfer.InitiateEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*transfer.InitiateEvent)")
			return resObj
		},
	},
	"transfer-offer-cmd": {
		Doc:   "Create a new transfer.OfferCmd struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &transfer.OfferCmd{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*transfer.OfferCmd)")
			return resObj
		},
	},
	"transfer-request-event": {
		Doc:   "Create a new transfer.RequestEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &transfer.RequestEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*transfer.RequestEvent)")
			return resObj
		},
	},
	"transfer-source-filter": {
		Doc:   "Create a new transfer.SourceFilter struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &transfer.SourceFilter{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*transfer.SourceFilter)")
			return resObj
		},
	},
	"transfer-target-filter": {
		Doc:   "Create a new transfer.TargetFilter struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &transfer.TargetFilter{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*transfer.TargetFilter)")
			return resObj
		},
	},
	"unit-metric": {
		Doc:   "Create a new unit.Metric struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &unit.Metric{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*unit.Metric)")
			return resObj
		},
	},
	"widget-contain": {
		Doc:   "Get widget.Contain value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(widget.Contain)))
			return resObj
		},
	},
	"widget-cover": {
		Doc:   "Get widget.Cover value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(widget.Cover)))
			return resObj
		},
	},
	"widget-fill": {
		Doc:   "Get widget.Fill value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(widget.Fill)))
			return resObj
		},
	},
	"widget-bool": {
		Doc:   "Create a new widget.Bool struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Bool{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Bool)")
			return resObj
		},
	},
	"widget-border": {
		Doc:   "Create a new widget.Border struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Border{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Border)")
			return resObj
		},
	},
	"widget-change-event": {
		Doc:   "Create a new widget.ChangeEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.ChangeEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.ChangeEvent)")
			return resObj
		},
	},
	"widget-click": {
		Doc:   "Create a new widget.Click struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Click{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Click)")
			return resObj
		},
	},
	"widget-clickable": {
		Doc:   "Create a new widget.Clickable struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Clickable{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Clickable)")
			return resObj
		},
	},
	"widget-decorations": {
		Doc:   "Create a new widget.Decorations struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Decorations{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Decorations)")
			return resObj
		},
	},
	"widget-draggable": {
		Doc:   "Create a new widget.Draggable struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Draggable{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Draggable)")
			return resObj
		},
	},
	"widget-editor": {
		Doc:   "Create a new widget.Editor struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Editor{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Editor)")
			return resObj
		},
	},
	"widget-enum": {
		Doc:   "Create a new widget.Enum struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Enum{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Enum)")
			return resObj
		},
	},
	"widget-float": {
		Doc:   "Create a new widget.Float struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Float{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Float)")
			return resObj
		},
	},
	"widget-icon": {
		Doc:   "widget.NewIcon",
		Argsn: 1,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var arg0Val []byte
			switch v := arg0.(type) {
			case env.Block:
				arg0Val = make([]byte, len(v.Series.S))
				for i, it := range v.Series.S {
					switch v := it.(type) {
					case env.Native:
						var ok bool
						arg0Val[i], ok = v.Value.(byte)
						if !ok {
							ps.FailureFlag = true
							return env.NewError("widget-icon: arg 1: block item: expected native of type byte")
						}
					default:
						ps.FailureFlag = true
						return env.NewError("widget-icon: arg 1: block item: expected native")
					}
				}
			case env.Native:
				var ok bool
				arg0Val, ok = v.Value.([]byte)
				if !ok {
					ps.FailureFlag = true
					return env.NewError("widget-icon: arg 1: expected native of type []byte")
				}
			case env.Integer:
				if v.Value != 0 {
					ps.FailureFlag = true
					return env.NewError("widget-icon: arg 1: expected integer to be 0 or nil")
				}
				arg0Val = nil
			default:
				ps.FailureFlag = true
				return env.NewError("widget-icon: arg 1: expected block, native or nil")
			}
			res0, resErr := widget.NewIcon(arg0Val)
			var res0Obj env.Object
			res0Obj = *env.NewNative(ps.Idx, res0, "Go(*widget.Icon)")
			var resErrObj env.Object
			if resErr != nil {
				resErrObj = env.NewError(resErr.Error())
			}
			if resErrObj != nil {
				ps.FailureFlag = true
				return resErrObj
			}
			return res0Obj
		},
	},
	"widget-image": {
		Doc:   "Create a new widget.Image struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Image{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Image)")
			return resObj
		},
	},
	"widget-label": {
		Doc:   "Create a new widget.Label struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Label{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Label)")
			return resObj
		},
	},
	"widget-list": {
		Doc:   "Create a new widget.List struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.List{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.List)")
			return resObj
		},
	},
	"widget-press": {
		Doc:   "Create a new widget.Press struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Press{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Press)")
			return resObj
		},
	},
	"widget-region": {
		Doc:   "Create a new widget.Region struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Region{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Region)")
			return resObj
		},
	},
	"widget-scrollbar": {
		Doc:   "Create a new widget.Scrollbar struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Scrollbar{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Scrollbar)")
			return resObj
		},
	},
	"widget-select-event": {
		Doc:   "Create a new widget.SelectEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.SelectEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.SelectEvent)")
			return resObj
		},
	},
	"widget-selectable": {
		Doc:   "Create a new widget.Selectable struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.Selectable{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.Selectable)")
			return resObj
		},
	},
	"widget-submit-event": {
		Doc:   "Create a new widget.SubmitEvent struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.SubmitEvent{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.SubmitEvent)")
			return resObj
		},
	},
	"widget-text-info": {
		Doc:   "Create a new widget.TextInfo struct",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			res := &widget.TextInfo{}
			var resObj env.Object
			resObj = *env.NewNative(ps.Idx, res, "Go(*widget.TextInfo)")
			return resObj
		},
	},
	"widget-scale-down": {
		Doc:   "Get widget.ScaleDown value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(widget.ScaleDown)))
			return resObj
		},
	},
	"widget-unscaled": {
		Doc:   "Get widget.Unscaled value",
		Argsn: 0,
		Fn: func(ps *env.ProgramState, arg0, arg1, arg2, arg3, arg4 env.Object) env.Object {
			var resObj env.Object
			resObj = *env.NewInteger(int64(uint8(widget.Unscaled)))
			return resObj
		},
	},
}
